<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook V3.1//EN" [
  <!ENTITY TONTO "TONTO">
  <!ENTITY foo "<emphasis>foo</emphasis>">
  <!ENTITY Foo "<emphasis>Foo</emphasis>">
]>

<book id="Tonto">
<title>Tonto</title>
<bookinfo>
  <mediaobject>
    <imageobject>
      <imagedata fileref="logo.pdf" align="center" scale="120" scalefit="1">
    </imageobject>
    <imageobject>
      <imagedata fileref="../logo_400.png">
    </imageobject>
    <textobject>
      <phrase>Tonto</phrase>
    </textobject>
  </mediaobject>
  <authorgroup>
    <author>
      <firstname>Dylan</firstname><surname>Jayatilaka</surname>
    </author>
    <author>
      <firstname>Daniel</firstname><othername>James</othername><surname>Grimwood</surname>
    </author>
  </authorgroup>
  <address>
    <email>tonto@crystal.uwa.edu.au</email>
  </address>
  <copyright>
    <year>2000</year>
    <year>2001</year>
    <year>2002</year>
    <holder>Dylan Jayatilaka</holder>
  </copyright>
</bookinfo>

<!-- *********************************************************************** -->
<!-- *********************************************************************** -->

<chapter id="Overview">
  <title>An Overview of &TONTO;</title>

<!-- *********************************************************************** -->

<sect1 id="Welcome-to-TONTO">
<title>Welcome to &TONTO;</title>

<para>&TONTO; is a computer package for "doing" computational chemistry.  It is
the embodiment of a grandiose scheme to make computational chemistry
quicker, easier, and more fun to do.</para>

<para>The idea is to provide useful, well documented and efficient "blocks" of
code that can easily be "put together" in as many ways as the user can imagine.
</para>

<para>&TONTO; is copyleft under the less restrictive GNU library license.  It is
officially, and forever, free software.</para>

<para>This document is a complete introduction and manual to the &TONTO; system.
It is suitable for beginners and experts, users and programmers.  To get some
idea of whether &TONTO; may be of any use to you, and to understand how to use
it, you should at least read this introductory chapter.</para>
</sect1>

<!-- *********************************************************************** -->

<sect1 id="TONTO-purpose">
<title>The mission of &TONTO;</title>

<para> The name &TONTO; <footnote><para>The name was suggested by Anthony
Russell</para></footnote> means "idiot" in Spanish. That name was chosen because
the main aim of &TONTO; is to be simple <footnote><para>For non-english
speakers: Tonto was also the name of the Lone Ranger's trusty Indian companion
in a famous wild-west TV series</para></footnote>.</para>

<para>
More specifically, the main aims of &TONTO; are, in order of priority:
<itemizedlist>
  <listitem>
    <para>To provide useful tools for computational chemistry</para>
  </listitem>
  <listitem>
    <para>To be simple to use, understand, maintain, and modify</para>
  </listitem>
  <listitem>
    <para>To be efficient</para>
  </listitem>
</itemizedlist>
</para>

<para>Note that, for &TONTO;, simplicity is regarded as more important than
efficiency. A few words should be said about this rather strange
decision.</para>

<para>It cannot be denied that computational chemistry calculations are usually
very time consuming. In order to reduce calculation time it is desirable to use
complex but efficient algorithms. Thus, the objective of simplicity may be in
conflict with the objective of efficiency. Getting the balance between these two
issues is always tricky.</para>

<para>This is how we resolve the conflict in &TONTO; : </para>

<para>If it is not possible to provide a single piece of code which is both
simple and highly efficiency, we try to provide two equivalent routines: one
simple, the other efficient.  We regard simplicity as being more important that
efficiency because, although it may be possible to achieve speedup in a certain
calculation of a factor of 5-10 or so by optimisation of the implementation of
an algorithm by complex code manipulations to take advantage of compiler or
hardware features, to go beyond this requires a fundamental change in the
algorithm itself.  When such a fundamental change is required, it is better to
have a simple code so that the parts that do not need to change can be easily
identified.</para>
</sect1>

<!-- *********************************************************************** -->

<sect1 id="tonto-who">
  <title>Who is &TONTO; for?</title>

<para>&TONTO; is intended mainly for computational chemists with new ideas, but
who are discouraged by the time it might take to understand and modify old,
monolithic programs to do what they want.</para>

<para>&TONTO; provides many useful modules covering all of the basic needs in
the field of quantum chemistry, including interfaces to the data archives of
other programs; and because it has excellent documentation, &TONTO; is a very
attractive starting point for the implementation of new algorithms and
interdisciplinary projects in computational chemistry.</para>

<para>In short, you don't have to reinvent the wheel to program in &TONTO;.
</para>

<para>However, although &TONTO; is for the people who mainly write code, it is
still very easy to use for the novice.</para>
</sect1>

<!-- *********************************************************************** -->

<sect1 id="tonto-compare">
  <title>How is &TONTO; different from other packages?</title>

<para>&TONTO; is different from other computational chemistry packages because
it is primarily (but not exclusively) concerned with calculations in
<command>quantum crystallography</command>.  The aim of this field is to derive
accurate wavefunctions by incorporating X-ray, polarised neutron, or other
diffraction and scattering data directly into the method for determining the
wavefunction.  </para>

<para>Another important feature of &TONTO; is that <command>it has been
implemented in an object oriented language</command> called
<emphasis>foo</emphasis> which translates into Fortran95
<footnote><para><emphasis>Foo</emphasis> stands for object oriented Fortran in
reverse, since true object orientation is not really possible in Fortran just
yet. In any case, some of the features in <emphasis>foo</emphasis> go beyond
what will shortly become available in the current Fortran 2x
standard</para></footnote>.  <emphasis>Foo</emphasis> makes the process of
maintaining and documenting the &TONTO; system automatic. In particular, the
online WWW documentation is generated directly from the code.</para>

<para>There is no guarantee that &TONTO; will remain translated into Fortran95.
A translation into C, or another object oriented language, would also be
relatively easy and may be required at a later date in the event that Fortran
ceases to be the best option for fast code.  Thus, <command>the lifespan of code written
in &TONTO; can be expected to be quite long</command>.</para>

<para>The best feature of &TONTO; is that it is <command>free</command>. The
modules of &TONTO; can be used without modification in your own work,
<emphasis>commercial or otherwise</emphasis><footnote><para> However, if you
modify the routines you can only distribute the modified work with your own
under the terms of the GNU library license</para></footnote>.</para>
</sect1>

<!-- *********************************************************************** -->

<sect1 id="tonto-what">
  <title>What can &TONTO; do&quest;</title>

<para>This depends on whether you are a user or a programmer.</para>

<para>As a user, you can do the following types of calculations:
<itemizedlist>
<listitem><para>Hartree-Fock/density functional molecular calculations of all
types except general restricted Hartree-Fock, using gaussian basis
sets.</para></listitem>
<listitem><para>Density plots of various kinds:
charge, spin, orbital, current, solenoidal current, irrotational current,
electric potential, and ELF density plots, Fermi mobility function plots for all
types of gaussian basis sets, density matrices</para></listitem>
<listitem><para>Density plots, as above, for non-interacting molecules in any
crystal spacegroup.</para></listitem>
<listitem><para>Vibrationally averaged density plots, as above, for diatomics.
</para></listitem>
<listitem><para>Mulliken and Roby population analyses.</para></listitem>
<listitem><para>Decomposition of the SCF energy into orbital and orbital pair
contributions.</para></listitem>
<listitem><para>Elastic X-ray and PND scattering intensities calculated from
non-interacting Hartree-Fock/density functional theory molecular wavefunctions
in any spacegroup.  </para></listitem>
<listitem><para>Non-interacting Hartree-Fock/density functional theory molecular
wavefunctions fitted to X-ray and PND scattering data in any
spacegroup.</para></listitem>
</itemizedlist></para>

<para>As a programmer, you have access to a number of programming tools:
<itemizedlist>
<listitem><para>Automated object oriented features such as automatic
overloading, routine pre- and post-conditiond, code inheritance and parameterised types,
and closures.</para></listitem> 
<listitem><para>Advanced editing facilities, with syntax recognition and
highlighting, routine recognition and browsing.
module.</para></listitem> 
<listitem><para>Comprehensive online HTML documentation for every
module.</para></listitem> 
<listitem><para>An integrated compile and build procedure.</para></listitem> 
<listitem><para>The ability to make custom debug or optimised executables,
including automatic checking for memory leaks, and full error reporting with
routine tracebacks and call-stack management.</para></listitem> 
<listitem><para>
Automatic checking for memory leaks, and full error reporting with
routine tracebacks.</para></listitem> 
<listitem><para>comprehensive online documentation for every
module.</para></listitem> 
</itemizedlist></para>

<para>For the programmer, the modules available define objects which deal with:
<itemizedlist>
<listitem><para>Error handling, and memory management, call-stack management,
and timing.</para></listitem>
<listitem><para>Basic type (integer, double precision, and string) manipulation.
</para></listitem>
<listitem><para>Vectors, matrices, and multidimensional arrays of all types.
</para></listitem>
<listitem><para>Binary, text, and archive files.</para></listitem>
<listitem><para>Gaussian basis functions, shells, shell pairs and quartets,
basis sets---including most of the integrals you will ever likely
need.</para></listitem>
<listitem><para>Rectilinear grids for plots.</para></listitem>
<listitem><para>DFT integration grids.</para></listitem>
<listitem><para>Pointgroups symmetry including irreps.</para></listitem>
<listitem><para>Crystal (spacegroup) symmetry and unit cells.</para></listitem>
<listitem><para>DIIS extrapolation for vectors and matrices.</para></listitem>
<listitem><para>Atoms and molecules.</para></listitem>
<listitem><para>3D isosurface routines.</para></listitem>
</itemizedlist>
</para>
</sect1>

<!-- *********************************************************************** -->

<sect1 id="how-to-get">
  <title>How do I get &TONTO;</title>

<para>The web site is <ulink
url="http://www.theochem.uwa.edu.au/tonto">http://www.theochem.uwa.edu.au/tonto</ulink>.</para>

<para>The site contains the most up to date version of this manual, the code for
&TONTO;, and the full online documentation of the program.</para>
</sect1>

<!-- *********************************************************************** -->

<sect1 id="compile-requirements">
<title>What do I need to compile and install &TONTO;</title>

<para>&TONTO; is a Fortran-based <acronym>UNIX</acronym> based program.</para>

<para>You will need the <acronym>UNIX</acronym> tools
<command>tar</command> and <command>gunzip</command> or
<command>bunzip2</command>.  You will also need the <command>perl</command>
command and GNU <command>make</command> 3.79.1 (3.76 is known not to work), and
<command>cmp</command>.  You'll also need a <acronym>FORTRAN</acronym>
compiler.</para>

<para>Apart from the fortran compiler, all the tools we use are freely
available.</para>

<para>If your system is known to &TONTO;, the installation is simple: after
uncompressing the distribution just type <command>perl -w Makefile.pl</command>
and then <command>make</command>.  Then optionally do a <command>make
install</command>.  See <xref linkend="compile-install"/> for details.</para>

<para>If your compiler/operating-system combination is not known you will need
to know how to modify the compiler options in the Makefile so that &TONTO; can
compile.  Makefiles exist already for many systems and compilers; you may be
able to start from one or two of those already available.</para>

<para>Information you will need to compile and install &TONTO; is described in
chapter <xref linkend="compile-install"/>. You can also compile customised
versions which are helpful for developers or those speed freaks who want to make
things go as fast as possible: see <xref
linkend="customised-compilation"/>.</para>
</sect1>

<!-- *********************************************************************** -->

<sect1 id="calculations">
  <title>How do I use &TONTO; for calculations?</title>

<para>The executables for &TONTO; may require a text input file. The structure
of the input files follows a well defined database protocol. Input files are
discussed in <xref linkend="calc-chap"/>, and example inputs are given in
chapter <xref linkend="example-input-files"/>. The actual keywords are
documented in <xref linkend="keywords"/> including a description of how to use
the online documentation to find keywords.</para>

<para>To make good use of &TONTO;, especially the online WWW documentation,
it will help if you understand a little about how the overall program
is structured. This is explained in <xref linkend="tonto-design"/>.</para>
</sect1>

<!-- *********************************************************************** -->

<sect1 id="start-programming">
<title>What do I need to start programming in &TONTO?</title>

<para>You will need to know how to program in <acronym>FORTRAN</acronym>95 in a
<acronym>UNIX</acronym> environment.  In addition, it will be helpful (but
certainly not necessary) to be familiar with the object oriented programming
paradigm.</para>

<para>As well as knowing how to use &TONTO;, you will need to know how &TONTO;
is structured, as described in <xref linkend="tonto-design"/>, and also why it
has the structure it does. It will help if you know how &TONTO; is compiled,
which is described in <xref linkend="building-executables"/>. With this
knowledge you will be prepared to modify &TONTO; for your requirements. </para>

<para>You can learn how to add new <acronym>FORTRAN</acronym> modules to &TONTO;
by reading <xref linkend="fortran-modules"/>.</para>

<para>Although you can program in <acronym>FORTRAN</acronym>, it is highly
recommended for &TONTO; that you learn how to program in the &foo; language.
&Foo; is easy to learn, and makes many routine tasks associated with &TONTO;
automatic, and in addition your code will automatically be documented and
checked for memory leaks, if you desire.  The &foo; language is described in
<xref linkend="foo-chap"/>, and how to write &foo; modules is described in <xref
linkend="foo-modules"/>.</para>

<para>Of course, to make good use of existing code, you will need to be familiar
with the code that is already there. You should review each of the modules in
&TONTO; using the online documentation.</para>

<para>If you want to become a regular developer, you should also know about the
free <command>cvs</command> version control system works. That is already well
documented elsewhere, and you can contact us for the repository details.</para>
</sect1>

<!-- *********************************************************************** -->

<sect1 id="contributing">
  <title>Contributing code to &TONTO;</title>

<para>Remember, &TONTO; is copyleft under the less restrictive
<acronym>GNU</acronym> library license.  It is free software.</para>

<para>If you want features added or corrected in &TONTO;, you can do 
it yourself and mail the new stuff to us. </para>

<para>If you intend to make major and continual additions, it may be better to
contact us: we will give you access to the current <acronym>CVS</acronym>
repository so you can join the team working on the code. </para>

<para>Either way, your code contributions will be very much appreciated. </para>

<para>Your rights as a contributing author are protected under the
<acronym>GNU</acronym> license.</para>

<para>You can find out more of the underlying philosophy and aspirations of 
the &TONTO; project in the final chapter of this manual.</para>
</sect1>

<!-- *********************************************************************** -->

<sect1 id="citation">
  <title>Citation and attribution in &TONTO;</title>

<para>Except in the cases listed below, we don't think it is appropriate to cite
&TONTO; in the references to a scientific paper. &TONTO; is only a software tool
used in our scientific work. For example, we don't think it is appropriate to
reference Bill Gates if we use a Microsoft mathematical library to generate our
results.</para>

<para>It <emphasis>is</emphasis> appropriate to place a footnote reference to
&TONTO; to inform the reader what software was used. This is so that the reader
may reproduce the reported results. Reproducibility is critical to the
scientific method.</para>

<para>We <emphasis>do</emphasis> believe it is very important to always cite the
authors who first described the theories or algorithms which are used by &TONTO;
to do a particular calculation.  References to algorithms used in &TONTO; may be
given in this manual, and may be presented as output from some calculations. Use
them.</para>

<para>You should cite &TONTO; as a scientific reference only in cases where it
is deserved, including, for example:
<itemizedlist>
<listitem><para>if you are writing a paper which has modified parts of &TONTO;
</para></listitem>
<listitem><para>if you are writing a paper which deals with aspects of
efficiency or implementation in &TONTO;</para></listitem>
<listitem><para>if you are writing a paper about the construction of large
programs, especially computational chemistry programs, since &TONTO; is probably
the only example of an object oriented Fortran computational chemistry system in
existence.</para></listitem>
</itemizedlist>
</para>

<para>If you have contributed code to &TONTO;, you will be acknowledged as a
contributing author in the manual for &TONTO;.  People should cite your work,
and not &TONTO;, if they use the code donated by you to &TONTO;.</para>
</sect1>
</chapter>

<!-- *********************************************************************** -->
<!-- *********************************************************************** -->

<chapter id="compile-install">
  <title>Compiling and Installing &TONTO;</title>

<para>&TONTO; has been compiled and tested using a variety of compilers
and systems. The set of known systems is given in the next section.</para>

<para>You will need a number of <acronym>GNU</acronym> software tools. These are
also listed in the next section.</para>

<para>Unfortunately, compiler bugs are relatively common. You should scan the
section <xref linkend="install-problems"/> before attempting an install.  Please
contact us with problems; we are always interested in making this code
universally accesible.</para>

<para>For a known system, the compilation procedure is given in the section
<xref linkend="compiling-tonto"/>.  It extensively uses <command>Perl</command>,
and should automatically build a production code.</para>

<para>If your system is not known to us, or if you have any other compile
problems you can look at <xref linkend="compile-fail"/>.</para>

<para><xref linkend="customised-compilation"/> gives further information
explaining how to compile versions of &TONTO; for specific purposes, such as:
those which can detect memory leaks, those which can detect violation of routine
preconditions and postconditions, those with error management, debug versions,
profiling versions, or highly optimised versions.</para>

<para>Also for programmers, <xref linkend="building-executables"/> gives an
overview of the build <command>make</command> process, and how &TONTO; has been
designed to avoid unneccesary recompilation.</para>
<!-- *********************************************************************** -->

<sect1 id="compiler-requirements">
  <title>Compiler requirements for &TONTO;</title>

<para>The set of compilers and operating systems on which 
&TONTO; has been tested is:
<itemizedlist>
<listitem><para>Compaq <command>f90</command> or <command>f95</command> compiler
under Tru64</para></listitem>
<listitem><para>DEC <command>f90</command> or <command>f95</command> compiler
under OSF1</para></listitem>
<listitem><para>Fujitsu <command>frtvpp</command> compiler under
UXP5</para></listitem>
<listitem><para>Fujitsu <command>frtvpp</command> cross compiler under
Solaris</para></listitem>
<listitem><para>Fujitsu <command>f90</command> or <command>f95</command>
compiler under LINUX</para></listitem>
<listitem><para>IBM <command>xlf90</command> compiler under
AIX</para></listitem>
<listitem><para>Lahey-Fujitsu <command>lf95</command> compiler under
LINUX</para></listitem>
<listitem><para>Silicon Graphics MIPSPRO <command>f90</command> compiler under
IRIX64</para></listitem>
<listitem><para>NAG <command>f95</command> compiler under
LINUX</para></listitem>
<listitem><para>Sun Workshop <command>f90</command> compiler under
Solaris</para></listitem>
</itemizedlist>
</para>

<para>Other compilers:
<itemizedlist>
<listitem><para>Intel Fortran for Linux 6.0 does not compile &TONTO;.  This is
due to a compiler bug, which Intel say they have fixed for the next compiler
version.</para></listitem>
<listitem><para>No attempt to compile &TONTO; has been made under MS Windows or
on a Macintosh.  To get &TONTO; to compile on these other systems, you will need
the standard unix utilities (available for free from <ulink
url="http://www.cygwin.com/">Cygwin</ulink>) and <command>perl</command>, which
is also free.</para></listitem>
<listitem><para>&TONTO; will not work with MS-DOS.</para></listitem>
</itemizedlist>
</para>

<para>Some compilers may need upgrading or require special settings. Have a look
at section <xref linkend="install-problems"/> for compiler specific issues. 
</para>
</sect1>

<!-- *********************************************************************** -->

<sect1 id="system-requirements">
<title>System requirements for &TONTO;</title>

<para>Apart from a Fortran compiler, you will need the following free software:
<itemizedlist>
<listitem><para>Netscape or another web browser</para></listitem>
<listitem><para>The <command>tar</command> program for extracting the
distribution</para></listitem>
<listitem><para>The <command>gunzip</command> or <command>bunzip2</command>
program for uncompressing files</para></listitem>
<listitem><para>The <command>gmake</command> program for controlling the
compilation</para></listitem>
<listitem><para>The <command>perl</command> program for the foo
preprocessor</para></listitem>
<listitem><para>The <command>cvs</command> program and associated commands (only
for developers)</para></listitem>
<listitem><para>The BLAS and LAPACK numerical libraries for linear algebra (only
if not available on your system)</para></listitem>
</itemizedlist></para>

<para>The above software must be installed and working
<emphasis>before</emphasis> you start compilation.</para>
<para>If you are not doing development work and have a &TONTO; executable, then
you do not need any of the above programs.</para>
</sect1>

<!-- *********************************************************************** -->

<sect1 id="install-problems">
  <title>Known problems installing &TONTO;</title>

<para>Compiler specific issues:
<itemizedlist>
<listitem><para>Compaq Fortran 5.2 for TRU64 and OSF/1. This compiler contains a
bug that prevents it from compiling the generic-interfaces in &TONTO;.  You can
download a later version for free from the Compaq web site.</para></listitem>
<listitem><para>Compaq Fortran 5.3 for TRU64 and OSF/1. Use build 1120 of the
compiler; the original could not handle the large number of modules. You can
download a later version for free from the Compaq web site.</para></listitem>
<listitem><para>Digital Fortran 5.0 for OSF/1 run time libraries 376 or later
must be used.  Before this, the <function>for_cpusec</function> routine will be
unresolved.  Also, in the <literal>site_config</literal> file you must have -DLANGUAGE_FORTRAN_90 on the DEFS line.</para></listitem>
<listitem><para>Fujitsu Fortan for Linux patch 1999/07/29 or later of the
Compiler must be used; the original could not handle the large number of
modules.</para></listitem>
<listitem><para>Intel Fortran for Linux 6.x and 7.0 do not compile &TONTO;, due
to numerous compiler bugs.</para></listitem>
<listitem><para>Absoft Pro Fortran for Linux 8.0 does not compile &TONTO;, due
to several minor compiler bugs.</para></listitem>
</itemizedlist></para>
</sect1>

<!-- *********************************************************************** -->

<sect1 id="compiling-tonto">
  <title>Compiling &TONTO;</title>

<para>Download the latest version of &TONTO; from the <ulink
url="http://www.theochem.uwa.edu.au/tonto/">http://www.theochem.uwa.edu.au/tonto/</ulink>
website.</para>


<para>To unpack the archive you downloaded, type: 
<programlisting>
       gunzip -c tonto.tar.gz | tar xvf -
</programlisting>
or
<programlisting>
       bunzip2 -c tonto.tar.bz2 | tar xvf -
</programlisting>
if you downloaded the bz2 version.
</para>

<para>Then to compile &TONTO;, type: 
<programlisting>
       cd tonto
       perl -w Makefile.pl
       make
</programlisting>
</para>

<para>If <command>Makefile.pl</command> tells you that your system is unknown,
you should read <xref linkend="compile-fail"/></para>

<para>Note that on some systems you need to type <command>gmake</command>
instead of <command>make</command>.  &TONTO; must use the GNU version of
<application>make</application> to succesfully compile.</para>

<para>On some systems the <application>BLAS</application> and
<application>LAPACK</application> libraries may not be available.  If this is
the case, you will need to read <quote>Compiling the BLAS and LAPACK
libraries</quote> section.  When you have generated those libraries and modified
the Makefile so that they are recognised, type <command>make</command> again to
finish compiling &TONTO;.</para>

<para>If you want to install customised versions of &TONTO;, you should edit
compiler settings as described in a later chapter before typing
<command>make</command>.</para>

<para>You can type <command>make help</command> to see a list of common commands
to pass to <command>make</command>.</para>
</sect1>

<!-- *********************************************************************** -->

<sect1 id="making-documentation">
  <title>Making the &TONTO; html documentation</title>

<para>To make the online documentation, type
<programlisting>
   make documentation
</programlisting>
</para>

<para>To see the documentation, use your browser to open the file
<programlisting>
   documentation/index.html
</programlisting>
</para>

<para>To make the pdf version of this manual, type
<programlisting>
   make manual-pdf
</programlisting>
Note that you will need the <command>docbook</command> suite of programs to do
this.</para>
</sect1>

<!-- *********************************************************************** -->

<sect1 id="installing-tonto">
<title>Installing &TONTO;</title>

<para>You do not have to install &TONTO; to another directory. You can use it in
place.</para>

<para>If you do want to install &TONTO; just type
<programlisting>
   make install
</programlisting>
after succesful compilation. By default, this will copy the &TONTO; executable
into the directory
<programlisting>
   /usr/local/bin
</programlisting>
If you do not wish this to be the installed directory, you should run
<command>perl -w Makefile.pl</command> with the
<userinput>--installdir=&lang;new_directory&rang;</userinput> option.</para>
</sect1>

<!-- *********************************************************************** -->

<sect1 id="compile-fail">
<title>What to do if compiling &TONTO; fails</title>

<para>There are a few problems that you might have: </para>

<sect2>
<title>Your system is not known to us</title>

<para>You will know this is the case, because after the Makefile.pl script has
completed it will tell you that it has not encountered your system before. In
this case, you will need to create a Makefile for your machine and operating
system. You should read <xref linkend="makefiles"/>.</para>
</sect2>

<sect2>
<title>You are missing the <application>BLAS</application> and
<application>LAPACK</application> libraries</title>

<para>You will know this is the case if you see many messages involving
<computeroutput>unresolved symbol</computeroutput>. Refer to <xref
linkend="blas-lapack"/>.</para>
</sect2>

<sect2>
<title>There are Fortran compiler problems</title>

<para>These are usually indicated by messages like <computeroutput>fatal
error</computeroutput>, <computeroutput>insufficient virtual
memory</computeroutput>, or no message at all with the generation of a
<computeroutput>core</computeroutput> file.  There is very little that can be
done about <computeroutput>fatal errors</computeroutput>, but they may be solved
by reducing the compilation language level from Fortran95 to Fortran90 by using
the <literal>-DLANGUAGE_FORTRAN_90</literal> preprocessor option, or by reducing
the compilation level to using the <literal>-FDEBUG</literal> compilation
option, or changing the compilation options so that no optimisation is
performed. See the chapter <quote>Compiling customised version of
&TONTO;</quote>. Messages such as <literal>insufficient memory</literal> can be
solved by adding more memory to your computer, or increasing the virtual memory
or swap space. You should consult an expert for your system in this case. For
example, on COMPAQ systems, memory problems can often be solved by increasing
the stacksize and other limits using the <command>limit</command> or
<command>ulimit</command> command.</para>
</sect2>

<sect2>
<title>There are Fortran code problems</title>

<para>These are indicated when compiler messages involving the words
<computeroutput>subroutine</computeroutput>, <computeroutput>incorrect
syntax</computeroutput>, <computeroutput>unknown syntax</computeroutput> or
<computeroutput>undeclared variable</computeroutput>. Usually, a line of Fortran
code will also be printed. If you know Fortran and also the
<command>foo</command> preprocessor, you should alter the corresponding line
in the .foo source file, found in the <emphasis>foofiles</emphasis> directory.
These problems are quite rare and usually indicate a non-compliant compiler. The
problem may be removed by reducing the compilation language level using the
<literal>-DLANGUAGE_FORTRAN_90</literal> preprocessor option.</para>
</sect2>

<sect2>
<title>There are <command>foo</command> preprocessor problems</title>

<para>Problems with the preprocessor are indicated by messages which involve the
<command>perl</command> command. Please ensure the version of
<command>perl</command> you have is up to date.  Otherwise, you should contact
us.</para>
</sect2>

</sect1>

<!-- *********************************************************************** -->

<sect1 id="blas-lapack">
<title>Compiling the BLAS and LAPACK libraries</title>

<para>If you do not have BLAS and LAPACK, you will have to download and install
them.  Note that if your vendor has their own version, you should use that as it
is probably much faster.</para>

<para>BLAS can be obtained from <ulink
url="http://www.netlib.org/blas/">http://www.netlib.org/blas/</ulink>.</para>
<para>LAPACK can be obtained from <ulink
url="http://www.netlib.org/lapack/">http://www.netlib.org/lapack/</ulink>.</para>

<para>Building BLAS and LAPACK should create the files
<literal>libblas.a</literal> and <literal>liblapack.a</literal>. These are the
archived BLAS and LAPACK libraries.</para>

<para>To ensure these libraries are located, you will need to modify your
specific <literal>site_config</literal> file.  Modify the
<literal>LIBS</literal> variable to read like this:
<programlisting>
   LIBS = -L/path/to/libs -llapack -lblas
</programlisting>
You must replace the string <literal>/path/to/libs</literal> with the directory
name where you have installed <literal>libblas.a</literal> and
<literal>liblapack.a</literal>.

If you compile the BLAS and LAPACK libraries using GNU g77, then you must
specify some additional library flags such as
<programlisting>
LIBS    := -L usr/lib/gcc-lib/i386-redhat-linux/2.96 -lg2c -llapack -lblas
</programlisting>
This will vary depending on your operating system / distribution.
</para>

<para>See <xref linkend="LIBS"/> for more information.</para>
</sect1>

<!-- *********************************************************************** -->

<sect1 id="makefiles">
<title>What you can do if a site_config file does not exist for your
system</title>

<para>If a <literal>site_config</literal> file does not exist for your system,
you should do the following:
<itemizedlist>
<listitem><para>Note the name of the <literal>site_config</literal> file that
<command>make</command> tells you it is going to use.  This is the file you must
edit.</para></listitem>
<listitem><para>Look in the <literal>site_config</literal> directory in the
distribution.  You will find there the machine specific files for a range of
compilers and systems. For example, <literal>COMPAQ-f95-on-OSF1</literal>
contains compiler options for the COMPAQ <command>f95</command> compiler on the
OSF1 (Tru64) operating system.</para></listitem>

<listitem><para>Some of the files in <literal>site_config</literal> may
correspond to your compiler, but not your system.  If this is the case, start by
using a file which corresponds to your compiler as a starting guess for the
compile-options you might need.  Use your editor to insert these compile-options
into the generic <literal>site_config</literal> file made by
<command>Makefile.pl</command>.</para></listitem>

<listitem><para>Whether you do or don't find appropriate compile-options in the
<literal>site_config</literal> directory corresponding to your compiler, you
should read <xref linkend="customised-compilation"/>, especially <xref
linkend="compiler-options"/>.  The latter section contains detailed information
about the meaning of all the typical compiler switches on the COMPAQ machine, so
you'll know which ones to look for on your system.</para></listitem>
</itemizedlist>
</para>

</sect1>
</chapter>

<!-- *********************************************************************** -->
<!-- *********************************************************************** -->

<chapter id="calc-chap">
<title>Using &TONTO; to do calculations</title>

<para>Using &TONTO; to do calculations consists of two parts. The first part is
to write an <emphasis>input file</emphasis> for the main program that you want
to use.  The second part is to actually run the program.</para>

<para>The second part is very easy and will be described first, in the next
section.  The rest of the chapter will be concerned with how to write input
files for the most common executables in the &TONTO; system.</para>

<!-- *********************************************************************** -->

<sect1 id="run-calc">
<title>How to run a &TONTO; calculation</title>

<para>&TONTO; is different from most programs used in computational chemistry
because it does not have a single <quote>main program</quote> (although for
convenience a few common <quote>main programs</quote> are already set up for you
to use).  Instead, &TONTO; consists of about fifty independent modules, and most
of these can be compiled and executed to do calculations.</para>

<para>By convention, the executable program associated with any module with name
<literal>XXXX</literal> is always called <literal>run_xxxx.x</literal>.</para>

<para>The module which probably will be used most often is
<literal>MOL</literal>, since it contains routines which deal with
<quote>molecular data</quote>.  The executable, or <quote>main program</quote>
associated with this module is called <literal>run_mol.x</literal>.</para>

<para>The procedure for running any main program is always the same. 
Simply type the name of the executable program.</para>

<para>For example, to run the <command>run_mol.x</command> program, simply type
<programlisting>
run_mol.x
</programlisting>
</para>

<para>The main program may, or may not, require an input file which contains
instructions for what it is to do. If an input file is required,
it must always be called <literal>stdin</literal>.</para>

<para>As part of its execution, the program will usually produce some output,
which will be the results of the calculation. If output is produced,
it will always be called <literal>stdout</literal>. Note that other files may
also be produced. The names of these files, and what is contained in them, will
depend on the nature of the calculation specified in the input file.</para>
</sect1>

<!-- *********************************************************************** -->

<sect1 id="input-files">
<title>Writing an input file: the basics</title>

<sect2>
<title>What is an input file?</title>

<para>An input file begins with an open curly bracket <literal>&lcub;</literal>
and ends with a close curly bracket, <literal>&rcub;</literal>.</para>

<para>In between these brackets, it consists of <quote>words</quote> and
<quote>numbers</quote> separated by blank spaces and possibly blank lines. One
blank space is equivalent to any number of blank spaces or blank lines.</para>

<para>The allowed <quote>words</quote> may be <quote>keywords</quote> which tell
the computer to <quote>do</quote> something, or they may actually be pieces of
<quote>data</quote> like <quote>numbers</quote> which are to be stored.</para>
</sect2>

<sect2>
<title>What does an input file look like?</title>

<para>Below is an example showing the style of keywords and data used in
&TONTO;.</para>

<para>Note how data is usually grouped within matching curly brackets; and note
that keywords ending in the <literal>=</literal> sign are followed by some
numerical or string-like data.</para>

<para>Note also that repetive lists of data are inputted using a <literal>list=
&lcub; ... &rcub;</literal> construction.  Preceding these repetitive lists of
data there is often a <literal>list_order= &lcub; ... &rcub;</literal> keyword
list; this keyword list specifies the order in which the data items in the list
are to be interpreted.</para>

<para>
<programlisting>
&lcub;
  name=     nh3
 
  charge=  0
 
  multiplicity= 1

 
  crystal= &lcub;
 
    spacegroup_it_symbol=   P2_13
    unit_cell_angles=      90.0   90.0   90.0       Degree
    unit_cell_dimensions=   5.1305 5.1305 5.1305    Angstrom
 
    thermal_smearing_model= stewart
    partition_model= mulliken
 
    reflection_data=  &lcub;
   
      ! Experimental data from Boese et al ...
 
      list_order= &lcub; h= k= l= F_exp= F_sigma= &rcub;
   
      list= &lcub;

      ! These are the real experimental data

       1   1   0    18.093    0.118
       1   1   1    63.470    0.446
       0   2   0    53.079    0.434
       1   2   0     2.864    0.084

      &rcub;
    &rcub; 
  &rcub;

   
  atoms= &lcub;

    list_order= 
       &lcub; label= " &lcub; axis_system= crystal &rcub; " pos= basis_label= &rcub;

    list= &lcub;

    N  0.2103001   0.2103001   0.2103001  N_basis_set
    H  0.3722001   0.2627001   0.1113001  H_basis_set
    H  0.1113001   0.3722001   0.2627001  H_basis_set
    H  0.2627001   0.1113001   0.3722001  H_basis_set

    &rcub; 
  &rcub;
  
  
  basis_sets= &lcub;

    list_order= &lcub; gamess-us= &rcub;

    list= &lcub;

    N_basis_set
    &lcub;
       S   3
        1        30.63310000         0.1119060000     
        2        7.026140000         0.9216660000     
        3        2.112050000        -0.2569190000E-02 
       P   3
        1        30.63310000         0.3831190000E-01
        2        7.026140000         0.2374030000    
        3        2.112050000         0.8175920000    
       D   1
        1       0.913000000           1.00000000    
    &rcub; 
  
    H_basis_set
    &lcub;
       S   1
        1       0.3258400000         1.000000000    
       P   1
        1       0.750000000          1.00000000    
    &rcub; 

    &rcub;
  &rcub;
&rcub;
</programlisting>
</para>
</sect2>

<sect2>
<title>How do I know which are the allowed input keywords?</title>

<para>If &TONTO; does not understand a keyword, it usually gives an error
message and sufficient information to track down the error.</para>

<para>To find out what keywords are allowed for any module
<literal>XXXX</literal>, look in <xref linkend="keywords"/> in the subsection
<quote>The <literal>XXXX</literal> module</quote>.</para>

<para>For example, we might start by looking in the <quote>The
<literal>MOL</literal> module</quote> section.  We find as a typical example the
following line:</para>

<para><programlisting>
name= STR

The name of the molecule 

&bull; The <literal>name=</literal> keyword must be the first one in any input file. 
&bull; The value of the inputted string is used to define the start of archive
file names, so <emphasis>do not</emphasis> use any spaces in it.
</programlisting></para>

<para>In the case above, the keyword is <literal>name=</literal>.  You can type
this into the input file.  Following the <literal>name=</literal> keyword you
must type a piece of data which is a <literal>STR</literal>, i.e.  a string
variable such as <quote>nh3</quote>.</para>

<para>Following this keyword is a description of what the keyword might do, if
you type it in the input file.  In this case, <literal>name=</literal> does not
seem to <quote>do</quote> anything at all, but seems to represent <quote>The
name of the molecule</quote>.  In smaller text still are some special comments
about the usage of this keyword.</para>

<para>Some keywords must be followed by data---perhaps a number or a string.
These are called <quote>data keywords</quote>. These are used to input data into
the program.  Data keywords always end in an <literal>=</literal> sign, so you
know that some data has to follow them. There are also <quote>task
keywords</quote> which may or may not be followed by data. Task keywords do not
end in an <literal>=</literal> sign. They are used to perform a specific action
or calculation.  The <quote>name=</quote> keyword is obviously a data
keyword.</para>

<para><emphasis>Note that there cannot be any space between a keyword and the
<literal>=</literal> symbol.</emphasis></para>

<para>There are two special keyword, which are the open and close braces,
<literal>&lcub;</literal> and <literal>&rcub;</literal> respectively. They are
always used to signify the beginning and end of input for a
<emphasis>list</emphasis> of data---perhaps a list of numbers, or a list of
keywords.</para>

<para><emphasis>Note that braces <literal>&lcub;</literal> and
<literal>&rcub;</literal> must have a space on both sides.</emphasis></para>

</sect2>

<sect2>
<title>What about keywords which aren't in this manual?</title>

<para>You will need to look in the online code documentation.</para>

<para>This is explained in <xref linkend="keywords"/> in <xref
linkend="online-doc"/> <quote>Online documentation</quote>.  A schematic
procedure for finding out what keywords are available is given there, and what
data the keywords require as input.</para>

<para>Since &TONTO; changes quite often, this may often be your only
alternative.</para>
</sect2>

<sect2>
<title>How do I know when to enter data?</title>

<para>If data is required to follow a particular keyword, in the documentation
you will see immediately following the keyword a double colon, and some
uppercase words, such as <literal>STR</literal>, <literal>REAL</literal>,
<literal>INT</literal>, <literal>REALVEC(3)</literal>, or
<literal>ATOM</literal>.</para>

<para>In the example above, the <literal>name=</literal> data keyword is
followed by <literal>STR</literal>.  indicating  it must be followed by some
data, and that this data must be of the <literal>STR</literal> variety.
<literal>STR</literal> is a shorthand for <quote>string data</quote>.</para>
</sect2>

<sect2>
<title>What kinds of data are there?</title>

<para>There are many kinds of data. You have already encountered
<literal>STR</literal> data.  There is also <literal>REAL</literal> data, which
represents <quote>real numbers</quote>, <literal>INT</literal> data which
represents <quote>integers</quote>, and <literal>REALVEC(3)</literal> data, which
represent 3 dimensional vectors, to name a few.</para>

<para>However, there are also more complicated pieces of input data, like
<literal>ATOM</literal> data, which (naturally enough) represents <quote>atom
data</quote>.  Atom data might be represented by a collection of simple data,
For example, there may be a <literal>STR</literal>  piece of information
representing the <quote>atom label</quote> , and there may be a
<literal>REALVEC(3)</literal>  piece of data representing the <quote>atom
position</quote>. There is also <quote>molecule data</quote>, or
<literal>MOL</literal> data for short. This might be composed of a
<quote>list</quote> or <quote>vector</quote> of <literal>ATOM</literal> data.
These complicated data objects are called <quote>derived data</quote>, or
<quote>vectors of derived data</quote>. </para>

<para>All data in &TONTO; is described by modules. Thus, <literal>ATOM</literal>
data is described by a module with name <literal>ATOM</literal>.  <xref
linkend="table-of-tonto-types"/> describes each of the modules (and hence data
types) which are used in &TONTO;.</para>

<para>
<table id="table-of-tonto-types">
<title>Modules available in &TONTO;.</title>
<tgroup cols=2>
<colspec colnum=1 colname=1>
<colspec colnum=2 colname=2>
<thead>
<row>
<entry>Module name</entry>
<entry>Description</entry>
</row>
</thead>
<tbody>
<row>
<entry><literal>ARCHIVE</literal></entry>
<entry>For archiving objects (mainly matrices) to disk</entry>
</row>
<row>
<entry><literal>ATOM</literal></entry>
<entry>A quantum mechanical atom</entry>
</row>
<row>
<entry><literal>ATOMVEC</literal></entry>
<entry>A vector of <literal>ATOM</literal>'s</entry>
</row>
<row>
<entry><literal>BASIS</literal></entry>
<entry>Quantum mechanical basis sets</entry>
</row>
<row>
<entry><literal>BASISVEC</literal></entry>
<entry>A vector of <literal>BASIS</literal>sets</entry>
</row>
<row>
<entry><literal>BINMAT</literal></entry>
<entry>A matrix of <literal>BIN</literal></entry>
</row>
<row>
<entry><literal>BINVEC</literal></entry>
<entry>A vector of <literal>BIN</literal></entry>
</row>
<row>
<entry><literal>BUFFER</literal></entry>
<entry>A string buffer</entry>
</row>
<row>
<entry><literal>CPXMAT</literal></entry>
<entry>Complex matrices</entry>
</row>
<row>
<entry><literal>CPXMAT3</literal></entry>
<entry>3 dimensional complex matrices</entry>
</row>
<row>
<entry><literal>CPXMAT4</literal></entry>
<entry>4 dimensional complex matrices</entry>
</row>
<row>
<entry><literal>CPXMAT5</literal></entry>
<entry>5 dimensional complex matrices</entry>
</row>
<row>
<entry><literal>COLOUR</literal></entry>
<entry>Converts colour names to RGB triples</entry>
</row>
<row>
<entry><literal>COLOURFUNCTION</literal></entry>
<entry>Generates RGB triples from function values</entry>
</row>
<row>
<entry><literal>CRYSTAL</literal></entry>
<entry>A crystal</entry>
</row>
<row>
<entry><literal>CPXVEC</literal></entry>
<entry>Complex vectors</entry>
</row>
<row>
<entry><literal>REAL</literal></entry>
<entry>Double precision numbers</entry>
</row>
<row>
<entry><literal>DFTGRID</literal></entry>
<entry>DFT integration grids</entry>
</row>
<row>
<entry><literal>FILE</literal></entry>
<entry>BINARY (unformatted) files</entry>
</row>
<row>
<entry><literal>GAUSSIAN</literal></entry>
<entry>A gaussian function</entry>
</row>
<row>
<entry><literal>GAUSSIAN2</literal></entry>
<entry>A pair of gaussian functions</entry>
</row>
<row>
<entry><literal>GAUSSIAN4</literal></entry>
<entry>A quartet of gaussian functions</entry>
</row>
<row>
<entry><literal>INTMAT</literal></entry>
<entry>Integer matrices</entry>
</row>
<row>
<entry><literal>INTMAT3</literal></entry>
<entry>3 dimensional integer matrices</entry>
</row>
<row>
<entry><literal>INTMAT4</literal></entry>
<entry>4 dimensional integer matrices</entry>
</row>
<row>
<entry><literal>INT</literal></entry>
<entry>Integers</entry>
</row>
<row>
<entry><literal>IRREP</literal></entry>
<entry>Point group irreps</entry>
</row>
<row>
<entry><literal>IRREPVEC</literal></entry>
<entry>A vector of point group irreps</entry>
</row>
<row>
<entry><literal>INTVEC</literal></entry>
<entry>Integer vectors</entry>
</row>
<row>
<entry><literal>IVECMAT3</literal></entry>
<entry>A 3 dimensional matrix of integer vectors</entry>
</row>
<row>
<entry><literal>IVECVEC</literal></entry>
<entry>A vector of integer vectors</entry>
</row>
<row>
<entry><literal>MARCHINGCUBE</literal></entry>
<entry>Generates triangulated iso-surfaces using the marching cubes method</entry>
</row>
<row>
<entry><literal>REALMAT</literal></entry>
<entry>Real Matrices</entry>
</row>
<row>
<entry><literal>REALMAT3</literal></entry>
<entry>3 dimensional matrices</entry>
</row>
<row>
<entry><literal>REALMAT3VEC</literal></entry>
<entry>A vector of 3 dimensional matrices</entry>
</row>
<row>
<entry><literal>REALMAT4</literal></entry>
<entry>4 dimensional matrices</entry>
</row>
<row>
<entry><literal>REALMAT4VEC</literal></entry>
<entry>A vector of 4 dimensional matrices</entry>
</row>
<row>
<entry><literal>REALMAT5</literal></entry>
<entry>5 dimensional matrices</entry>
</row>
<row>
<entry><literal>REALMATVEC</literal></entry>
<entry>A vector of matrices</entry>
</row>
<row>
<entry><literal>MOL</literal></entry>
<entry>A chemical molecule</entry>
</row>
<row>
<entry><literal>OPMATRIX</literal></entry>
<entry>Operator matrices (restricted, unrestricted, complex, etc.)</entry>
</row>
<row>
<entry><literal>OPVECTOR</literal></entry>
<entry>Diagonals of operator matrices</entry>
</row>
<row>
<entry><literal>PLOTGRID</literal></entry>
<entry>Rectilinear grids for plots</entry>
</row>
<row>
<entry><literal>POINTGROUP</literal></entry>
<entry>Symmetry pointgroups</entry>
</row>
<row>
<entry><literal>REFLECTION</literal></entry>
<entry>A single reflection (scattering data) from a crystal</entry>
</row>
<row>
<entry><literal>REFLECTIONS</literal></entry>
<entry>A vector of reflections</entry>
</row>
<row>
<entry><literal>RYS</literal></entry>
<entry>Rys roots and weights for electron repulsion integrals</entry>
</row>
<row>
<entry><literal>SCFDATA</literal></entry>
<entry>SCF convergence data and results</entry>
</row>
<row>
<entry><literal>SHELL</literal></entry>
<entry>A contracted shell of gaussian functions</entry>
</row>
<row>
<entry><literal>SHELL1</literal></entry>
<entry>A contracted shell of gaussian functions, with a position</entry>
</row>
<row>
<entry><literal>SHELLVEC</literal></entry>
<entry>A vector of <literal>SHELL</literal>'s</entry>
</row>
<row>
<entry><literal>SHELL2</literal></entry>
<entry>A <literal>SHELL</literal>pair. Contains integral code</entry>
</row>
<row>
<entry><literal>SHELL4</literal></entry>
<entry>A <literal>SHELL</literal>quartet. Contains integral code</entry>
</row>
<row>
<entry><literal>SHELLPAIR</literal></entry>
<entry>A pair of <literal>SHELL</literal>s</entry>
</row>
<row>
<entry><literal>SHELLQUARTET</literal></entry>
<entry>A quartet of <literal>SHELL</literal>s</entry>
</row>
<row>
<entry><literal>SHELL1QUARTET</literal></entry>
<entry>A quartet of <literal>SHELL1</literal>s.  Contains heavily optimised
integral code</entry>
</row>
<row>
<entry><literal>SPACEGROUP</literal></entry>
<entry>Crystal spacegroup symmetry</entry>
</row>
<row>
<entry><literal>STR</literal></entry>
<entry>Character strings</entry>
</row>
<row>
<entry><literal>STRVEC</literal></entry>
<entry>Character strings</entry>
</row>
<row>
<entry><literal>SYSTEM</literal></entry>
<entry>System level routines</entry>
</row>
<row>
<entry><literal>TEXTFILE</literal></entry>
<entry>A file containing ASCII text</entry>
</row>
<row>
<entry><literal>TIME</literal></entry>
<entry>Current and elapsed time</entry>
</row>
<row>
<entry><literal>TYPES</literal></entry>
<entry>Defines the various types in &TONTO;</entry>
</row>
<row>
<entry><literal>UNITNUMBER</literal></entry>
<entry>Information about files currently open</entry>
</row>
<row>
<entry><literal>VECDIIS</literal></entry>
<entry>A vector of DIIS</entry>
</row>
<row>
<entry><literal>REALVEC</literal></entry>
<entry>A real vector</entry>
</row>
<row>
<entry><literal>REALVECVEC</literal></entry>
<entry>A vector of <literal>REALVEC</literal>s</entry>
</row>
</tbody>
</tgroup>
</table>
</para>

</sect2>

<sect2>
<title>How do I enter data?</title>

<para>Simply type the required piece of data immediately following the data
keyword---remembering to leave at least one blank space between the keyword and
the data.</para>

<para>For the kind of <quote>simple data</quote>, such as
<literal>STR</literal>, <literal>REAL</literal>, <literal>INT</literal>, or
<literal>REALVEC</literal>.  you can probably guess what you have to type in your
input file. </para>

<para>Examples for entering simple data are given in <xref
linkend="simple-data-table"/>.  This is explained further in a section
below.</para>

<para>The simplest way to enter derived data like <literal>ATOM</literal> data
is to use keywords---and finding and using keywords has already been explained
above. If the keyword is to be followed by data, it is either simple data (which
is described below), or derived data (which can be inputted using keywords,
already described above).</para>

<para>There is also another way to enter vectors of derived data, without using
keywords, which is also explained below.</para>

<para>
<table id="simple-data-table">
<title>Shorthand symbols for simple data with input examples</title>
<tgroup cols=3>
<colspec colnum=1 colname=1>
<colspec colnum=2 colname=2>
<colspec colnum=3 colname=3>
<thead>
<row>
<entry>Kind of data</entry>
<entry>Shorthand symbol</entry>
<entry>Some examples of how to enter this data</entry>
</row>
</thead>
<tbody>
<row>
<entry morerows=2>Comment</entry>
<entry morerows=2>-</entry>
<entry>! A comment appears after an isolated exclamation</entry>
</row>
<row>
<entry>"!" Even this is a comment</entry>
</row>
<row>
<entry># A hash will also begin a comment</entry>
</row>
<row>
<entry>Logical</entry>
<entry>BIN</entry>
<entry>TRUE true F Yes "NO" False F f</entry>
</row>
<row>
<entry>String</entry>
<entry>STR</entry>
<entry>a-string-with-no-blanks "a string with blanks"</entry>
</row>
<row>
<entry>Integer</entry>
<entry>INT</entry>
<entry>123 -10 +10 "666"</entry>
</row>
<row>
<entry>Real number</entry>
<entry>REAL</entry>
<entry>123 -10.0 123.4 123.4e5 +123.4d-5</entry>
</row>
<row>
<entry>Complex number</entry><entry>CPX</entry>
<entry>12.3e5 56.7e8 ! A single complex number</entry>
</row>
</tbody>
</tgroup>
</table>
</para>

<para>
<table id="simple-vec-data-table">
<title>Shorthand symbols for simple vector data with input examples</title>
<tgroup cols=4>
<colspec colnum=1 colname=1>
<colspec colnum=2 colname=2>
<colspec colnum=3 colname=3>
<colspec colnum=4 colname=4>
<thead>
<row>
<entry>Kind of data</entry>
<entry>Shorthand symbol</entry>
<entry namest=3 nameend=4>Some examples of how to enter this data</entry>
</row>
</thead>
<tbody>
<row>
<entry morerows=1>Logical vector</entry>
<entry>BINVEC(4)</entry>
<entry>T T T<quote>f</quote></entry>
<entry>A logical vector, length 4</entry>
</row>
<row>
<entry>BINVEC*</entry>
<entry>&lcub; T T T &rcub;</entry>
<entry>A logical vector, variable length</entry>
</row>
<row>
<entry morerows=1>String vector</entry>
<entry>STRVEC(2)</entry>
<entry><quote>Hi</quote> gorgeous</entry>
<entry>A string vector, length 2</entry>
</row>
<row>
<entry>STRVEC*</entry>
<entry>&lcub; a b c d &rcub;</entry>
<entry>A string vector, variables length</entry>
</row>
<row>
<entry morerows=1>Integer vector</entry>
<entry>INTVEC(5)</entry>
<entry>1 0 1 1 0</entry>
<entry>An integer vector, length 5</entry>
</row>
<row>
<entry>INTVEC*</entry>
<entry>&lcub; 66 99 33 &rcub;</entry>
<entry>An integer vector, variable length</entry>
</row>
<row>
<entry morerows=1>Real vector</entry>
<entry>REALVEC(3)</entry>
<entry>0 0.0 30.d-3</entry>
<entry>A real vector, length 3</entry>
</row>
<row>
<entry>REALVEC*</entry>
<entry>&lcub; 1. 2. 3. &rcub;</entry>
<entry>A real vector, variable length</entry>
</row>
<row>
<entry morerows=1>String vector pair</entry>
<entry morerows=1>STRVEC(3),STRVEC(3)</entry>
<entry morerows=1><literallayout>
x_1 y_1
x_2 y_2
x_3 y_3
</literallayout></entry>
<entry>Vector x in column 1</entry>
</row>
<row>
<entry>Vector y in column 2</entry>
</row>
<row>
<entry morerows=1>Real vector, String vector pair</entry>
<entry morerows=1>REALVEC(3),STRVEC(3)</entry>
<entry morerows=1><literallayout>
1. y_1
2. y_2
3. y_3
</literallayout></entry>
<entry>Real vector in column 1</entry>
</row>
<row>
<entry>String vector in column 2</entry>
</row>
<row>
<entry morerows=1>Complex vector</entry>
<entry>CPXVEC(1)</entry>
<entry>0.0 1.0</entry>
<entry>A complex vector, length 1</entry>
</row>
<row>
<entry>CPXVEC*</entry>
<entry>&lcub; 1. 2. 3 4 &rcub;</entry>
<entry>A complex vector, variable length</entry>
</row>
</tbody>
</tgroup>
</table>
</para>

<para>
<table id="simple-mat-data-table">
<title>Shorthand symbols for simple matrix data with input examples</title>
<tgroup cols=4>
<colspec colnum=1 colname=1>
<colspec colnum=2 colname=2>
<colspec colnum=3 colname=3>
<colspec colnum=4 colname=4>
<thead>
<row>
<entry>Kind of data</entry>
<entry>Shorthand symbol</entry>
<entry namest=3 nameend=4>Some examples of how to enter this data</entry>
</row>
</thead>
<tbody>
<row>
<entry morerows=1>String matrix</entry>
<entry morerows=1>STRMAT(2,2)</entry>
<entry><literallayout>
a b
c <quote>d</quote>
</literallayout></entry>
<entry>A string matrix, rank 2 x 2</entry>
</row>
<row>
<entry><literallayout>
by_cloumn
a c
b <quote>d</quote>
</literallayout></entry>
<entry>Same matrix, entered by column</entry>
</row>
<row>
<entry morerows=1>Integer matrix</entry>
<entry morerows=1>INTMAT(2,2)</entry>
<entry><literallayout>
1 2
3 "4"
</literallayout></entry>
<entry>An integer matrix, rank 2 x 2</entry>
</row>
<row>
<entry><literallayout>
by_column
1 3
2 "4"
</literallayout></entry>
<entry>Same matrix, entered by column</entry>
</row>
<row>
<entry morerows=1>Real matrix</entry>
<entry morerows=1>REALMAT(2,2)</entry>
<entry><literallayout>
1 2.
3 4d+5
</literallayout></entry>
<entry>A real matrix, rank 2 x 2</entry>
</row>
<row>
<entry><literallayout>
by_column
1 3
2. 4d+5
</literallayout></entry>
<entry>Same matrix, entered by column</entry>
</row>
</tbody>
</tgroup>
</table>
</para>

</sect2>

<sect2>
<title>How do I enter simple data?</title>

<para>Some examples of how to input simple kinds of data are shown in
<xref linkend="simple-data-table"/>, <xref linkend="simple-vec-data-table"/>
and <xref linkend="simple-mat-data-table"/>.  Some examples of input comments
are also shown.</para>

<para>In most cases, the input that you type is the same as that used for the
Fortran language, except in the following respects related to the entry of
vectors and arrays of data. </para>

<para>Sometimes it is necessary to enter vector data where the size of the
vector is not known by the program, beforehand. When entering these vector data
with variable length, curly brackets <literal>&lcub;</literal> and
<literal>&rcub;</literal> are used to enclose the vector or list.</para>

<para>Sometimes, it is also convenient to enter a pair (or more) of vectors with
the same length so that one alternates between the lists. This is called
<emphasis> interleaved vector input</emphasis>. One represents this alternating
sequence of vectors with a comma between the different types of vector data. For
example, entering two 3 dimensional vectors
<emphasis><literal>x</literal></emphasis> and
<emphasis><literal>y</literal></emphasis> in the sequence
<literal>x<subscript>1</subscript> y<subscript>1</subscript>
x<subscript>2</subscript> y<subscript>2</subscript> x<subscript>3</subscript>
y<subscript>3</subscript></literal> would be represented by the data type
<literal>REALVEC(3),REALVEC(3)</literal>.</para>

<para>Finally, when entering two dimensional matrix data, there is always the
question of whether one should enter the data across rows, or by columns. The
default is to read by rows, unless the matrix is preceded by a string
<literal>by_column</literal> or <literal>column-wise</literal>. The row order
can also be explicitly forced by preceding the matrix with the string
<literal>by_row</literal> or <literal>row-wise</literal>. Multidimensional
matrices are always entered in the Fortran order, <literal>by_column</literal>.
That is, so the first index of the matrix is incrementing most rapidly.</para>

</sect2>

<sect2 id="changing-units">
<title>How do I change units with simple data?</title>

<para>For any simple numerical data, simply append the new units string. For
example, entering:</para>

<programlisting>1.3 angstrom</programlisting>

<para>would cause &TONTO; to interpret the number !1.3! in Angstrom units, and
&TONTO; would convert the number internally into default units, which
are atomic units. This also applies to vectors and matrices of fixed length.
For example,</para>

<programlisting>1.0 2.0 3.0 angstrom</programlisting>

<para>would represent <literal>REALVEC(3)</literal> object in Angstrom units. To see
the list of allowed units, look at the <literal>is_known_unit</literal> routine
in the <literal>STR</literal> module.</para>
</sect2>

<sect2 id="entering-derived-data">
<title>How do I enter derived data?</title>

<para>Any derived data is composed of a collection of simpler pieces of data,
including, possibly, simpler kinds of derived data. Any one of these simpler
pieces of data which make up the derived data is called a
<emphasis>component</emphasis>.  For example, for <literal>ATOM</literal> data,
there may be a <literal>STR</literal> piece of information representing the
<quote>atom label</quote> , and there may be a <literal>REALVEC(3)</literal> piece
of data representing the <quote>atom position</quote>.  Both of these are
components.</para>

<para>One way to enter derived data component information is to use keywords,
which has been explained above.  <footnote><para>This component information is
stored in <emphasis> type component variables</emphasis>.  Usually, the names of
these variable are the same as, or similar to the names of the keywords used to
input them.  It is good programming practice ensure that this is the
case</para></footnote></para>

<para>Another way to enter derived data component data is to type the 
data for each component in order, without any keywords.
For example, for <literal>ATOM</literal> just discussed, first we could type
a <literal>STR</literal>, representing the atom label, then a
<literal>REALVEC(3)</literal>, representing the atom position, like this:</para>

<programlisting>oxygen-atom   0.0  0.0  0.0</programlisting>

<para>But, we could equally well convey the same information by typing
this:</para>

<programlisting>0.0  0.0  0.0 oxygen-atom</programlisting>

<para>Clearly, it is important to know the correct order for the pieces 
of information. The correct order for an <literal>ATOM</literal> in the 
<quote>Input documentation for module <literal>ATOM</literal></quote>, under the
heading <quote>Standard input data order</quote>. It is usually the first thing
that is mentioned. This style of input is called <quote>plain style
input</quote>.  <footnote><para>It should be pointed out that derived data, such
as <literal>ATOM</literal> data, may contain extra pieces of information which
are not inputted.  For example, <literal>ATOM</literal> data contains an
<quote>atomic number</quote> represented by an <literal>INT</literal> variable.
This atomic number is not inputted, but can be worked out from the <quote>atom
label</quote>---provided the label contains a string which clearly identifies
which kind of atom it is.</para></footnote></para>

<note><para>
Plain style input is never used to input derived data.  It is only used to input
arrays of derived data (although, keyword style input can also be used for
arrays of derived data, if desired). Plain style input is used for arrays of
derived data in order to save typing keywords for inputting long lists of data.
</para></note>

</sect2>

<sect2 id="entering-lists-of-derived-data">
<title>How do I enter lists of derived data?</title>

<para>The way to input a list of plain style data is to begin with the
<literal>&lcub;</literal> symbol indicating that derived data is to follow.
Thereafter, a list of plain style data is entered, as described above. This list
is terminated by the <literal>&rcub;</literal> symbol indicating the enf of the
variable-length list.  For example, to enter a sequence of three
<literal>ATOM</literal> pieces of data---which is <literal>ATOMVEC</literal>
data---we would type:</para>
<programlisting>
&lcub;
   oxygen-atom   0.0  0.0  0.0
   N             1.0  0.0  0.0
   carbon        0.0  1.0  0.0
&rcub;
</programlisting>
<para>The indentation in the above example is not required (nor are line
breaks), but indentation is advised to improve readability.</para>

<note><para>If <literal>XXXX</literal> is the name of a data type, then
<literal>XXXXVEC</literal> is the name of the list or vector of those data
types.</para></note>

</sect2>

<sect2 id="altering-input-order">
<title>Altering the input order for lists of derived data</title>

<para>Sometimes, it is convenient to alter the order in which the components of
plain data are inputted---for example, to read some other programs data, or to
enter extra pieces of data.  This can be done using the
<literal>list_order=</literal> keyword.</para>

<para>Following the <literal>list_order=</literal> keyword is a list of allowed
keywords which specifies the new input data order to be used for the plain data.
As usual, this new list of keywords is enclosed by curly brackets
<literal>&lcub;</literal> and <literal>&rcub;</literal>.  For example, if we
wanted to enter the positions of the atoms before their atom labels, use the
following input:</para>
<programlisting>
{
   list_order= { pos=           label= }
                 0.0  0.0  0.0  oxygen-atom
                 1.0  0.0  0.0  N
                 0.0  1.0  0.0  carbon
}
</programlisting>
<para>We could also enter the above data as follows, by explicitly labelling
the listed data with an enclosing <literal>list= &lcub; ... &rcub;</literal>
descriptor which has been implied in the above example:</para>
<programlisting>
{
   list_order= { pos=           label= }
   list= {
                 0.0  0.0  0.0  oxygen-atom
                 1.0  0.0  0.0  N
                 0.0  1.0  0.0  carbon
   }
}
</programlisting>

</sect2>

<sect2 id="embedded-commands">
<title>Embedded commands in lists of derived data</title>

<para>The list of keywords in a <literal>list_order=</literal> statement need
not be data keywords: commands or embedded data can also be placed in the list.
This is useful, for example, for specifying operations on the data while the
list of data is being processed.</para>

<para>For example, we may wish to tell the program that the position coordinates
are in Angstr&ouml;m units. When entering <literal>ATOM</literal> data. This
can be done by prefacing the <literal>pos=</literal> keyword by <literal>"&lcub;
units= angstrom &rcub;"</literal> (see the <literal>units=</literal>  keyword in
module <literal>ATOM</literal>---it is usually available in every module).
Thus, to change the units for the entire list of <literal>ATOM</literal> data in
the example above, type:</para>

<programlisting>
&lcub;
list_order= &lcub; "&lcub; units= angstrom &rcub;" pos= label= &rcub;
   0.0  0.0  0.0   oxygen-atom
   1.0  0.0  0.0   N
   0.0  1.0  0.0   carbon
&rcub;
</programlisting>

<para>Note that <quote><literal>&lcub; units= angstrom &rcub;</literal></quote>
must be enclosed in double quotes to ensure it is interpreted as a single unit.
Likewise, curly brackets must be used because the contents of the quoted string
are interpreted as derived data, which must always begin and end with curly
brackets.</para>

<note><para>The curly brackets must always appear as separate characters
surrounded by blank space; or the curly bracket must be at the beginning or end
of a string.</para></note>

<para>If in the above example only the <literal>units=</literal> were to appear
in the <literal>data_order</literal>  section, then since the
<literal>units=</literal> keyword must be followed by a <literal>STR</literal>
unit identifier, this string must appear as the first data element within the
plain data list. That is, we would have to type:</para>
<programlisting>
&lcub;
   list_order= &lcub; units= pos= label= &rcub;
      angstrom 0.0  0.0  0.0   oxygen-atom
      angstrom 1.0  0.0  0.0   N
      angstrom 0.0  1.0  0.0   carbon
&rcub;
</programlisting>
<para>This would defeat somewhat the purpose of using the plain data style,
since the unit specifier <literal>angstrom</literal> must be repeated. Likewise,
since the units of each position can be changed using a post-facto units
identifier, typing the following input would also have the same effect</para>
<programlisting>
&lcub;
   list_order= &lcub; pos= label= &rcub;
      0.0  0.0  0.0 angstrom  oxygen-atom
      1.0  0.0  0.0 angstrom  N
      0.0  1.0  0.0 angstrom  carbon
&rcub;
</programlisting>
<para>In both cases the repetition of the "angstrom" string is rather
tedious.</para>

</sect2>

</sect1>

<sect1 id="example-derived-data">
<title>Examples of derived data input</title>

<sect2 id="example-gaussian">
<title>Example input for a <emphasis>GAUSSIAN</emphasis></title>

<para>A gaussian function used in theoretical chemistry is defined
by its position in three dimension space, its exponent, and
its angular momentum quantum number. These are held in
variables <literal>pos</literal>, <literal>ex</literal>, and
<literal>l</literal>. Valid keyword input for one <literal>GAUSSIAN</literal>
piece of data is:</para>

<programlisting>
&lcub; pos= 0.0 0.0 0.0 ex= 3.0 l= 2 put &rcub;
</programlisting>

<para>or:</para>
<programlisting>
&lcub;
  l=    2 
  ex=   3.0  
  pos=  0.0 0.0 0.0 
  put
&rcub;
</programlisting>
<para>Note that the last keyword <literal>put</literal> is not a data keyword,
but would actually cause an operation to be performed---in this case, outputting
the data to an output file <literal>stdout</literal>.</para>

<para>Remember also that in the above, line breaks are not significant.  The
ordering of the data keywords above corresponds to the standard input data
order.  Thus, valid plain style input for one GAUSSIAN piece of data is:</para>

<programlisting>
&lcub; 2  3.0  0.0 0.0 0.0 &rcub;
</programlisting>

<para>However, such an input line would only be used when inputting a
<emphasis>list</emphasis> of GAUSSIAN data, i.e. for a GAUSSIANVEC.</para>

</sect2>
<sect2 id="example-shell">

<title>Example input for a <emphasis>SHELL</emphasis></title>

<para>A shell is a collection of gaussian functions with the same position and
angular momentum, summed together after being weighted by some
<quote>contraction coefficients</quote>.</para>

<para>For efficiency reasons, a shell is not represented as a list of
<quote>gaussian data</quote>, since there would be some duplicated information.
Instead, a shell is stored in &TONTO; by the following variables: its
<quote>angular momentum</quote> <literal>l</literal>, an <literal>INT</literal>,
the exponents of each gaussian function, <literal>ex</literal>, a
<literal>REALVEC</literal>, the contraction coefficients, <literal>cc</literal>,
also a <literal>REALVEC</literal>, the number of contractions coefficients,
<literal>n_cc</literal>, an <literal>INT</literal>, and the number of different
functions in the shell, <literal>n_comp</literal>.</para>

<para>Not all this information is inputted. For example,
<literal>n_comp</literal>  is currently evaluated from the variable
<literal>l</literal>. Further, some information is inputted in a form which does
not agree with the way that the information is stored. For example, there is a
data keyword <literal>l</literal>, but this has type <literal>STR</literal>. It
is valid to enter an integer, such as <literal>"2"</literal> after the
<literal>l</literal> data keyword---it will be converted to an
<literal>INT</literal> and stored in the variable <literal>l</literal>. However,
you could also input "d", since it is commonly understood that "d" usually means
a function with angular momentum <literal>2</literal>. </para>

<para>It should also be noted when reading the documentation for the
<literal>ex=</literal> or <literal>cc=</literal> data keywords, that these
keywords can be used only after the <literal>n_cc=</literal> keyword.</para>

<para>Here then is some valid keyword style input for a <literal>SHELL</literal>
piece of information:</para>

<programlisting>
&lcub;
  l=    D
  n_cc= 3
  ex=   1.0 2.0 3.0
  cc=   0.1 0.2 0.3
&rcub;
</programlisting>
<para>We can also enter the data like this:</para>
<programlisting>
&lcub;
  l=    D
  n_cc= 3
  ex,cc= 1.0 0.1 2.0 0.2 3.0 0.3
&rcub;
</programlisting>
<para>Here, the data keyword <quote><literal>ex,cc=</literal></quote> indicates
that components of the <literal>ex</literal> vector and <literal>cc</literal>
vector are to be entered simultaneously, component-wise, in pairs: the first
element of <literal>ex</literal>, then the first element of
<literal>cc</literal>, the second element of <literal>ex</literal>, and then the
second element of <literal>cc</literal>, and so on. This is called
<emphasis>interleaved vector input</emphasis>, and is represented in the
documentation by a data type declaration like this:</para>

<variablelist>
<varlistentry>
<term>ex,cc= REALVEC(n_cc),REALVEC(n_cc)</term>
<listitem><para>Enter the exponents <literal>ex=</literal> and contraction
coefficients <literal>cc=</literal> for the gaussian shell in alternating
style.</para></listitem>
</varlistentry>
</variablelist>

<para>The <literal>n_cc</literal> within the <literal>REALVEC(n_cc)</literal> symbol
indicates that the arrays <literal>ex</literal> and <literal>cc</literal> have
length equal to the <literal>SHELL</literal> component variable
<literal>n_cc</literal>.</para>

<para>Finally, since the default input data order is <literal>l= n_cc=
ex,cc=</literal>, a valid plain-style input equivalent to the last example
is:</para>
<programlisting>
&lcub;
 D 3
 1.0 0.1 
 2.0 0.2 
 3.0 0.3
&rcub;
</programlisting>

<!-- *********************************************************************** -->
<!-- *********************************************************************** -->

</sect2>
</sect1>
</chapter>

<chapter id="example-input-files">

<title>Examples of &TONTO; input files</title>

<para>This chapter gives examples of some common input files for the
<literal>run_mol.x</literal> executable.</para>

<para>It should not be used as a substitute for reading the previous chapter
which explains how input is entered; nor a substitute for a careful examination
of the following chapter which gives the exhaustive keyword
documentation.</para>

<!-- *********************************************************************** -->

<sect1 id="rhf">
<title>A restricted Hartree-Fock calculation</title>

<para>The following is a restricted Hartree-Fock calculation for
H<subscript>2</subscript>O with a manually entered basis set.</para>

<programlisting>
&lcub;

   name=     h2o
   
   charge=   0
   
   multiplicity= 1
   
   atoms= &lcub;
      list_order= &lcub; label= pos= basis= &rcub;
      list= &lcub;
         O  0.000000     .000000     .000000  O-DZP
         H  1.107       1.436        .0       H-DZP
         H  1.107      -1.436        .0       H-DZP
      &rcub;
   &rcub;
   
   basis_sets= &lcub;
   list= &lcub;
   O-DZP
   &lcub;
       S   6
              7816.54000000       0.00203100
              1175.82000000       0.01543600
               273.18800000       0.07377100
                81.16960000       0.24760600
                27.18360000       0.61183200
                 3.41360000       0.24120500
       S   1
                 9.53220000       1.00000000
       S   1
                 0.93980000       1.00000000
       S   1
                 0.28460000       1.00000000
       P   4
                35.18320000       0.01958000
                 7.90400000       0.12418900
                 2.30510000       0.39472700
                 0.71710000       0.62737500
       P   1
                 0.21370000       1.00000000
       D   1
                 0.85000000       1.00000000
   &rcub;
   H-DZP
   &lcub;
       S   3
                19.24060000       0.03282800
                 2.89920000       0.23120800
                 0.65340000       0.81723800
       S   1
                 0.17760000       1.00000000
       P   1
                 1.00000000       1.00000000
   &rcub;
   &rcub;
   &rcub;
   
   scfdata= &lcub;
      initial_guess= atom
      kind=          rhf
      direct=        on
      diis=          on
      diis_keep=     8
      diis_start=    0
   &rcub;
   
   put

   scf
   
&rcub;
</programlisting>
</sect1>

<!-- *********************************************************************** -->
<sect1 id="library-basis-sets">
<title>Using the library basis sets</title>

<para>The following is a restricted Hartree-Fock calculation for
H<subscript>2</subscript>O using a library basis set.</para>

<para>Please note that the &TONTO; library may not contain the basis sets you
require. Look in the <literal>basis_sets</literal> directory to see a list of
available basis sets arranged in files according to the traditional base name,
e.g.  <literal>dzp</literal>, <literal>631+g*</literal>, etc.</para>


<programlisting>
&lcub;

   name=     h2o
   
   charge=   0
   
   multiplicity= 1
   
   atoms= &lcub;
      list_order= &lcub; label= pos= basis= &rcub;
      list= &lcub;
         O  0.000000     .000000     .000000  
         H  1.107       1.436        .0       
         H  1.107      -1.436        .0       
      &rcub;
   &rcub;

   basis_set_directory= ./basis_sets   ! This is the &TONTO; default
                                     ! Always specify *before* basis_set_kind=
   basis_set_kind= dzp
   
   scfdata= &lcub;
      initial_guess= atom
      kind=          rhf
      direct=        on
      diis=          on
      diis_keep=     8
      diis_start=    0
   &rcub;
   
   put

   scf
   
&rcub;
</programlisting>
</sect1>

<!-- *********************************************************************** -->
<sect1 id="gaussian-checkpoint-input">

<title>Input from a gaussian checkpoint file</title>

<para>Gaussian is a well known <emphasis>ab initio</emphasis> program used for
calculating wavefunctiond and properties in the gaussian basis set expansion
formalism.</para>

<para>Before you can run this calculation, you must run Gaussian using the FChk
option to produce an ASCII checkpoint file called <filename>Test.FChk</filename>
by default. You can rename this file to anyuthing you like, but in the example
below which merely reads the information, we used the original name.</para>

<para>We have only performed a <literal>put</literal> operation, but many other
operations can be performed, as if the calculations done in Gaussian had been
run in &TONTO;.</para>

<note><para>Since &TONTO; can only hold one density matrix in its memory at any
given time, at the moment only the SCF density matrix is inputted into &TONTO;
from the <literal>Test.Fchk</literal> file.  If you want to inpu other density
matrices, you may have to manually alter the <literal>Test.Fchk</literal> file
by over-writing the SCF density matrix with the one you actually need, e.g. the
MP2 relaxed density matrix or the QCISD relaxed density matrix.</para></note>

<programlisting>
&lcub;

   read_g94_checkpoint_file Test.FChk

   put
   
&rcub;
</programlisting>
</sect1>

<!-- *********************************************************************** -->

<sect1 id="output-morphy">
<title>Outputting a MORPHY input file</title>

<para>MORPHY is a program for producing properties from the electron densities
of wavefunctions expanded in gaussian basis sets, using Bader and coworkers
Atoms in Molecules (AIM) technique.</para>

<para>This job shows a conversion of a Gaussian checkpoint file into a MORPHY 
<filename>.wfn</filename> input file.</para>

<programlisting>
&lcub;

   read_g94_checkpoint_file Test.FChk

   put

   put_morphy_wfn_file 

&rcub;
</programlisting>
</sect1>

<!-- *********************************************************************** -->

<sect1 id="constrained-X-ray-calc">
<title>A constrained X-ray wavefunction calculation</title>

<para>This represents a simple wavefunction fiting calculation for a single
NH<subscript>3</subscript> unit in the ammonia crystal. The geometry for a
larger cluster has been included and commented out. It was generated using the
<literal>put_cluster_input</literal> command. To select subparts of a large
cluster, refer to the <literal>repetation_factors=</literal> keyword.</para>

<note><para>For brevity, most of the experimental structure fcators have been
omitted.</para></note>

<note><para>This input deck uses the <literal>games-us</literal> style of basis
input.</para></note>

<programlisting>
&lcub;

  name=     nh3_1
 
  charge=  0
 
  multiplicity= 1
 
  crystal= &lcub;
 
    spacegroup_it_symbol=   P2_13
    unit_cell_angles=      90.0   90.0   90.0       Degree
    unit_cell_dimensions=   5.1305 5.1305 5.1305    Angstrom
 
    thermal_smearing_model= stewart
    partition_model= mulliken
    optimise_extinction= true
 
    reflection_data=  &lcub;
   
      ! Experimental data from Boese et al ...
 
      list_order= &lcub; h= k= l= F_exp= F_sigma= &rcub;
   
      list= &lcub;

      ! These are the real experimental data

       1   1   0    18.093    0.118
       1   1   1    63.470    0.446
       0   2   0    53.079    0.434
       1   2   0     2.864    0.084

       ! Some data deleted here for the example ...

      &rcub;
    &rcub; 
  &rcub;
   
  atoms= &lcub;

    list_order= 
       &lcub; label= "&lcub; axis_system= crystal &rcub;" pos= basis_label= 
         "&lcub; units= angstrom^2 &rcub;" thermal_tensor= &rcub;

    list= &lcub;

    N  0.2103001  0.2103001  0.2103001 N_631 0.0372 0.0372 0.0372 -0.0009 -0.0009 -0.0009
    H  0.3722001  0.2627001  0.1113001 H_631 0.0530 0.0530 0.0530  0.0000  0.0000  0.0000
    H  0.1113001  0.3722001  0.2627001 H_631 0.0530 0.0530 0.0530  0.0000  0.0000  0.0000
    H  0.2627001  0.1113001  0.3722001 H_631 0.0530 0.0530 0.0530  0.0000  0.0000  0.0000
 
  ! These atoms coords were produced with the "put_cluster_input" command 

  ! N  0.2897001 -0.2103001 -0.2897001 N_631 0.0372 0.0372 0.0372 -0.0009 -0.0009 -0.0009
  ! N -0.2897001  0.2897001 -0.2103001 N_631 0.0372 0.0372 0.0372 -0.0009 -0.0009 -0.0009
  ! N -0.2103001 -0.2897001  0.2897001 N_631 0.0372 0.0372 0.0372 -0.0009 -0.0009 -0.0009
  ! H  0.1278001 -0.2627001 -0.3887000 H_631 0.0530 0.0530 0.0530  0.0000  0.0000  0.0000
  ! H -0.3887000  0.1278001 -0.2627001 H_631 0.0530 0.0530 0.0530  0.0000  0.0000  0.0000
  ! H -0.2627001 -0.3887000  0.1278001 H_631 0.0530 0.0530 0.0530  0.0000  0.0000  0.0000
  ! H -0.1278001  0.2373000 -0.1113001 H_631 0.0530 0.0530 0.0530  0.0000  0.0000  0.0000
  ! H -0.1113001 -0.1278001  0.2373000 H_631 0.0530 0.0530 0.0530  0.0000  0.0000  0.0000
  ! H  0.2373000 -0.1113001 -0.1278001 H_631 0.0530 0.0530 0.0530  0.0000  0.0000  0.0000
  ! H  0.3887000 -0.3722001 -0.2373000 H_631 0.0530 0.0530 0.0530  0.0000  0.0000  0.0000
  ! H -0.2373000  0.3887000 -0.3722001 H_631 0.0530 0.0530 0.0530  0.0000  0.0000  0.0000
  ! H -0.3722001 -0.2373000  0.3887000 H_631 0.0530 0.0530 0.0530  0.0000  0.0000  0.0000

    &rcub; 
  &rcub;
  
  
  
  basis_sets= &lcub;

    list_order= &lcub; gamess-us= &rcub;

    list= &lcub;

    N_631 ! 6311++g**
    &lcub;
       S   6
        1        6293.480000         0.1969790000E-02
        2        949.0440000         0.1496130000E-01
        3        218.7760000         0.7350060000E-01
        4        63.69160000         0.2489370000    
        5        18.82820000         0.6024600000    
        6        2.720230000         0.2562020000    
       S   3
        1        30.63310000         0.1119060000     
        2        7.026140000         0.9216660000     
        3        2.112050000        -0.2569190000E-02 
       P   3
        1        30.63310000         0.3831190000E-01
        2        7.026140000         0.2374030000    
        3        2.112050000         0.8175920000    
       S   1
        1       0.6840090000          1.000000000    
       P   1
        1       0.6840090000          1.000000000    
       S   1
        1       0.2008780000          1.000000000    
       P   1
        1       0.2008780000          1.000000000    
       D   1
        1       0.913000000           1.00000000    
       S   1
        1       0.639000000E-01       1.00000000    
       P   1
        1       0.639000000E-01       1.00000000    
    &rcub; 
  
    H_631 ! 6311++g**
    &lcub;
       S   3
        1       33.86500000          0.2549380000E-01
        2       5.094790000          0.1903730000    
        3       1.158790000          0.8521610000    
       S   1
        1       0.3258400000         1.000000000    
       S   1
        1       0.1027410000         1.000000000    
       P   1
        1       0.750000000          1.00000000    
       S   1
        1       0.360000000E-01      1.00000000    
    &rcub; 

    &rcub;
  &rcub;


  scfdata= &lcub;

    kind=            xray_rhf
    initial_guess=   atom
    direct=          on
    max_it=          50
    eri_limit=       1.0d-20

    initial_lambda=  0.000000
    lambda_max=      0.001000
    lambda_step=     0.001000

    ! Convergence options

    diis_keep=       12
    diis_start=      0
    diis=            on 
    level_shift=     1.0
    damp_factor=     0.5
    damp_finish=     3
  &rcub;
  

  output_style_options= &lcub;
    int_width= 5
    real_width= 14
    precision= 6
  &rcub;

  scf

&rcub;
</programlisting>
</sect1>

<!-- *********************************************************************** -->
<sect1 id="pair-energy-decomposition">
<title>An MO pair-energy decompisitoin</title>

<para>This performs an MO energy decompisition into single MO energy terms, and
pair MO energy terms, for the H<subscript>2</subscript>O molecule, according to
the usual SCF energy expression.</para>

<programlisting>
&lcub;

   name=     h2o
   
   charge=   0
   
   multiplicity= 1
   
   atoms= &lcub;
      O  0.000000     .000000     .000000  
      H  1.107       1.436        .0       
      H  1.107      -1.436        .0       
   &rcub;

   basis_set_directory= ./basis_sets   ! This is the &TONTO; default
                                     ! Always specify *before* basis_set_kind=
   basis_set_kind= dzp
   
   scfdata= &lcub;
      initial_guess= atom
      kind=          rhf
      direct=        on
      diis=          on
      diis_keep=     8
      diis_start=    0
   &rcub;
   
   put

   scf

   put_scf_energy_in_mo_pairs
   
&rcub;
</programlisting>
</sect1>

<!-- *********************************************************************** -->

<sect1 id="morokuma-analysis">
<title>Morokuma-like analysis</title>

<para>The following calculation performs a Morokuma like energy
decomposition, firstly for a density matrix which is the
(direct) sum of two non-interacting water molecule, density matrices;
and then for the case when the orbitals of the two water moleculeso
are symmetrically orthonormalised to form a promolecule single
determinant.</para>

<para>Note that this only works for closed shell molecular fragments
at the moment.</para>

<programlisting>
&lcub;

   name=     h2o
   
   charge=   0
   
   multiplicity= 1
   
   atoms= &lcub;
      O  0.000000     .000000     .000000  
      H  1.107       1.436        .0       
      H  1.107      -1.436        .0       
   &rcub;

   basis_set_directory= ./basis_sets   ! This is the &TONTO; default
                                     ! Always specify *before* basis_set_kind=
   basis_set_kind= dzp

   
   atom_groups= &lcub;

     atom_group= &lcub; 1 2 3&rcub;
     atom_range= 4 6
     group_charges= &lcub; 0 0 &rcub;

   &rcub;
   

   put


   make_group_density_matrix

   put_MO_energy_partition

   make_promol_density_matrix

   put_MO_energy_partition

   scf
&rcub;
</programlisting>

<para>You may also produce plots from the group, or promolecule density
matrices. You would first have to <literal>make_ao_density_matrix</literal>,
which makes a (spin independent) density matrix, and then
<literal>make_natural_orbitals</literal>, since the plots are always made from
an existing set of natural orbitals.</para>

</sect1>

<!-- *********************************************************************** -->
<sect1 id="spin-density-plot">
<title>Spin density plot</title>

<para>The following calculation makes a <literal>gnuplot</literal> mesh of the
spin density for H<subscript>2</subscript>O<superscript>+</superscript>. The
centre of the plot is defined to be the position of the O atom, and the
<emphasis>x</emphasis> axis is defined to be along the OH bond, where H is the
first H atom in the list. The <emphasis>y</emphasis> axis is defined to be the
perpendicular component of the vector from O to the second H atom. There are 101
points in the mesh, and it will be a square of 10 au by 10 au.</para>

<programlisting>
&lcub;

   name=     h2o
   
   charge=   +1
   
   multiplicity= 3
   
   atoms= &lcub;
      O  0.000000     .000000     .000000  
      H  1.107       1.436        .0       
      H  1.107      -1.436        .0       

      O  0.000000     .000000    2.000000  
      H  1.107       1.436       2.0       
      H  1.107      -1.436       2.0       
   &rcub;

   basis_set_directory= ./basis_sets   ! This is the &TONTO; default
                                     ! Always specify *before* basis_set_kind=
   basis_set_kind= dzp
   

   scfdata= &lcub;

      kind=          uhf

   &rcub;


   scf


   plotgrid= &lcub;

      kind = spin_density

      centre_atom= 1

      x_axis_atoms= 1 2
      y_axis_atoms= 1 2

      x_points = 201

      x_width = 10.0
      y_width = 10.0

   &rcub;
   

   plot

&rcub;
</programlisting>
</sect1>

<!-- *********************************************************************** -->

<sect1 id="ELF-plot">
<title>ELF density plot</title>

<para>The following calculation makes a <command>gnuplot</command> mesh of the
ELF density for H<subscript>2</subscript>O. The details are as for the spin
density plot, except the plot plane is offset along the <emphasis>z</emphasis>
axis by 1 au.</para>

<programlisting>
&lcub;

   name=     h2o
   
   charge=   0
   
   multiplicity= 1
   
   atoms= &lcub;
      O  0.000000     .000000     .000000  
      H  1.107       1.436        .0       
      H  1.107      -1.436        .0       

      O  0.000000     .000000    2.000000  
      H  1.107       1.436       2.0       
      H  1.107      -1.436       2.0       
   &rcub;

   basis_set_directory= ./basis_sets   ! This is the &TONTO; default
                                     ! Always specify *before* basis_set_kind=
   basis_set_kind= dzp
   

   scfdata= &lcub;

      kind=          uhf

   &rcub;


   scf


   plotgrid= &lcub;

      kind = elf

      centre_atom= 1
      x_axis_atoms= 1 2
      y_axis_atoms= 1 2
      x_points = 201
      x_width = 10.0
      y_width = 10.0

      z_axis_offset= 1

   &rcub;
   

   plot

&rcub;
</programlisting>
</sect1>

<!-- *********************************************************************** -->
<sect1 id="ZORA-calc">
<title>A ZORA relativistic calculation, g<subscript>zz</subscript> tensor
calculation, and parity violating weak force energy shift calculation</title>

<para>The following calculation is a two-component relativistic general complex
Hartree-Fock calcyulation, followed by an evaluation of the
g<subscript>zz</subscript> tensor for the OH molecule.</para>

<programlisting>
&lcub;

   name=     oh
   
   charge=   0
   
   multiplicity= 1
   
   atoms= &lcub;
      O  0.000000     .000000     .000000  
      H  0.000000    0.000000    1.800000  
   &rcub;

   basis_set_directory= ./basis_sets   ! This is the &TONTO; default
                                     ! Always specify *before* basis_set_kind=
   basis_set_kind= dzp
   

   scfdata= &lcub;
      kind=          uhf
   &rcub;

   scf
   

   scfdata= &lcub;
      kind=          gchf
      initial_mos=    uhf
      quantization_axis=  0 0 1
      convergence=        0.0000001
      diis_convergence=   0.0000001

      use_1e_ZORA_term= true
      use_2e_sl_term= no
   &rcub;

   scf


   put_g_tensor_information

   make_weak_force_energy_shift

&rcub;
</programlisting>

<note><para>This job is untested. The two electron part has been switched
off because there is currently a bug.</para></note>
</sect1>
</chapter>

<!-- *********************************************************************** -->
<!-- *********************************************************************** -->

<chapter id="keywords">
<title>Keyword documentation for &TONTO;</title>

<para>This chapter describes the current set of keywords used in &TONTO;.</para>

<para>You must have read <xref linkend="calc-chap"/> in order to understand the
documentation.</para>

<para>Even though the online documentation is primarily for programmers, there
is a short introduction on how to use the online documentation to find keywords
and what needs to be entered after those keywords.</para>

<para>For those that prefer a book, the keyword documentation for every module
is given.  It is comprised of a short synopsis, and then a listing of all valid
keyword tokens, a description of the type of data which are required to follow
the keyword (if any), as well as explanatory notes and special conditions
applying to that keyword.</para>

<para>Not all modules in &TONTO; have keywords input: only modules which are
more complex than a <literal>TEXTFILE</literal> can have keywords, since a
module that uses keywords must use the <literal>TEXTFILE</literal>
module.</para>

<!-- *********************************************************************** -->

<sect1 id="online-doc">
<title>The online documentation</title>

<para>The online documentation is intended mainly for programmers, but it can be
easily used to find keywords and to find what should be entered after a
keyword.</para>

<para>The online documentation is compirised of two parts: the short
documentation, and the long documentation. You will need to understand what you
are looking at in these two parts before you can find the keywords and what they
require as input.</para>

<para>If you have not already made the documentation, refer to <xref
linkend="making-documentation"/>.</para>

<sect2 id="short-docs">
<title>The short documentation</title>

<para>The short documentation for a module is obtained by clicking your mouse on
the module name in the left frame bar of the &TONTO; homepage, or the left frame
bar when you open the file <literal>documentation/index.html</literal>. </para>

<para>It consists of 
<itemizedlist>
<listitem><para> a <quote>Synopsis</quote> describing what kind of object the
module is intended for</para></listitem>
<listitem><para> a list of the <quote>Used modules</quote> which are required by
the module</para></listitem>
<listitem><para> a list (in green) of the <quote>type components</quote> used to
store information for this type (if it is not an array or a simple data type).
There is an explanation of what each type component represents, and and what
type of data is held in the component, following the double colon
<literal>::</literal></para></listitem>
<listitem><para> a list of any explicitly constructed <quote>generic
interfaces</quote> and the module procedures which make up these generic
interface names; this section is not present in many modules</para></listitem>
<listitem><para> a list (in red) of the <quote>procedures components</quote>
which comprise the code components of the module, and the arguments that these
routines take, together with an explanation of what the procedure
does.</para></listitem>
</itemizedlist></para>

<para>You can click your browser on any underlined item to obtain more detailed
information---usually, the actual code in the long documentation---for that
item. </para>
</sect2>

<!-- *********************************************************************** -->

<sect2 id="long-docs">
<title>The long documentation</title>

<para>The long documentation is comprised essentially of the
<command>foo</command> code for the module.</para>

<para>Again, you will see green <quote>type components</quote> or red
<quote>procedure components</quote> in this code.  You can click on these  to
find out exactly what they are.</para>
</sect2>

<!-- *********************************************************************** -->

<sect2 id="finding-keywords">
<title>Finding keywords in &TONTO; online</title>

<para>According to the design of &TONTO;, every module which accepts keywords
must have a <literal>process_input(word)</literal> routine. This will appear in
red.</para>

<para>You can get an up-to-date list of keywords used in &TONTO; by looking in
the <literal>process_input</literal> routine in the long html documentation, as
explained below.</para>

<para>As well as being convenient, this is particularly useful when there are
undocumented keywords, or keywords which have been incorrectly documented
(sorry).</para>

<para>The procedure for finding keyword documentation is as follows:
<itemizedlist>
<listitem><para>Decide which module the keyword resides. This will invariably be
the <literal>MOL</literal> module.</para></listitem>
<listitem><para>Click on the documentation for that module in framebar on the
left.</para>
<para>For the <literal>MOL</literal> module, you may have to click on the
<literal>mol_main</literal> module which contains the <literal>read</literal>
routine.</para>
<para>Do not click the <literal>foo</literal> part of the module name: that will
give you the raw <literal>foo</literal> code.</para></listitem>
<listitem><para>Find the <literal>process_input</literal> routine within the
short html documentation in the main documentation windo on the right. Click on
it.</para></listitem>
<listitem><para>You will now be within the code of a routine. Scroll down until
you can see a <literal>case</literal> statement. Following this case statement
there will be many strings involving data keywords such as
<literal>name=</literal> or task keywords like <literal>scf</literal>.  These
are the allowed keywords.</para></listitem>
<listitem><para>To see what kind of data might be accepted by this keyword, look
to the corresponding code to the right of the case option. </para></listitem>
<listitem><para>In the simple case,
a variable may be inputted directly from that line, like this:
<programlisting>
   case("name=");   stdin.read(.name)
</programlisting>
which means the variable <literal>.name</literal> (usually in green) is to be
inputted from the input file, <literal>stdin</literal>. Click on the variable
<literal>.name</literal> to see what data type it is (e.g. a string,
<literal>STR</literal>, or a double precision number, <literal>REAL</literal>).
Since in this case <literal>.name</literal> is a <literal>STR</literal>, you
know that following the <literal>name=</literal> keyword you 
must enter a <literal>STR</literal>.</para></listitem>
<listitem><para>In the more usual case, a routine may be called, like this:
<programlisting>
   case("name=");   .read_name
</programlisting>
where the routine <literal>.read_name</literal> is in red. Click on this routine
to get to the short documentation.  Click again to see the code associated with
the routine.  In this code, which will invariably very short, you may see
exactly what is being inputted. For example, there may be a line like this:
<programlisting>
   case("name=");   stdin.read(.name)
</programlisting>
exactly as in the case above.</para>
<para>If a <literal>STR</literal> variable in being read in, and if there are
only a few allowed options for this string variable, there should be a
<literal>case</literal> statement telling you what options are allowed.</para>
<para>If you do not see a <literal>stdin.read(...)</literal> line within your
routine, keep reading.</para></listitem>

<listitem><para>Sometimes, a read routine, for example the
<literal>read_name</literal> above, may call other read routines to input data.
An example might be
<programlisting>
   .shell.read
</programlisting>
where <literal>.shell</literal> is in green and <literal>.read</literal> is in
red.  There may be a sequence of these routines. This is particularly true of
derived data input.  In this case, follow each <literal>.read</literal>-like
routine by clicking on it. Eventually, you will come to code in which simple
data such as strings or numbers are inputted. The order that you should enter
these data, is the sequential order that you click on the routines, from top to
bottom.</para></listitem>
</itemizedlist></para>
</sect2>
</sect1>

<!-- *********************************************************************** -->

<sect1 id="ATOM">
<title><literal>ATOM</literal></title>

<sect2 id="ATOM-purpose">
<title>Purpose</title>

<para>A quantum mechanical atom with a basis set</para>
</sect2>

<sect2 id="ATOM-synopsis">
<title>Synopsis</title>

<para>This object is used both for positional information and basis set
information.  Atomic natural orbitals and occupations are stored for Roby
population analysis reasons.</para>

<para>Information about thermal motion (for X-ray calcculations) is also stored,
as well as Bragg-Slater radii and nuetron scattering lengths.</para>
</sect2>

<sect2 id="ATOM-input">
<title>Default input data order</title>

<programlisting>
ATOM_INPUT_DATA_ORDER     [ label= pos= basis_label= ]
</programlisting>
</sect2>

<sect2 id="ATOM-keywords">
<title>Listing of keywords</title>

<variablelist>
<varlistentry>
<term><literal>axis_system= STR</literal></term>
<listitem><para>Read a string which describes the axis system.</para>
<itemizedlist>
<listitem><para>Currently allowed options are <literal>cartesian</literal> or
<literal>crystal</literal></para></listitem>
<listitem><para>Note that the <literal>thermal_axis_system</literal> is
changed to be the same as the <literal>axis_system</literal></para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>basis= BASIS</literal></term>
<listitem><para>Read a complete basis set.</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>basis_label= STR</literal></term>
<listitem><para>Read only a the basis set label for the atom.</para>
<itemizedlist>
<listitem><para>Modules which use the <literal>ATOM</literal> module may resolve
the missing basis set information from a library file, or from
an inputted <literal>BASISVEC</literal> object.</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>group= INT</literal></term>
<listitem><para>Read an integer index which represents the group the atom
belongs to.</para>
<itemizedlist>
<listitem><para>Different atoms which have the same index belong in the same
group.</para></listitem>
<listitem><para>The index can be used, for example, when calculating the
properties of a group of atoms within a molecule, or interaction between groups
of atoms.</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>junk= STR</literal></term>
<listitem><para>Read in a junk string</para>
<itemizedlist>
<listitem><para>This is useful for ignoring a data field from input which has
not been generated by &TONTO;</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>label= INT|STR</literal></term>
<listitem><para>Read in an atom label.</para>
<itemizedlist>
<listitem><para>If the atom label is an integer it is assumed to be the atomic
number of the atom</para></listitem>
<listitem><para>If the atom label is a string, the first two characters must be
the periodic table symbol for that atom followed by (optionally) an integer, for
example <literal>Cu13</literal></para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>pos= REALVEC(3)</literal></term>
<listitem><para>Read in the position of the atom in some
<literal>axis_system</literal></para>
<itemizedlist>
<listitem><para>Refer to the <literal>axis_system</literal>
keyword</para></listitem>
<listitem><para>If the <literal>axis_system</literal> is
<literal>crystal</literal>, the positions in cartesian coordinates can only be
determined when information about a corresponding <literal>CRYSTAL</literal> is
provided</para></listitem>
<listitem><para>Refer to the <literal>resolve_axis_system</literal>
routine</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>put</literal></term>
<listitem><para>Print out information about the atom to
<literal>stdout</literal> in human readable form.</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>thermal_axis_system= STR</literal></term>
<listitem><para>Read a string which describes the axis system for the
<literal>thermal_tensor</literal> of the atom.</para>
<itemizedlist>
<listitem><para>Currently allowed options are <literal>cartesian</literal> or
<literal>crystal</literal></para></listitem>
<listitem><para>This keyword is only required for cases where the
<literal>axis_system</literal> and <literal>thermal_axis_system</literal> are
different</para></listitem>
<listitem><para>Refer to the <literal>thermal_tensor=</literal>
keyword.</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>thermal_tensor= REALVEC(6)</literal></term>
<listitem><para>Read in the anisotropic Debye-Waller factors or thermal tensor
<literal>U</literal> for the atom in the order
<literal>U<subscript>11</subscript></literal>
<literal>U<subscript>22</subscript></literal>
<literal>U<subscript>33</subscript></literal>
<literal>U<subscript>12</subscript></literal>
<literal>U<subscript>13</subscript></literal>
<literal>U<subscript>23</subscript></literal></para>
<itemizedlist>
<listitem><para>For a definition of the thermal tensor see the
<literal>read_thermal_tensor</literal> routine</para></listitem>
<listitem><para>Be careful with units; the
<emphasis><literal>U</literal></emphasis> tensor is often given in
<literal>angstrom^2</literal> units</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>units= STR</literal></term>
<listitem><para>Read a string which describes the units of the next inputted
numerical entity; that is, the next real or complex number, real or complex
vector, or real or complex matrix.</para>
<itemizedlist>
<listitem><para>The default atomic units are restored after the numerical entity
has been inputted</para></listitem>
<listitem><para>Warning: if the next inputted datum is not a numerical entity,
the new units keyword remains in force</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

</sect2>
</sect1>

<!-- *********************************************************************** -->

<sect1 id="BASIS">
<title><literal>BASIS</literal></title>

<sect2 id="BASIS-purpose">
<title>Purpose</title>

<para>A segmented gaussian basis set object for quatum mechanical
calculations.</para>
</sect2>

<sect2 id="BASIS-synopsis">
<title>Synopsis</title>

<para>This is essentially just a <literal>SHELLVEC</literal> with a label for
the name of the basis set.</para>

<para>It's functionality is limited to reading input and unnormalising or
renormalising.</para>
</sect2>

<sect2 id="BASIS-input">
<title>Default input data order</title>

<programlisting>
BASIS_INPUT_DATA_ORDER     [ label= shells= ]
</programlisting>
</sect2>

<sect2 id="BASIS-keywords">
<title>Listing of keywords</title>

<variablelist>
<varlistentry>
<term><literal>gamess-us= </literal></term>
<listitem><para>Read in a basis set in the GAMESS-US or CADPAC style input; the
input format does not form part of the &TONTO; system.</para>
<itemizedlist>
<listitem><para>The input is comprised of <literal>label=</literal> followed by
a <literal>SHELLVEC</literal> input order of <literal>l_chr=</literal>,
<literal>n_cc=</literal>, <literal>junk,ex,cc=</literal></para></listitem>
<listitem><para>Refer to the <literal>SHELL</literal> module documentation for
further information</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>label= STR</literal></term>
<listitem><para>Read a basis label</para>
<itemizedlist>
<listitem><para>The label should be unique</para></listitem>
<listitem><para>If a basis set library or file is to be used, the label
should correspond to an existing basis set in the library or
file</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>put</literal></term>
<listitem><para>Print out information about the atom to
<literal>stdout</literal> in human readable form</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>shells= SHELLVEC</literal></term>
<listitem><para>Read in a list of shells describing the basis set.</para>
<itemizedlist>
<listitem><para>So far, only segmented basis sets can be
entered</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>units= STR</literal></term>
<listitem><para>Read a string which describes the units of the next inputted
numerical entity; that is, the next real or complex number, real or complex
vector, or real or complex matrix.</para>
<itemizedlist>
<listitem><para>The default atomic units are restored after the numerical entity
has been inputted</para></listitem>
<listitem><para>Warning: if the next inputted datum is not a numerical entity,
the new units keyword remains in force</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>
</sect2>

</sect1>

<!-- *********************************************************************** -->

<sect1 id="CRYSTAL">
<title><literal>CRYSTAL</literal></title>

<sect2 id="CRYSTAL-purpose">
<title>Purpose</title>

<para>A representation of a crystal, from a mainly diffraction perpective</para>
</sect2>

<sect2 id="CRYSTAL-synopsis">
<title>Synopsis</title>

<para>A crystal is comprised of a unit cell information, 
<literal>SPACEGROUP</literal> information, and diffraction reflection
information stored as <literal>REFLECTIONVEC</literal>.</para>

<para>The module provides considerable functionality, including the ability to
produce predicted structure factors by optimising scla e and extinction
corrections. It can also sum certain fourier transform integrals (charge, spin,
current) into unique combinations for structure factor calculations, or
constrained wavefunction calculations. It can also determine neighbouring atoms
and clusters from an initial fragment, as well as repetition factors,
<literal>Z</literal> factors, asymmetric units and so on. There are various
statistical routines which calculate agreement factors between calculated and
observed structure factors, inclusing some plot-generating routines (scatter
plots, QQ-plots, etc).</para>
</sect2>

<sect2 id="CRYSTAL-input">
<title>Default input data order</title>

<para>There is no associated CRYSTALVEC type; an input data order has not been
defined.</para>
</sect2>

<sect2 id="CRYSTAL-keywords">
<title>Listing of keywords</title>

<variablelist>
<varlistentry>
<term><literal>cell_angles= REALVEC(3)</literal></term>
<listitem><para>Read the unit cell angles in the order &alpha;, &beta;,
&gamma;.</para>
<itemizedlist>
<listitem><para>Use the <literal>degrees</literal> unit modifier to change from
default of radians</para></listitem>
<listitem><para><literal>unit_cell_angles=</literal> is
synonymous</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>cell_lengths= REALVEC(3)</literal></term>
<listitem><para>Read the unit cell lengths in the order <literal>a</literal>,
<literal>b</literal>, <literal>c</literal>.</para>
<itemizedlist>
<listitem><para>Use the <literal>angstrom</literal> unit modifier to change from
default of atomic units</para></listitem>
<listitem><para><literal>unit_cell_lengths=</literal> and
<literal>unit_cell_dimensions=</literal> are synonymous</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>correct_dispersion= BIN</literal></term>
<listitem><para>Read a switch which tells whether to correct dispersion when
calculating the structure factors</para>
<itemizedlist>
<listitem><para>The method uses atomic dispersion factors</para></listitem>
<listitem><para>The method may be buggy</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>destroy_reflection_data</literal></term>
<listitem><para>If any reflection data are stored, destroy it in preparation for
fresh data</para>
<itemizedlist>
<listitem><para>The reflection data are entered using the
<literal>reflection_data=</literal> keyword</para></listitem>
<listitem><para>This is synonymous with
<literal>erase_reflection_data</literal></para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>destroy_spacegroup</literal></term>
<listitem><para>If any spacegroup data are stored, destroy it in preparation for
fresh data</para>
<itemizedlist>
<listitem><para>The spacegroup data are entered using the
<literal>spacegroup_symbol=</literal>, <literal>spacegroup_it_symbol=</literal>
or <literal>spacegroup_hall_symbol=</literal>.</para></listitem>
<listitem><para>This is synonymous with
<literal>erase_spacegroup</literal></para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>erase_reflection_data</literal></term>
<listitem><para>If any reflection data are stored, destroy it in preparation for
fresh data</para>
<itemizedlist>
<listitem><para>The reflection data are entered using the
<literal>reflection_data=</literal> keyword</para></listitem>
<listitem><para>This is synonymous with
<literal>destroy_reflection_data</literal></para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>erase_spacegroup</literal></term>
<listitem><para>If any spacegroup data are stored, destroy it in preparation for
fresh data.</para>
<itemizedlist>
<listitem><para>The spacegroup data are entered using the
<literal>spacegroup_symbol=</literal>, <literal>spacegroup_it_symbol=</literal>
or <literal>spacegroup_hall_symbol=</literal>.</para></listitem>
<listitem><para>This is synonymous with
<literal>destroy_spacegroup</literal></para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>exp_scale_factor</literal></term>
<listitem><para>Read in a scale factor which is used to multiply any
experimental structure factors or experimental sigma values.</para>
<itemizedlist>
<listitem><para>The scale factor is applied only once</para></listitem>
<listitem><para>Refer to the <literal>reflection_data=</literal>
keyword</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>kind= STR</literal></term>
<listitem><para>Read the kind of crystal data that is to be stored.</para>
<itemizedlist>
<listitem><para>The allowed kinds are <literal>x-ray</literal> or
<literal>pnd</literal></para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>make_f_predicted</literal></term>
<listitem><para>Make the predicted magnitudes of the structure factors,
including possibly an overall scale factor and extinction correction.</para>
<itemizedlist>
<listitem><para>Refer to the <literal>optimise_scale=</literal>
keyword</para></listitem>
<listitem><para>Refer to the <literal>optimise_extinction_factor=</literal>
keyword</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>optimise_extinction= BIN</literal></term>
<listitem><para>Equivalent to <literal>optimise_scale_factor=</literal></para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>optimise_extinction_factor= BIN</literal></term>
<listitem><para>Read a switch whether to use an extincton factor when
calculating the magnitudes of the predicted structure factors.</para>
<itemizedlist>
<listitem><para>Refer to the
<literal>make_f_predicted</literal></para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>optimize_extinction= BIN</literal></term>
<listitem><para>Equivalent to <literal>optimise_scale_factor=</literal></para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>optimize_extinction_factor= BIN</literal></term>
<listitem><para>Equivalent to <literal>optimise_scale_factor=</literal></para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>optimise_scale= BIN</literal></term>
<listitem><para>Equivalent to <literal>optimise_scale_factor=</literal>.</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>optimise_scale_factor= BIN</literal></term>
<listitem><para>Read a switch whether to optimise a scale factor when
calculating the magnitudes of the predicted structure factors.</para>
<itemizedlist>
<listitem><para>The X-ray structure factors are often not determined on an
absolute scale, so a scale factor may be used to minimise the
&chi;<superscript>2</superscript> agreement statistic between the experimental
and calculated structure factors</para></listitem>
<listitem><para>By convention it is the calculate structure factors which are
scaled, even though in reality it is the experimental structure factors which
should be</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>optimize_scale= BIN</literal></term>
<listitem><para>Equivalent to <literal>optimise_scale_factor=</literal>.</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>optimize_scale_factor= BIN</literal></term>
<listitem><para>Equivalent to <literal>optimise_scale_factor=</literal>.</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>partition_model= STR</literal></term>
<listitem><para>Read the <quote>partition model</quote> used to calculate
structure factors when using <quote>oversampled</quote> model of the crystal
unit cell.</para>
<itemizedlist>
<listitem><para>An oversampled cell is one which is greater than the asymmetric
unit; partition factord are introduced to obtain a correct repeating density for
the crystal</para></listitem>
<listitem><para>Allowed options are <literal>none</literal>,
<literal>mulliken</literal> or <literal>gaussian</literal></para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>reflection_data= REFLECTIONVEC</literal></term>
<listitem><para>Enter a list of reflection data.</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>spacegroup_hall_symbol= STR</literal></term>
<listitem><para>Enter the spacegroup in Hall notation.</para>
<itemizedlist>
<listitem><para>Refer to
<literal>spacegroup_it_symbol</literal></para></listitem>
<listitem><para>Refer to <literal>SPACEGROUP:set_Hall_conversion_table</literal>
so see the relationship between Hall symbols and international table
symbols</para></listitem>
<listitem><para>For details of notation and non standard axis and origin
settings, see: S. R. Hall, Acta Cryst. A37, 517 (1981)</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>spacegroup_it_symbol= STR</literal></term>
<listitem><para>Read the international table (IT) symbol for the
spacegroup.</para>
<itemizedlist>
<listitem><para>Use a caret <literal>^</literal> before a character to represent
a bar over that character; e.g <!-- $\bar&lcub;P&rcub;$ --> is
<literal>^P</literal></para></listitem>
<listitem><para>Use an underscore <literal>_</literal> after a character to represent a subscript; 
e.g.  2<subscript>ab</subscript> is <literal>2_ab</literal></para></listitem>
<listitem><para>Use a slash <literal>/</literal> where a slash should
go</para></listitem>
<listitem><para>Do not use spaces between symbols</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>spacegroup_symbol= STR</literal></term>
<listitem><para>Equivalent to <literal>spacegroup_it_sumbol=</literal>.</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>synthesize_sigma_i= BIN</literal></term>
<listitem><para>Read the switch whether to artificially
create<literal>&sigma;(I)</literal> errors, where<literal>I</literal> is an
intensity, when evaluating the<literal>&chi;^2</literal> agreement statistic
based on intensities.</para>
<itemizedlist>
<listitem><para>Refer to routine <literal>I_sigma</literal></para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>thermal_smearing_model= STR</literal></term>
<listitem><para>Read the thermal smearing model to use to correct for thermal
vibration in the calculated structure factors.</para>
<itemizedlist>
<listitem><para>Allowed models are <literal>none</literal>,
<literal>coppens</literal>, <literal>stewart</literal>,
<literal>tanaka</literal></para></listitem>
<listitem><para>For explanation, refer to: Grimwood and Jayatilaka, (2001),
Acta. Cryst., A57, 87-100.</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>unit_cell_angles= REALVEC(3)</literal></term>
<listitem><para>Read the unit cell angles in the order
<literal>&alpha;</literal>, <literal>&beta;</literal>,
<literal>&gamma;</literal>.</para>
<itemizedlist>
<listitem><para>Use the <literal>degrees</literal> unit modifier to change from
default of radians</para></listitem>
<listitem><para><literal>cell_angles=</literal> is synonymous</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>unit_cell_dimensions= REALVEC(3)</literal></term>
<listitem><para>Read the unit cell dimensions in the order <literal>a</literal>,
<literal>b</literal>, <literal>c</literal>.</para>
<itemizedlist>
<listitem><para>Use the <literal>angstrom</literal> unit modifier to change from
default of atomic units</para></listitem>
<listitem><para><literal>cell_lengths=</literal> and
<literal>unit_cell_lengths=</literal> are synonymous</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>unit_cell_lengths= REALVEC(3)</literal></term>
<listitem><para>Read the unit cell lengths in the order <literal>a</literal>,
<literal>b</literal>, <literal>c</literal>.</para>
<itemizedlist>
<listitem><para>Use the <literal>angstrom</literal> unit modifier to change from
default of atomic units</para></listitem>
<listitem><para><literal>cell_lengths=</literal> and
<literal>unit_cell_dimensions=</literal> are synonymous</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>wavelength= REAL</literal></term>
<listitem><para>Read the wavelength &lambda; used in the X-ray or netron
diffraction experiment.</para>
<itemizedlist>
<listitem><para>The value is used to calculated
<literal>sin(&thetas;)/&lambda;</literal> values for each reflection, often
quoted in diffraction experiments</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

</sect2>
</sect1>

<!-- *********************************************************************** -->

<sect1 id="DFTGRID">
<title><literal>DFTGRID</literal></title>

<sect2 id="DFTGRID-purpose">
<title>Purpose</title>

<para>An object for making integration grids used for DFT calculations.</para>
</sect2>

<sect2 id="DFTGRID-synopsis">
<title>Synopsis</title>

<para>This routine makes a 3-D atomic integration grid which is a tensor product
of a radial grid and a spherical grid.</para>

<para>An integration grid for a molecule can also be made, using a weighted
sum of these atomic grids.</para>

<para>In getting a complete molecular grid, an atomic grid at the origin is made
using the <literal>make_atom_grid</literal> routine. For each atom in the
molecule, this grid at the origin is copied, re-scaled depending on the
Bragg-Slater radii, and then displaced so that its origin is now centred on the
atom.  </para>

<para>Each re-scaled, displaced grid is then <quote>partitioned</quote>. The
partitioning modifies the weights of the displaced grid so that effectively it
doesn't overlap with the displaced grids on all the other atoms.</para>

<para>The displace and partition of the original <quote>atom</quote> grid is
done by the routine <literal>rescale_displace_partition</literal>.</para>

<bibliography><title>References</title>

  <biblioentry>
    <author><firstname>A.</firstname><othername>D.</othername><surname>Becke</surname></author>
    <title>J. Chem. Phys.</title>
    <volumenum>88</volumenum>
    <pubdate>1988</pubdate>
    <pagenums>2547</pagenums>
  </biblioentry>
  <biblioentry>
    <authorgroup>
      <author><firstname>O.</firstname><surname>Treutler</surname></author>
      <author><firstname>R.</firstname><surname>Ahlrichs</surname></author>
    </authorgroup>
    <title>J. Chem. Phys.</title>
    <volumenum>102</volumenum>
    <pubdate>1995</pubdate>
    <pagenums>346</pagenums>
  </biblioentry>
</bibliography>
</sect2>

<sect2 id="DFTGRID-input">
<title>Default input data order</title>

<para>There is no associated DFTGRIDVEC type; an input data order has not been
defined.</para>
</sect2>

<sect2 id="DFTGRID-keywords">
<title>Listing of keywords</title>

<variablelist>
<varlistentry>
<term><literal>becke_m_partition_power= REAL</literal></term>
<listitem><para>Read an integer used in smoothing the partition between atomic
grids.</para>
<itemizedlist>
<listitem><para>Must be greater than zero</para></listitem>
<listitem><para>Default value is 2</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>euler_maclaurin_alpha= REAL</literal></term>
<listitem><para>Read the the <literal>&alpha;</literal> parameter used to define
the Euler-Maclaurin radial grid.</para>
<itemizedlist>
<listitem><para>Must be greater than zero</para></listitem>
<listitem><para>Default value is 2</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>euler-maclaurin_alpha= REAL</literal></term>
<listitem><para>Equivalent to <literal>euler_maclaurin_alpha=</literal>.</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>euler_maclaurin_m= REAL</literal></term>
<listitem><para>Read the the <literal>&alpha;</literal> parameter used to define
the Euler-Maclaurin radial grid.</para>
<itemizedlist>
<listitem><para>Must be greater than zero</para></listitem>
<listitem><para>Default value is 2</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>euler-maclaurin_m= REAL</literal></term>
<listitem><para>Equivalent to <literal>euler_maclaurin_m=</literal>.</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>gauss_chebyshev_alpha= REAL</literal></term>
<listitem><para>Read the the <literal>&alpha;</literal> parameter used to define
the Gauss-Chebyshev radial grid.</para>
<itemizedlist>
<listitem><para>Must be greater than zero</para></listitem>
<listitem><para>Default value is 3</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>gauss-chebyshev_alpha= REAL</literal></term>
<listitem><para>Equivalent to <literal>gauss_chebyshev_alpha=</literal>.</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>gauss_chebyshev_m= REAL</literal></term>
<listitem><para>Read the the <literal>m</literal> parameter used to define
the Gauss-Chebyshev radial grid.</para>
<itemizedlist>
<listitem><para>Must be greater than zero</para></listitem>
<listitem><para>Default value is 1</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>gauss-chebyshev_m= REAL</literal></term>
<listitem><para>Equivalent to <literal>gauss_chebyshev_m=</literal>.</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>radial_grid_kind= STR</literal></term>
<listitem><para>Read the kind of radial grid to be used for the radial part of
the numerical quadrature grid.</para>
<itemizedlist>
<listitem><para>Allowed options are <literal>gauss-chebyshev</literal> or
<literal>euler_maclaurin</literal></para></listitem>
<listitem><para>Default is <literal>gauss-chebyshev</literal></para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>radial_grid_order= INT</literal></term>
<listitem><para>Read a the number of radial quadrature points to be used.</para>
<itemizedlist>
<listitem><para>Must be greater than zero</para></listitem>
<listitem><para>Default value is 60</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>spherical_grid_kind= STR</literal></term>
<listitem><para>Read the kind of spherical grid to be used for the angular part
of the numerical quadrature grid.</para>
<itemizedlist>
<listitem><para>Allowed optins: only <literal>lebedev</literal> so
far</para></listitem>
<listitem><para>Not surprisingly, the default value is
<literal>lebedev</literal></para></listitem>
<listitem><para>To input the kind of radial integration grid see
<literal>radial_grid_kind=</literal></para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>spherical_grid_order= INT</literal></term>
<listitem><para>Read an integer which determines the <quote>order</quote> or
accuracy of the angular quandrature grid..</para>
<itemizedlist>
<listitem><para>Allowed <literal>lebedev</literal> values are
<literal>23</literal>, <literal>25</literal>, <literal>27</literal>,
<literal>29</literal>, <literal>35</literal>, <literal>41</literal>,
<literal>47</literal>, <literal>53</literal>,
<literal>59</literal></para></listitem>
<listitem><para>Default <literal>lebedev</literal> value is
<literal>35</literal></para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>put</literal></term>
<listitem><para>Print out information about the DFT integration grid to
<literal>stdout</literal> in human readable form.</para>
</listitem>
</varlistentry>
</variablelist>

</sect2>
</sect1>

<!-- *********************************************************************** -->

<sect1 id="GAUSSIAN">
<title><literal>GAUSSIAN</literal></title>

<sect2 id="GAUSSIAN-purpose">
<title>Purpose</title>

<para>For describing a single gaussian function at any position in space, and
with a given angular momentum <literal>l</literal>.</para>
</sect2>

<sect2 id="GAUSSIAN-synopsis">
<title>Synopsis</title>

<para>The gaussian module is used mainly to help in defining gaussian pair data
(see the <literal>GAUSSIAN2</literal> module) or gaussian quartet data (see the
<literal>GAUSSIAN4</literal>  module).  These are used for one-electron and two
electron integrals.</para>
</sect2>

<sect2 id="GAUSSIAN-input">
<title>Default input data order</title>

<para>There is no associated GAUSSIANVEC type; an input data order has not been
defined.</para>
</sect2>

<sect2 id="GAUSSIAN-keywords">
<title>Listing of keywords</title>

<variablelist>
<varlistentry>
<term><literal>ex= REAL</literal></term>
<listitem><para>Read the exponent of the gaussian.</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>l= INT|STR</literal></term>
<listitem><para>Read either an integer representing the <literal>l</literal>
value of the gaussian; or read a single character representing the angular
momentum.</para>
<itemizedlist>
<listitem><para>If the inputted data in an integer, it must be
non-negative</para></listitem>
<listitem><para>If the inputted data in a character is must be
<literal>s</literal>, <literal>p</literal>, <literal>d</literal>,
<literal>f</literal>, <literal>g</literal>, <literal>...</literal>,
<literal>z</literal></para></listitem>
<listitem><para>See also <literal>l_chr=</literal> and
<literal>l_int=</literal></para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>l_chr= STR</literal></term>
<listitem><para>Read a single character representing the angular momentum of the
gaussian.</para>
<itemizedlist>
<listitem><para>Must be <literal>s</literal>, <literal>p</literal>,
<literal>d</literal>, <literal>f</literal>, <literal>g</literal>,
<literal>...</literal>, <literal>z</literal></para></listitem>
<listitem><para>See also <literal>l=</literal> and
<literal>l_int=</literal></para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>l_int= INT</literal></term>
<listitem><para>Read a single integer which is the angular momentum of the
gaussian.</para>
<itemizedlist>
<listitem><para>Inputted data must be non-negative</para></listitem>
<listitem><para>See also <literal>l=</literal> and
<literal>l_chr=</literal></para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>pos= REALVEC(3)</literal></term>
<listitem><para>Read the position of the gaussian.</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>units= STR</literal></term>
<listitem><para>Read a string which describes the units of the next inputted
numerical entity; that is, the next real or complex number, real or complex
vector, or real or complex matrix.</para>
<itemizedlist>
<listitem><para>The default atomic units are restored after the numerical entity
has been inputted</para></listitem>
<listitem><para>Warning: if the next inputted datum is not a numerical entity,
the new units keyword remains in force</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

</sect2>
</sect1>

<!-- *********************************************************************** -->

<sect1 id="MOL">
<title><literal>MOL</literal></title>

<sect2 id="MOL-purpose">
<title>Purpose</title>

<para>An object representation of a molecule</para>
</sect2>

<sect2 id="MOL-synopsis">
<title>Synopsis</title>

<para>This is the main module in &TONTO;. It is intenede to provide a quantum
mechanocal repr4esentation of a molecule and all properties that can be
interrogated from a molecule.</para>
</sect2>

<sect2 id="MOL-note">
<title>Special note</title>

<para>Because it is quite large, the module may be broken up into parts, each
part being labelled by a particular working author. Thus for example, the
current distribution contains <literal>mol_dylan</literal>,
<literal>mol_daniel</literal>, <literal>mol_chris</literal>.</para>

<para>The main routine is <literal>mol_main</literal> and contains essentially
just the <literal>read</literal> and <literal>process_input</literal>
routines.</para>

<para>The online documentation may not work properly for routines which are
under individual author names. Probably you should not be using these routines
for production purposes.</para>
</sect2>

<sect2 id="MOL-input">
<title>Default input data order</title>

<para>There is no associated MOLVEC type; an input data order has not been
defined.</para>
</sect2>

<sect2 id="MOL-keywords">
<title>Listing of keywords</title>

<variablelist>
<varlistentry>
<term><literal>assign_natural_orbitals</literal></term>
<listitem><para>Assign the natural orbitals to the currently defined molecular
orbitals.</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>atomic_roby_populations</literal></term>
<listitem><para>Evaluate the atomic Roby populations.</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>atoms= ATOMVEC</literal></term>
<listitem><para>Enter data for a list of <literal>ATOM</literal>'s. That is,
concerning the number, type, and position of atoms in the molecule.</para>
<para>Example: 
<programlisting>
atoms= &lcub;
    O1   0.0  0.0  0.0   o-sto3g
    H2   1.0  0.0  0.0   h-sto3g
    H    0.0  1.0  0.0   h-sto3g
&rcub;
</programlisting></para>
<itemizedlist>
<listitem><para>It is efficient to only specify a
<literal>basis_label</literal>. Later, the entire basis set can be specified
using the <literal>basis_sets</literal> command.</para></listitem>
<listitem><para>The <literal>basis_sets</literal> keyword may be used before or
after the <literal>atoms</literal> keyword.</para></listitem>
<listitem><para>Before a QM calculation can begin, every
<literal>basis_label</literal> must correspond to a defined basis
set.</para></listitem>
<listitem><para>Use <literal>"units angstrom"</literal> to specify coordinates
in angstrom units.</para></listitem>
<listitem><para>Use the <literal>axis_system</literal> command to specify
coordinates in crystal axis system</para></listitem>
<listitem><para>The default units for <literal>thermal_tensors</literal> is
<literal><!-- &Abreve; &Amacr; &Aogon; -->angstrom
<superscript>-2</superscript></literal>.</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>atoms_groups= GROUP</literal></term>
<listitem><para>Specify a partition of the numbers from 1 to the number of atoms
in the molecule.</para>
<itemizedlist>
<listitem><para>The <literal>GROUP</literal> module does not exist yet, so this
keyword is not documented in the standard way yet</para></listitem>
<listitem><para>This is used for nonintegacting-group Hartree-Fock
calculations</para></listitem>
<listitem><para>Within curly brackets <literal>&lcub;</literal> and
<literal>&rcub;</literal> use the keywords <literal>atom_group=</literal>
followed by an <literal>INTVEC</literal> list of atom indices; use
<literal>atom_range=</literal> or <literal>range=</literal> followed by an
<literal>INTVEC(2)</literal> indicating the range of atom indices, inclusive; use
<literal>group_charges=</literal> array to enter an <literal>INTVEC</literal>
describing the charge of each group.</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>b_field= REALVEC(3)</literal></term>
<listitem><para>Enter the cartesian components of an externally applied static
magnetic field <emphasis><literal>B</literal></emphasis>.</para>
<itemizedlist>
<listitem><para>The default value is
<literal>(0,0,0)</literal></para></listitem>
<listitem><para>It is assumed that <emphasis><literal>B</literal></emphasis> is
in atomic units of flux.</para></listitem>
<listitem><para>This keyword is used for plots of the diamagnetic part 
of the current density.</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>basis_set_directory= STR</literal></term>
<listitem><para>Enter a directory where basis sets for each atom may be
found.</para>
<itemizedlist>
<listitem><para>This keyword must come before any <literal>atoms=</literal>
keyword if basis sets are to be entered for those atoms</para></listitem>
<listitem><para>You must also specify a
<literal>basis_set_kind=</literal></para></listitem>
<listitem><para>The default value is
<literal>"./basis_sets"</literal></para></listitem>
<listitem><para>Not all basis sets are available. See the
<literal>basis_sets</literal> directory and the contents of each file there for
the list of available basis sets</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>basis_set_kind= STR</literal></term>
<listitem><para>Enter a the kind of basis set to be used.</para>
<itemizedlist>
<listitem><para>This must correspond to an existing basis set file in the basis
set directory</para></listitem>
<listitem><para>See <literal>basis_set_directory=</literal></para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>basis_sets= BASISVEC</literal></term>
<listitem><para>Enter data for a list of basis sets for use in quantum chemical
calculations.</para>
<para>Example: 
<programlisting>
basis_sets= &lcub;
&lcub;
    h-sto3g 
    &lcub;
      S   3
        3.42525091         0.15432897
        0.62391373         0.53532814
        0.16885540         0.44463454
    &rcub;

    o-sto3g
    &lcub;
      S   3
      130.70932000         0.15432897
       23.80886100         0.53532814
        6.44360830         0.44463454
      S   3
        5.03315130        -0.09996723    
        1.16959610         0.39951283  
        0.38038900         0.70011547 
      P   3
        5.03315130         0.15591627
        1.16959610         0.60768372
        0.38038900         0.39195739
    &rcub;
&rcub;
</programlisting></para>
<itemizedlist>
<listitem><para>The <literal>basis_label</literal> need not correspond to any
that are actually used in the <literal>atoms</literal>
keyword.</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>canonicalize_mos</literal></term>
<listitem><para>Generate a fock matrix from the existing molecule orbitals in
memory and diagonalise it over the occupied part only, and the virtual part
only, producing "canonical" molecular orbitals.</para>
<itemizedlist>
<listitem><para>The orbitals need not be converged for the existing kind of
SCF</para></listitem>
<listitem><para>See <literal>scfdata=</literal> and especially the
<literal>scf_kind=</literal> within this derived data keyword</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>charge= INT</literal></term>
<listitem><para>Enter the <literal>charge</literal> on the molecule in atomic
units of charge.</para>
<itemizedlist>
<listitem><para>The charge on the molecule is used to work out the total number
of electrons, and with the spin multiplicity, the number of alpha and beta
electrons.</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>create_cluster</literal></term>
<listitem><para>Create a cluster from the existing set of molecule
information.</para>
<itemizedlist>
<listitem><para>This keyword is not documented in the standard
way</para></listitem>
<listitem><para>Refer to the online documentation</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>crystal= CRYSTAL</literal></term>
<listitem><para>Enter the data for specifying a crystal, including the
experimental data for measured structure factors</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>delete_scf_integrals</literal></term>
<listitem><para>Delete the integrals files for the previous SCF
calculation.</para>
<itemizedlist>
<listitem><para>This must be done whenever a new geometry is
specified.</para></listitem>
<listitem><para>This command has an effect for direct calculations, because the
one electron integrals are always stored on disk.</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>dftgrid= DFTGRID</literal></term>
<listitem><para>Enter the data for specifying an integration grid for DFT
functions.</para>
</listitem>
</varlistentry>
</variablelist>


<variablelist>
<varlistentry>
<term><literal>e_field= REALVEC(3)</literal></term>
<listitem><para>Enter the cartesian components of an externally applied static
electric field <emphasis>E</emphasis>.</para>
<itemizedlist>
<listitem><para>The default value is
<emphasis>(0,0,0)</emphasis></para></listitem>
<listitem><para>It is assumed that <emphasis>E</emphasis> is in atomic units of
flux.</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>factor_density</literal></term>
<listitem><para>Multiply certain atom basis set sized blocks of the density
matrix by the specified factors</para>
<itemizedlist>
<listitem><para>This keyword is not documented in the standard
way</para></listitem>
<listitem><para>Refer to the online documentation</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>fit_thermal_parameters</literal></term>
<listitem><para>Optimise the thermal parameters so as to minimise the
&chi;<superscript>2</superscript> for the predicted vs. the experimental
structure factors</para>
<itemizedlist>
<listitem><para>Crystal data must be entered, and there must be an existing density matrix</para></listitem>
<listitem><para>Refer to <literal>crystal=</literal></para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>force_thermal_symmetry</literal></term>
<listitem><para>Force the thermal parameters on symmetry equivalent atoms to be
equal.  This is performed by averaging.</para>
<itemizedlist>
<listitem><para>This keyword is undocumented</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>gauge_origin= REALVEC(3)</literal></term>
<listitem><para>Enter the gauge origin for an externally applied static magnetic
field.</para>
<itemizedlist>
<listitem><para>The default value is
<emphasis>(0,0,0)</emphasis></para></listitem>
<listitem><para>This keyword will affect spin orbit and magnetic field
calculations</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>get_atom_density</literal></term>
<listitem><para>Read the stored sum of spherically averaged atom densities from
the archive stored on disk into the current density matrix.</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>get_homoleptic_bond_index</literal></term>
<listitem><para>Calculate the homoleptic bond index between two Roby
fragments</para>
<itemizedlist>
<listitem><para>This keyword remains undocumented</para></listitem>
<listitem><para>Refer to the online documentation</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>hf_scf_energy_gradient</literal></term>
<listitem>
<itemizedlist>
<listitem><para>Calculate the Hartree-Fock energy gradient</para></listitem>
<listitem><para>Warning: this keyword is untested</para></listitem>
<listitem><para>Can you debug it?</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>grid= PLOTGRID</literal></term>
<listitem><para>Enter the data for specifying a rectilinear grid, for
plots</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>make_ao_density_matrix</literal></term>
<listitem><para>Make the density matrix in the AO basis set from the current
density matrix. (If the current density matrix of of the restricted kind, no
operation is performed).</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>make_ao_sz_density_matrix</literal></term>
<listitem><para>Make the matrix of the S<subscript>z</subscript> operator in the
AO basis set from the current density matrix. This is used to generate densities
for use in calculating spin-only magnetic structure factors from UHF
calculations.</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>make_atom_density</literal></term>
<listitem><para>Calculate the density matrix as a sum of spherically averaged
atomic UHF densities.</para>
<itemizedlist>
<listitem><para>The maximum multiplicity Hund's rule is assumed for the spin
state of the atom.</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>make_fermi_mobility_grid</literal></term>
<listitem><para>Make and print out the Fermi mobility function on the specified
vibrationally rectilinear plot grid.</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>make_fock_guess</literal></term>
<listitem><para>Make an initial set of molecular orbitals and eigenvalues from
the current fock matrix.</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>make_fock_matrix</literal></term>
<listitem><para>Make the fock matrix from a density matrix already in
memory.</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>make_group_density_matrix</literal></term>
<listitem><para>Make a density matrix which is the sum of non-interacting group
densities</para>
<itemizedlist>
<listitem><para>Refer to the <literal>atom_groups=</literal> keyword to define
the groups</para></listitem>
<listitem><para>Only works for closed shell <literal>rhf</literal> group
fragments at the moment</para></listitem>
<listitem><para>Can you fix the rest?</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>make_irrotational_jp_grid</literal></term>
<listitem><para>Make and print out the irrotational part of the paramagnetic
current density on the specified rectilinear grid.</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>make_mulliken_matrix</literal></term>
<listitem><para>Make and print out the Mulliken population matrix.</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>make_natural_orbitals</literal></term>
<listitem><para>Make the natural orbitals for the currently defined molecular
orbitals.</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>make_pnd_scalar_magnetic_sf</literal></term>
<listitem><para>Make the polarised neutron diffraction (pnd) scalar magnetic 
structure factors for the currently defined complex density matrix.</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>make_promol_density_matrix</literal></term>
<listitem><para>Make a promolecule density matrix from symmetrically
orthonormalised group molecular orbitals</para>
<itemizedlist>
<listitem><para>The promolecule orbitals are also made, and are ordered by
group, including the virtual orbitals within each group i.e. the occupation
number vector is not continguous</para></listitem>
<listitem><para>Refer to <literal>atom_groups=</literal> and
<literal>make_promol_density</literal></para></listitem>
<listitem><para>Only works for <literal>rhf</literal> fragment groups at the
moment</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>make_roby_atoms</literal></term>
<listitem><para>Define the atomic natural orbitals for every atomn in the
molecule</para>
<itemizedlist>
<listitem><para>These are used to define the Roby aton projectors from Roby
population analysis</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>


<variablelist>
<varlistentry>
<term><literal>make_scf_density_matrix</literal></term>
<listitem><para>Make a density matrix from the current set of molecular
orbitals, for the currently defined type of SCF calculation (set in
<literal>scfdata</literal>).</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>make_structure_factors</literal></term>
<listitem><para>Make the structure factors for the currently defined density
matrix.</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>make_sz_structure_factors</literal></term>
<listitem><para>Make the S<subscript>z</subscript> spin only magnetic structure
factors for the currently defined density matrix.</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>make_vib_averaged_rho_grid</literal></term>
<listitem><para>Make and print out the vubrationally averaged charge density for
a diatomic molecule using adpative Simpson quadrature.</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>make_weak_force_energy_shift</literal></term>
<listitem><para>Calculate the parity violating weak force energy shift from a
complex spin-orbit SCF calculation.</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>multiplicity= INT</literal></term>
<listitem><para>Enter the spin <emphasis>multiplicity</emphasis> value for the
molecule, <literal>2S+1</literal>, where <literal>S</literal> is the spin of the
molecule.</para>
<itemizedlist>
<listitem><para>The multiplicity values is used to define the number of alpha
and beta electrons in unrestricted Hartree-Fock (UHF)
calculations.</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>name= STR</literal></term>
<listitem><para>Input the <emphasis>name</emphasis> you wish to give to your
molecule calculation.</para>
<itemizedlist>
<listitem><para>The <literal>name=</literal> keyword must be the first one in
any input file.</para></listitem>
<listitem><para>The value of the inputted string is used to define the start of
archive file names, so <emphasis>do not</emphasis> use any spaces in
it.</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>optimise_thermal_parameters= BIN</literal></term>
<listitem><para>If set <literal>TRUE</literal>, the thermal parameters in an
X-ray wavefunction fitting calculations are optimised to minimise the
&chi;<superscript>2</superscript> agreement statistic.</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>plot_covalent_orbitals INT</literal></term>
<listitem><para>Output the Roby covalent orbital density for the specified
orbital index.</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>plot_ionic_orbitals INT</literal></term>
<listitem><para>Output the Roby ionic orbital density for the specified orbital
index.</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>plot_subspace_density INT</literal></term>
<listitem><para>Output the Roby subspace density for the specified shared
orbitals whose index is specified.</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>pointgroup= CRYSTAL</literal></term>
<listitem><para>Specify th pointgroup symmetry of the molecule in Schoenflies
notation.</para>
<itemizedlist>
<listitem><para>The character table does not include complex irreps, but they
are grouped into two dimensional modules.</para></listitem>
<listitem><para>The character table is not available for the Icosahedral groups.
used in the <literal>atoms</literal> keyword.</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>put</literal></term>
<listitem><para>Put out information concerning the current molecule to the
<literal>stdout TEXTFILE</literal>.</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>put_cluster_operations REAL</literal></term>
<listitem><para>Put the crystal Seitz operations which will generate a cluster
for which no atom is more than a certain specified distance from the center of
the molecule out to the  <literal>stdout TEXTFILE</literal>.</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>put_crystal</literal></term>
<listitem><para>Put out <literal>CRYSTAL</literal> information for the current
molecule to the <literal>stdout TEXTFILE</literal>.</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>put_all_atom_coord_info</literal></term>
<listitem><para>Put out all the atom coordinate information.</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>put_ao_energy_partition</literal></term>
<listitem><para>Put out the AO energy partition, which is a kind of Morokuma
analysis</para>
<itemizedlist>
<listitem><para>This is only available for two <literal>rhf</literal> fragment
groups at the moment</para></listitem>
<listitem><para>The density matrix for each group is partitioned according to AO
basis functions, and then the energy of each block os calculated separately,
including the <quote>interaction energy</quote>
<literal>E<subscript>AB</subscript> = E
- E<subscript>AA</subscript> -
  E<subscript>BB</subscript></literal></para></listitem>
<listitem><para>Refer to <literal>put_sao_energy_partition</literal> and
<literal>put_mo_energy_partition</literal></para></listitem>
<listitem><para>Refer to <literal>atom_groups=</literal>
command</para></listitem>
<listitem><para>Refer to <literal>make_promol_density_matrix</literal> and
<literal>make_group_density_matrix</literal> command</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>put_chi2_vs_angle_plot</literal></term>
<listitem><para>Make a <literal>gnuplot</literal> table of the
<literal>&chi;<superscript>2</superscript></literal> agreement statistic between
calculated and experimental structure factors, and the binned <literal>sin
&thetas;/&lambda;</literal> values, where &lambda; is the diffraction particle
wavelength</para>
<itemizedlist>
<listitem><para>This may be moved to the <literal>CRYSTAL</literal> module at a
later date</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>put_cluster_input</literal></term>
<listitem><para>Write out the cluster input details for a supercluster of the
existing molecule</para>
<itemizedlist>
<listitem><para>This keyword remains undcoumented</para></listitem>
<listitem><para>Refer to the online documentation</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>put_crystal</literal></term>
<listitem><para>Put out all crystal information for this molecule</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>put_crystal_reflection_data</literal></term>
<listitem><para>Put out only crystal reflection information for this
molecule</para>
<itemizedlist>
<listitem><para>This may be moved to the <literal>CRYSTAL</literal> module at a
later data</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>put_current_time</literal></term>
<listitem><para>Put the current time out to the  <literal>stdout
TEXTFILE</literal>.</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>put_density_matrix</literal></term>
<listitem><para>Put out the density matrix to the
<literal>stdout</literal>.</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>put_fock_matrix</literal></term>
<listitem><para>Put out the fock matrix to the <literal>stdout</literal>.</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>put_f_calc</literal></term>
<listitem><para>Put the calculated structure factors out to the
<literal>stdout</literal>.</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>put_f_calc_plots</literal></term>
<listitem><para>Put out a series of useful <literal>gnuplot</literal> files
detailing the behaviour of the calculated structure factors</para>
<itemizedlist>
<listitem><para>It produces the normalised deviates vs.
<literal>sin&thetas;/&lambda;</literal>; the normalised deviates vs.
experimental structre factor magnitude; the normalised deviates vs. experimental
structre factor magnitude; both of the above plots when the calculated structure
factors include an extinction correction; and the mean value of the normalised
deviate with and without extinction</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>put_fock_matrix</literal></term>
<listitem><para>Put out the fock matrix to the <literal>stdout</literal>.</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>put_g_tensor_information</literal></term>
<listitem><para>Calculate and put out the g tensor information from an existing
complex density matrix.</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>put_labelled_qq_plot</literal></term>
<listitem><para>Write an archive of the <literal>QQ</literal> plot for the
calculated structure factors data, including the <literal>h</literal>,
<literal>k</literal>, <literal>l</literal> reflection data</para>
<itemizedlist>
<listitem><para>This is a plot of the sorted experimental quantile versus the
expected gaussian quantile</para></listitem>
<listitem><para>Refer to <literal>put_qq_plot</literal></para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>put_mos_and_energies</literal></term>
<listitem><para>Put out the molecular orbitals and orbitals energies to the
<literal>stdout</literal>.</para>
</listitem>
</varlistentry>
</variablelist>


<variablelist>
<varlistentry>
<term><literal>put_molecular_orbitals</literal></term>
<listitem><para>Put out the molecular orbitals information to the
<literal>stdout</literal>.</para>
</listitem>
</varlistentry>
</variablelist>


<variablelist>
<varlistentry>
<term><literal>put_mo_energy_partition</literal></term>
<listitem><para>Put out the MO energy partition, which is a kind of Morokuma
analysis</para>
<itemizedlist>
<listitem><para>This is only available for two <literal>rhf</literal> fragment
groups at the moment</para></listitem>
<listitem><para>The density matrix for each group is partitioned according to MO
basis functions, and then the energy of each block os calculated separately,
including the <quote>interaction energy</quote>
<literal>E<subscript>AB</subscript> = E - E<subscript>AA</subscript> -
E<subscript>BB</subscript></literal></para></listitem>
<listitem><para>Refer to <literal>put_ao_energy_partition</literal> and
<literal>put_sao_energy_partition</literal></para></listitem>
<listitem><para>Refer to <literal>atom_groups=</literal>
command</para></listitem>
<listitem><para>Refer to <literal>make_promol_density_matrix</literal> and
<literal>make_group_density_matrix</literal> command</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>put_sao_energy_partition</literal></term>
<listitem><para>Put out the symmetrix AO energy partition, which is a kind of
Morokuma analysis</para>
<itemizedlist>
<listitem><para>This is only available for two <literal>rhf</literal> fragment
groups at the moment</para></listitem>
<listitem><para>The density matrix for each group is partitioned according to MO
basis functions, and then the energy of each block os calculated separately,
including the <quote>interaction energy</quote>
<literal>E<subscript>AB</subscript> = E - E<subscript>AA</subscript> -
E<subscript>BB</subscript></literal></para></listitem>
<listitem><para>Refer to <literal>put_ao_energy_partition</literal> and
<literal>put_mo_energy_partition</literal></para></listitem>
<listitem><para>Refer to <literal>atom_groups=</literal>
command</para></listitem>
<listitem><para>Refer to <literal>make_promol_density_matrix</literal> and
<literal>make_group_density_matrix</literal> command</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>put_scf_energy</literal></term>
<listitem><para>Evaluate and put out the SCF energy</para>
<itemizedlist>
<listitem><para>The kinetic energy is also outputted for
information</para></listitem>
<listitem><para>Refer to <literal>scfdata=</literal> to set scf
type</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>put_scf_energy_in_mo_pairs</literal></term>
<listitem><para>Evaluate and put out the SCF energy in an MO pairs like
form</para>
<itemizedlist>
<listitem><para>This decomposes the total SCF energy into one orbital in two
orbital contributions in the expected way</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>put_plotgrid</literal></term>
<listitem><para>Put out the plotgrid information</para>
<itemizedlist>
<listitem><para>Refer to <literal>plotgrid=</literal> to set the plot
information and plot type</para></listitem>
<listitem><para>Refer to <literal>plot</literal> to actually perform the plot
calculation</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>put_pnd_sf</literal></term>
<listitem><para>Put out the polarised neutron diffraction (PND) structure factor
information to the <literal>stdout</literal>.</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>put_pointgroup</literal></term>
<listitem><para>Put out <literal>POINTGROUP</literal> information for the
current molecule to the <literal>stdout</literal>.</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>put_qq_plot</literal></term>
<listitem><para>Put the data for Hamilton's $QQ$ plot out to the
<literal>stdout</literal>.</para>
<itemizedlist>
<listitem><para>This is a plot of the sorted experimental quantile versus the
expected gaussian quantile</para></listitem>
<listitem><para>Refer to
<literal>put_labelled_qq_plot</literal></para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>put_roby_atom_energy</literal></term>
<listitem><para>Put out the Roby energies for every atom</para>
<itemizedlist>
<listitem><para>This keyword is undocumented</para></listitem>
<listitem><para>Refer to the online documentation</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>put_roby_ionic_energy</literal></term>
<listitem><para>Put out the Roby ionic energies for every atom</para>
<itemizedlist>
<listitem><para>This keyword is undocumented</para></listitem>
<listitem><para>Refer to the online documentation</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>put_roby_shared_energy</literal></term>
<listitem><para>Output the Roby shared energy.</para>
<itemizedlist>
<listitem><para>This keyword is undocumented</para></listitem>
<listitem><para>Refer to the online documentation</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>put_roby_shared_population</literal></term>
<listitem><para>Output the Roby shared populations.</para>
<itemizedlist>
<listitem><para>This keyword is undocumented</para></listitem>
<listitem><para>Refer to the online documentation</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>put_sylvian_csizmadia_tensors</literal></term>
<listitem><para>Output an approxintmation for the polarisability and
hyperpolarisability tensors developed by Sylvian and Csizmadia.</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>put_scf_energy_in_mo_pairs</literal></term>
<listitem><para>Calculate and put out the SCF energy in molecular orbitals pairs
for the current set of molecular orbitals.</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>put_time_taken</literal></term>
<listitem><para>Put the time taken since the <literal>start_timer</literal>
command (or beginning of job, if the <literal>start_timer</literal> command is
not present) to the <literal>stdout</literal>.</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>put_total_time</literal></term>
<listitem><para>Put the total time since the <literal>start_timer</literal>
command (or the beginning of job, if the <literal>start_timer</literal> command
is not present) out to the  <literal>stdout</literal>.</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>put_vrml</literal></term>
<listitem><para>Put out a VRML graphics representation of the molecule</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>read_archive STR STR</literal></term>
<listitem><para>Read the specified binary archive, and its kind, into the
program.</para>
<itemizedlist>
<listitem><para>Only the possibilities <literal>molecular_orbitals</literal>,
<literal>density_matrix</literal>, <literal>natural_orbitals</literal>,
<literal>occupation_numbers</literal> and <literal>fock_matrix</literal> are
allowed.</para></listitem>
<listitem><para>The kind must be one of the <literal>OPMATRIX</literal> kind
types.</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>read_ascii_archive STR STR</literal></term>
<listitem><para>Read the specified ASCII archive into the program.</para>
<itemizedlist>
<listitem><para>Only the possibilities <literal>molecular_orbitals</literal>,
<literal>density_matrix</literal>, <literal>natural_orbitals</literal>,
<literal>occupation_numbers</literal> and <literal>fock_matrix</literal> are
allowed.</para></listitem>
<listitem><para>The kind must be one of the <literal>OPMATRIX</literal> kind
types.</para></listitem>
<listitem><para>This command is useful for inputting data from other programs:
simply rename the input into the appropriate archive file.</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>read_g94_checkpoint_file</literal></term>
<listitem><para>Read the gaussian94 checkpoint file, generated from the
<literal>fchk</literal> command, into &TONTO;.</para>
<itemizedlist>
<listitem><para>Atom positions, basis sets, molecular orbitals and density
matrices are inputted.</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>redirect STR</literal></term>
<listitem><para>Redirect the <literal>stdin</literal> to the name of the
following input file</para>
<itemizedlist>
<listitem><para>To come back to the original input file, use the
<literal>revert</literal> command</para></listitem>
<listitem><para>See the <literal>revert</literal> command</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>roby_energy_analysis</literal></term>
<listitem><para>Perform a Roby energy analysis on the previously calculated
density matrix.</para>
<itemizedlist>
<listitem><para>This keyword remains undocumented</para></listitem>
<listitem><para>Refer to the online documentation</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>roby_population_analysis</literal></term>
<listitem><para>Perform a Roby population analysis on the previously calculated
density matrix.</para>
<itemizedlist>
<listitem><para>This keyword remains undocumented</para></listitem>
<listitem><para>Refer to the online documentation</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>


<variablelist>
<varlistentry>
<term><literal>scf</literal></term>
<listitem><para>Perform an SCF calculation using the specified
<literal>scfdata</literal>.</para>
<itemizedlist>
<listitem><para>At the termination of the program the density matrix, molecular
orbitals, and fock matrix hold the converged results for future
calculations.</para></listitem>
<listitem><para>The results are also stored in archive files on disk for later
use.</para></listitem>
<listitem><para>If a standard SCF calculation is performed, the integrals are
stored ion disk and reused, if required.</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>scfdata= SCFDATA</literal></term>
<listitem><para>Enter the data for the SCF calculation options, including the
type of SCF, the initial guess, the convergence criteria, extrapolation
methods, to name a few.</para>
<itemizedlist>
<listitem><para>This does not perform a calculation. Only the required options
are set.  Use the <literal>scf</literal> keyword to invoke the SCF
calculation.</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>simulate_new_f_exp</literal></term>
<listitem><para>Add a series of &sigma;-variance gaussian random deviates to
the experimental crystal structure factors</para>
<itemizedlist>
<listitem><para>This may be moved to the <literal>CRYSTAL</literal> module at a
later date</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>start_timer</literal></term>
<listitem><para>Start timing the program from the current point.</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>write_archive STR</literal></term>
<listitem><para>Write the specified binary archive into the program.</para>
<itemizedlist>
<listitem><para>Only the possibilities <literal>molecular_orbitals</literal>,
<literal>density_matrix</literal>, <literal>natural_orbitals</literal>,
<literal>occupation_numbers</literal> and <literal>fock_matrix</literal> are
allowed.</para></listitem>
<listitem><para>The kind is determined from the current type of object which is
to be written.</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>write_ascii_archive STR</literal></term>
<listitem><para>Write the specified ASCII archive into the program.</para>
<itemizedlist>
<listitem><para>Only the possibilities <literal>molecular_orbitals</literal>,
<literal>density_matrix</literal>, <literal>natural_orbitals</literal>,
<literal>occupation_numbers</literal> and <literal>fock_matrix</literal> are
allowed.</para></listitem>
<listitem><para>The kind is determined from the current type of object which is
to be written.</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>write_wfn_file</literal></term>
<listitem><para>Write out a MORPHY98 <literal>.wfn</literal> input file.</para>
<itemizedlist>
<listitem><para>This is useful for performing a Bader analysis on the current
density matrix.</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

</sect2>
</sect1>

<!-- *********************************************************************** -->

<sect1 id="PLOTGRID">
<title><literal>PLOTGRID</literal></title>

<sect2 id="PLOTGRID-purpose">
<title>Purpose</title>

<para>An object representing an evenly spaced rectilinear grid used for making
plots</para>
</sect2>

<sect2 id="PLOTGRID-synopsis">
<title>Synopsis</title>

<para>The <literal>PLOTGRID</literal> is comprised mainly of three axis
directions.  The number of points along the <literal>x</literal>-axis of the
plot is given, while the number of points along remaining axes are derived so
that the points are evenly spaced.</para>

<para>Normally a plotgrid will be two dimensional, but three dimensional plots
can also be represented.</para>

<para>There are also datum stored representing the kind of plot the grid is for;
and if an orbital based plot is desired, the index of the orbital desired for
plotting.</para>

<para>It is also possible to define a <literal>PLOTGRID</literal> relative to
specific <literal>ATOM</literal> positions, or relative to a
<literal>CRYSTAL</literal> axis system.</para>

<para>A plotgrid should never be used until the <literal>update</literal>
routine has been called.  Modules which call <literal>PLOTGRID</literal> always
ensure that this is done.</para>
</sect2>

<sect2 id="PLOTGRID-input">
<title>Default input data order</title>

<para>There is no associated PLOTGRIDVEC type; an input data order has not been
defined.</para>
</sect2>

<sect2 id="PLOTGRID-keywords">
<title>Listing of keywords</title>

<variablelist>
<varlistentry>
<term><literal>centre= REALVEC(3)</literal></term>
<listitem><para>Read the center position of the plot</para>
<itemizedlist>
<listitem><para>The default is <literal>(0,0,0)</literal></para></listitem>
<listitem><para>See <literal>x_width=</literal>, <literal>y_width=</literal> or
<literal>z_width=</literal> to specify the plot widths</para></listitem>
<listitem><para>See <literal>x_points=</literal> to specify the number of points
desired on the <literal>x</literal> axis</para></listitem>
<listitem><para>The number of points on the remaining axes are evaluated from
their widths and the condition that the points are evenly
spaced.</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>centre_atom= INT</literal></term>
<listitem><para>Read the index of the center atom of the plot</para>
<itemizedlist>
<listitem><para>To fully define all the parameters of the plotgrid, the user
must supply <literal>ATOMVEC</literal> information</para></listitem>
<listitem><para>See the <literal>update</literal> routine</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>crystal_plane= REALVEC(3)</literal></term>
<listitem><para>Read the desired crystal plane for plotting</para>
<itemizedlist>
<listitem><para>This is equivalent to the <literal>z_axis=</literal> keyword
</para></listitem>
<listitem><para>It should only be used when the <literal>kind</literal> of the
is <literal>crystal</literal></para></listitem>
<listitem><para>Refer to the <literal>kind=</literal> keyword</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>kind= STR</literal></term>
<listitem><para>Read the kind of plot the grid represents</para>
<itemizedlist>
<listitem><para>The default is the blank string</para></listitem>
<listitem><para>The allowed kinds are:
<simplelist type="vert" columns=1>
<member><literal>electron_density</literal>,</member>
<member><literal>laplacian_density</literal>,</member>
<member><literal>orbital_density</literal>,</member>
<member><literal>orbital</literal>,</member>
<member><literal>difference_density</literal>,</member>
<member><literal>fermi_mobility</literal>,</member>
<member><literal>crystal_error_map</literal>,</member>
<member><literal>qq_plot</literal>,</member>
<member><literal>spin_density</literal>,</member>
<member><literal>current_density</literal>,</member>
<member><literal>j_density</literal>,</member>
<member><literal>jp_density</literal>,</member>
<member><literal>jd_density</literal>,</member>
<member><literal>elf</literal>,</member>
<member><literal>electric_potential</literal>,</member>
<member><literal>solenoidal_jp</literal></member>
</simplelist>
</para></listitem>
<listitem><para>The <literal>laplacian_density</literal> is a plot of
<literal>&nabla;<superscript>2</superscript> &rho;</literal></para></listitem>
<listitem><para>The <literal>difference density</literal> is a plot of
<literal>&rho;- &rho;<subscript>promol</subscript></literal> where
<literal>&rho;<subscript>promol</subscript></literal> is evaluated as a sum of
spherically averaged atomic UHF densities calculated in the same basis
set</para></listitem>
<listitem><para><literal>fermi_mobility</literal> is a plot of Luken's fermi
mobility function</para></listitem>
<listitem><para><literal>crystal_error_map</literal> is a plot of the inverse
fourier synthesis of the differences between the calculated and (phased)
observed structure factors of the electron density</para></listitem>
<listitem><para><literal>qq_plot</literal> is a plot of the ranked
sigma-normalised deviations of predicted and observed structure factor
magnitudes plotted against those expected from a normal distribution; also known
as an Abraham-Skeev plot</para></listitem>
<listitem><para><literal>current_density</literal> and
<literal>j_density</literal> are equivalent; a general complex density matrix
must exist</para></listitem>
<listitem><para><literal>jp_density</literal> is a plot of the paramagnetic
current density</para></listitem>
<listitem><para><literal>jd_density</literal> is a plot of the diamagnetic
current density</para></listitem>
<listitem><para><literal>elf</literal> is a plot of the electron localisation
function</para></listitem>
<listitem><para><literal>solenoidal_jp</literal> is a plot of the solenoidal
part of the paramagnetic current density</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>maximum_cell_distance= REAL</literal></term>
<listitem><para>Read the maximum cell distance for a crystal-section plot</para>
<itemizedlist>
<listitem><para>The default is 5</para></listitem>
<listitem><para>This is currently only used with
<literal>crystal_error_map</literal> plots.</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>max_cell_distance= REAL</literal></term>
<listitem><para>Equivalent to <literal>maximum_cell_distance=</literal></para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>normal= REALVEC(3)</literal></term>
<listitem><para>Equivalent to <literal>z_axis=</literal> or
<literal>crystal_plane=</literal></para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>orbital= INT</literal></term>
<listitem><para>Read in the integer of the orbital to be used in an orbital-type
plot</para>
<itemizedlist>
<listitem><para>Must be greater than 0</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>put</literal></term>
<listitem><para>Print out information about the <literal>PLOTGRID</literal> to
the <literal>stdout</literal> file in human readable form</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>type= STR</literal></term>
<listitem><para>Equivalent to <literal>kind=</literal></para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>units= STR</literal></term>
<listitem><para>Read a string which describes the units of the next inputted
numerical entity; that is, the next real or complex number, real or complex
vector, or real or complex matrix.</para>
<itemizedlist>
<listitem><para>The default atomic units are restored after the numerical entity
has been inputted</para></listitem>
<listitem><para>Warning: if the next inputted datum is not a numerical entity,
the new units keyword remains in force</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>x_axis= REALVEC(3)</literal></term>
<listitem><para>Read in the <literal>x</literal>-axis direction of the
plot</para>
<itemizedlist>
<listitem><para>The default is <literal>(1,0,0)</literal></para></listitem>
<listitem><para>Note: the default can have different interpretation in a
<literal>crystal</literal> axis system</para></listitem>
<listitem><para>Note: if <literal>z_axis=</literal> is defined, then the
<literal>x</literal> axis is orthogonalised to the entered <literal>z</literal>
axis of the plot.</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>x_axis_atoms= INTVEC(2)</literal></term>
<listitem><para>Read in the indices of two atoms which lie along the
<literal>x</literal>-axis</para>
<itemizedlist>
<listitem><para>To evaluate all data in the <literal>PLOTGRID</literal> some
<literal>ATOMVEC</literal> information must be supplied</para></listitem>
<listitem><para>Refer to the <literal>update</literal> routine</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>x_axis_offset= REAL</literal></term>
<listitem><para>Read a number with which to displace the
<literal>PLOTGRID</literal> along the <literal>x</literal>-axis</para>
<itemizedlist>
<listitem><para>The default is 0</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>x_points= INT</literal></term>
<listitem><para>Read in the number of points wanted along the
<literal>x</literal>-axis</para>
<itemizedlist>
<listitem><para>The default is 51</para></listitem>
<listitem><para>The number of points should be odd; if not, the plot grid will
increase the even number by one</para></listitem>
<listitem><para>The number of points on the remaining axes are evaluated from
their widths and the condition that the points are evenly
spaced.</para></listitem>
<listitem><para>See <literal>y_width=</literal> or <literal>z_width=</literal>
to specify the plot widths</para></listitem>
<listitem><para>The number of points on the <literal>y</literal> and
<literal>z</literal> axes is also made to be odd; thus the center of the plot
corresponds exactly to a grid point</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>x_width= REAL</literal></term>
<listitem><para>Specify the width of the plot along the <literal>x</literal>
axis</para>
<itemizedlist>
<listitem><para>The default is 2</para></listitem>
<listitem><para>The value is used to calculate the spacing of the points
along the <literal>x</literal> axis</para></listitem>
<listitem><para>The total number of points in the plot is evaluade from the
remaining widths of the plot, assuming even spacing</para></listitem>
<listitem><para>See <literal>y_width=</literal> and
<literal>z_width=</literal></para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>y_axis= REALVEC(3)</literal></term>
<listitem><para>Read the direction of the <literal>y</literal> axis of the
plot</para>
<itemizedlist>
<listitem><para>The default is <literal>(0,1,0)</literal></para></listitem>
<listitem><para>Note: the default can have different interpretation in a
<literal>crystal</literal> axis system</para></listitem>
<listitem><para>Note: if the <literal>y</literal> axis is not orthogonal to the
<literal>x</literal> axis, then it is orthogonalised to the <literal>x</literal>
axis</para></listitem>
<listitem><para>Note: if <literal>z_axis=</literal> is defined, then the
<literal>y</literal> axis is set to the cross product of the
<literal>z</literal> axis and the orthogonalised <literal>x</literal> axis of
the plot</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>y_axis_atoms= INTVEC(2)</literal></term>
<listitem><para>Read in the indices of two atoms which lie along the
<literal>y</literal>-axis</para>
<itemizedlist>
<listitem><para>To evaluate all data in the <literal>PLOTGRID</literal> some
<literal>ATOMVEC</literal> information must be supplied</para></listitem>
<listitem><para>Refer to the <literal>update</literal> routine</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>y_axis_offset= REAL</literal></term>
<listitem><para>Read a number with which to displace the
<literal>PLOTGRID</literal> along the <literal>y</literal>-axis</para>
<itemizedlist>
<listitem><para>The default is 0</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>y_width= REAL</literal></term>
<listitem><para>Specify the width of the plot along the <literal>y</literal>
axis</para>
<itemizedlist>
<listitem><para>The default is 2</para></listitem>
<listitem><para>The value is used to calculate the number of points along the
<literal>y</literal> axis, and the total number of points in the
grid</para></listitem>
<listitem><para>Refer to <literal>x_width=</literal> and
<literal>x_points=</literal></para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>z_axis= REALVEC(3)</literal></term>
<listitem><para>Read the direction of the <literal>z</literal> axis of the
plot</para>
<itemizedlist>
<listitem><para>The default is <literal>(0,0,1)</literal></para></listitem>
<listitem><para>Note: the default can have different interpretation in a
<literal>crystal</literal> axis system</para></listitem>
<listitem><para>If this keyword is used, the <literal>y</literal> axis is set to
the cross product of the <literal>z</literal> axis and the orthogonalised
<literal>x</literal> axis of the plot</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>z_axis_offset= REAL</literal></term>
<listitem><para>Read a number with which to displace the
<literal>PLOTGRID</literal> along the <literal>z</literal>-axis</para>
<itemizedlist>
<listitem><para>The default is 0</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>z_width= REAL</literal></term>
<listitem><para>Specify the width of the plot along the <literal>z</literal>
axis</para>
<itemizedlist>
<listitem><para>The default is 0</para></listitem>
<listitem><para>This is used to calculate the number of points along the
<literal>z</literal> axis, and the total number of points in the
grid</para></listitem>
<listitem><para>Refer to <literal>x_width=</literal> and
<literal>x_points=</literal></para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

</sect2>
</sect1>

<!-- *********************************************************************** -->

<sect1 id="POINTGROUP">
<title><literal>POINTGROUP</literal></title>

<sect2 id="POINTGROUP-purpose">
<title>Purpose</title>

<para>An object for deriving and manipulating point group objects</para>
</sect2>

<sect2 id="POINTGROUP-synopsis">
<title>Synopsis</title>

<para>The only input required is the Schonflies symbol.</para>

<para>The data generated are The 3x3 rotation matrices in a standard axis frame
(the highest symmetry axis is the <literal>z</literal>-axis), all the
irreducible representations, the character table, the irreducible representation
lables, the group multiplication table, and the list of inverse
operators.</para>

<para>The module works by explictly constructing smaller point groups. Larger
point groups are constriucted as direct products of the smaller ones.</para>
</sect2>

<sect2 id="POINTGROUP-input">
<title>Default input data order</title>

<para>There is no associated POINTGROUPVEC type; an input data order has not
been defined.</para>
</sect2>

<sect2 id="POINTGROUP-keywords">
<title>Listing of keywords</title>

<variablelist>
<varlistentry>
<term><literal>schoenflies_symbol= STR</literal></term>
<listitem><para>Read in the Schoenflies symbol for the pointgroup</para>

<itemizedlist>
<listitem><para>Allowed values of the symbol are:</para>

<para>
<simplelist type="Horiz" columns=3>
<member><literal>c1</literal></member> <member><literal>cs</literal></member>
<member><literal>ci</literal></member>

<member><literal>c2</literal></member> <member><literal>c3</literal></member>
<member><literal>c4</literal></member> <member><literal>c5</literal></member>
<member><literal>c6</literal></member> <member><literal>c7</literal></member>
<member><literal>c8</literal></member> <member><literal>c9</literal></member>
<member><literal>c10</literal></member>
<member><literal>c11</literal></member>
<member><literal>c12</literal></member>

<member><literal>s2</literal></member> <member><literal>s4</literal></member>
<member><literal>s6</literal></member> <member><literal>s8</literal></member>
<member><literal>s10</literal></member>
<member><literal>s12</literal></member>

<member><literal>c2h</literal></member>
<member><literal>c3h</literal></member>
<member><literal>c4h</literal></member>
<member><literal>c5h</literal></member>
<member><literal>c6h</literal></member>
<member><literal>c7h</literal></member>
<member><literal>c8h</literal></member>
<member><literal>c9h</literal></member>
<member><literal>c10h</literal></member>
<member><literal>c11h</literal></member>
<member><literal>c12h</literal></member>

<member><literal>c2v</literal></member>
<member><literal>c3v</literal></member>
<member><literal>c4v</literal></member>
<member><literal>c5v</literal></member>
<member><literal>c6v</literal></member>
<member><literal>c7v</literal></member>
<member><literal>c8v</literal></member>
<member><literal>c9v</literal></member>
<member><literal>c10v</literal></member>
<member><literal>c11v</literal></member>
<member><literal>c12v</literal></member>

<member><literal>d2</literal></member> <member><literal>d3</literal></member>
<member><literal>d4</literal></member> <member><literal>d5</literal></member>
<member><literal>d6</literal></member> <member><literal>d7</literal></member>
<member><literal>d8</literal></member> <member><literal>d9</literal></member>
<member><literal>d10</literal></member>
<member><literal>d11</literal></member>
<member><literal>d12</literal></member>

<member><literal>d2h</literal></member>
<member><literal>d3h</literal></member>
<member><literal>d4h</literal></member>
<member><literal>d5h</literal></member>
<member><literal>d6h</literal></member>
<member><literal>d7h</literal></member>
<member><literal>d8h</literal></member>
<member><literal>d9h</literal></member>
<member><literal>d10h</literal></member>
<member><literal>d11h</literal></member>
<member><literal>d12h</literal></member>

<member><literal>d2d</literal></member>
<member><literal>d3d</literal></member>
<member><literal>d4d</literal></member>
<member><literal>d5d</literal></member>
<member><literal>d6d</literal></member>
<member><literal>d7d</literal></member>
<member><literal>d8d</literal></member>
<member><literal>d9d</literal></member>
<member><literal>d10d</literal></member>
<member><literal>d11d</literal></member>
<member><literal>d12d</literal></member>

<member><literal>cinfv</literal></member>
<member><literal>dinfh</literal></member>
<member><literal>t</literal></member> <member><literal>th</literal></member>
<member><literal>td</literal></member> <member><literal>o</literal></member>
<member><literal>oh</literal></member> <member><literal>i</literal></member>
<member><literal>ih</literal></member>
</simplelist></para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>schonflies_symbol= STR</literal></term>
<listitem><para>Equivalent to <literal>schoenflies_symbol=</literal></para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>symbol= STR</literal></term>
<listitem><para>Equivalent to <literal>schoenflies_symbol=</literal></para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>put</literal></term>
<listitem><para>Print out information about the <literal>POINTGROUP</literal> to
the <literal>stdout</literal> file in human readable form</para>
</listitem>
</varlistentry>
</variablelist>

</sect2>
</sect1>

<!-- *********************************************************************** -->

<sect1 id="REFLECTION">
<title><literal>REFLECTION</literal></title>

<sect2 id="REFLECTION-purpose">
<title>Purpose</title>

<para>For representing general crystal diffraction reflection information</para>
</sect2>

<sect2 id="REFLECTION-synopsis">
<title>Synopsis</title>

<para>A reflection is comprised of the miller indices, the experimental
structure factors and associated <literal>&sigma;</literal> value, the
experimental intensity and associated <literal>&sigma;</literal> values, and
predicted structure factors and intensities.</para>
</sect2>

<sect2 id="REFLECTION-input">
<title>Default input data order</title>

<para><programlisting>
REFLECTION_INPUT_DATA_ORDER    [ indices= ]
</programlisting></para>
</sect2>

<sect2 id="REFLECTION-keywords">
<title>Listing of keywords</title>

<variablelist>
<varlistentry>
<term><literal>add_f_calc= CPX</literal></term>
<listitem><para>Read in a complex number which will be added to the stored
calculated structure factor</para>
<itemizedlist>
<listitem><para>Note that the calculated structure factor is a complex
entity</para></listitem>
<listitem><para>The predicted structure factor is a real entity, representing
the magnitude of the strcuture factor, include experimental
corrections</para></listitem>
<listitem><para>Refer to <literal>f_calc=</literal></para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>add_f_exp= REAL</literal></term>
<listitem><para>Read in a number which will be added to the stored experimental
structure factor</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>add_f_pred= REAL</literal></term>
<listitem><para>Read in a number which will be added to the stored experimental
structure factor</para>
<itemizedlist>
<listitem><para>The predicted structure factor is a real entity, representing
the magnitude of the structure factor, include experimental
corrections</para></listitem>
<listitem><para>Refer to <literal>f_pred=</literal></para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>add_f_sigma= REAL</literal></term>
<listitem><para>Read in a number which will be added to the stored
<literal>&sigma</literal> value for the experimental structure factor</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>add_i_exp= REAL</literal></term>
<listitem><para>Read in a number which will be added to the stored experimental
intensity</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>add_i_pred= REAL</literal></term>
<listitem><para>Read in a number which will be added to the stored predicted
intensity</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>add_i_sigma= REAL</literal></term>
<listitem><para>Read in a number which will be added to the stored
<literal>&sigma;</literal> value for the experimental intensity</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>f_calc= CPX</literal></term>
<listitem><para>Read in a <emphasis>complex</emphasis> number representing the
calculated structure factor</para>
<itemizedlist>
<listitem><para>This is not usually inputted, but will be calculated by a
calling module</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>f_exp= REAL</literal></term>
<listitem><para>Read in a number which is the <quote>measured</quote>
experimental structure factor</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>f_pred= REAL</literal></term>
<listitem><para>Read in a number which is the predicted experimental structure
factor</para>
<itemizedlist>
<listitem><para>This is not usually inputted, but will be calculated by a
calling module</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>f_sigma= REAL</literal></term>
<listitem><para>Read in a number which is the <quote>measured</quote>
experimental <literal>&sigma;</literal> value for the structure factor</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>h= INT</literal></term>
<listitem><para>Read in the <literal>h</literal> Miller index</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>indices= INTVEC(3)</literal></term>
<listitem><para>Read in a triple of indices representing the miller indices
<literal>h</literal>, <literal>k</literal>, <literal>l</literal></para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>i_exp= REAL</literal></term>
<listitem><para>Read in a number which is the <quote>measured</quote>
experimental intensity</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>i_pred= REAL</literal></term>
<listitem><para>Read in a number which is the predicted intensity</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>i_sigma= REAL</literal></term>
<listitem><para>Read in a number which is the <quote>measured</quote>
<literal>&sigma;</literal> value for the experimental intensity</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>k= INT</literal></term>
<listitem><para>Read in the <literal>k</literal> Miller index</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>l= INT</literal></term>
<listitem><para>Read in the <literal>l</literal> Miller index</para>
</listitem>
</varlistentry>
</variablelist>

</sect2>
</sect1>

<!-- *********************************************************************** -->

<sect1 id="SCFDATA">
<title><literal>SCFDATA</literal></title>

<sect2 id="SCFDATA-purpose">
<title>Purpose</title>

<para>An object to store self consistent field (SCF) data, including interation
control </para>
</sect2>

<sect2 id="SCFDATA-synopsis">
<title>Synopsis</title>

<para>The <literal>SCFDATA</literal> objects contains all the information
required to define the way a self consistent field calculation converges. For
example, the kind of SCF calculation, initial guess parameters, integral
tolerances, whether to use extrapolation procedures, or to ingore certain
interaction, all stored in this object. </para>

<para>A count of the number of iterations is also kept so that the object can
evaluate whether convergence has been achieved. </para>

<para>Output routines are also available to print out <quote>banners</quote> and
iteration specific data in a tabular format.</para>

</sect2>

<sect2 id="SCFDATA-input">
<title>Default input data order</title>

<para>There is no associated SCFDATAVEC type; an input data order has not
been defined.</para>
</sect2>

<sect2 id="SCFDATA-keywords">
<title>Listing of keywords</title>

<variablelist>
<varlistentry>
<term><literal>1e_sl_factor= REAL</literal></term>
<listitem><para>Read a factor which multiplies the 1-electron spin orbit
interaction term in general relataivitic Hartree-Fock calculations</para>
<itemizedlist>
<listitem><para>the default is 1</para></listitem>
<listitem><para>setting this to zero will eliminate these
integrals</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>2e_sl_factor= REAL</literal></term>
<listitem><para>Read a factor which multiplies the 2-electron spin orbit
interaction term in general relataivitic Hartree-Fock calculations</para>
<itemizedlist>
<listitem><para>the default is 1</para></listitem>
<listitem><para>setting this to zero will eliminate these
integrals</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>camp-king= BIN</literal></term>
<listitem><para>Read a switch which tells whether to use Camp-King
extrapolation</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>convergence= REAL</literal></term>
<listitem><para>Read a number which indicates convergence in the SCF energy
value</para>
<itemizedlist>
<listitem><para>Default value is
<literal>10<superscript>-4</superscript></literal></para></listitem>
<listitem><para>Convergence is when the difference between the energies from two
succesive iterations is less than the inputted value and greater than the first
iteration</para></listitem>
<listitem><para>Other convergence criteria also apply; <literal>see
diis_convergence=</literal></para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>converge= REAL</literal></term>
<listitem><para>Same as <literal>convergence=</literal></para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>damp_finish= INT</literal></term>
<listitem><para>Read an integer representing when density damping ceases</para>
<itemizedlist>
<listitem><para>Default value is 3</para></listitem>
<listitem><para>Density damping refers to a technique whereby a certain
percentage of the previous iteration density matrix is added to the
complementary percentage of the current density matrix</para></listitem>
<listitem><para>It is used to stop wild oscillations near the start of the SCF
procedure</para></listitem>
<listitem><para>Refer to <literal>damp_factor=</literal> and
<literal>use_damping=</literal></para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>damp_factor= REAL</literal></term>
<listitem><para>Read a factor <literal>x</literal> which is used to damp the
current density matrix</para>
<itemizedlist>
<listitem><para>Default value is 0.5</para></listitem>
<listitem><para>Density damping refers to a technique whereby a certain
percentage of the previous iteration density matrix is added to the
complementary percentage of the current density matrix, <literal>D =
x D<subscript>i</subscript> + (1-x)
D<subscript>i-1</subscript></literal></para></listitem>
<listitem><para>It is used to stop wild oscillations near the start of the SCF
procedure</para></listitem>
<listitem><para>Refer to <literal>use_damping=</literal></para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>direct= BIN</literal></term>
<listitem><para>If set <literal>TRUE</literal>, two electron integrals are
recalculated every iteration</para>
<itemizedlist>
<listitem><para>Default value is <literal>FALSE</literal></para></listitem>
<listitem><para>Note: if this switch is set, then
<literal>use_delta_build=</literal> is also set</para></listitem>
<listitem><para>Refer to <literal>use_delta_build=</literal></para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>diis= BIN</literal></term>
<listitem><para>Equivalent to <literal>use_diis=</literal></para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>diis_convergence= REAL</literal></term>
<listitem><para>Read a number which indicates when DIIS convergence is
achieved</para>
<itemizedlist>
<listitem><para>Default value is
<literal>10<superscript>-4</superscript></literal></para></listitem>
<listitem><para>This convergence value is used even when DIIS is not, since it
indicates the gradient of the SCF energy with respect to orbital rotation
parameters</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>dynamic_damping= BIN</literal></term>
<listitem><para>If <literal>TRUE</literal>, a density damping technique is used,
where the damping factor used is decided by the program during each SCF
iteration</para>
<itemizedlist>
<listitem><para>The default is <literal>FALSE</literal></para></listitem>
<listitem><para>See <literal>use_damping=</literal></para></listitem>
<listitem><para>See also
<literal>dynamic_damp_factor=</literal></para></listitem>
<listitem><para>Warning: this should not be used for completion of SCF
convergence, since density matrices generated by damping are not valid density
matrices</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>diis_keep= INT</literal></term>
<listitem><para>Read an integer telling how many DIIS parameter vectors to
keep</para>
<itemizedlist>
<listitem><para>The default value is 8</para></listitem>
<listitem><para>Note: some archive files are created by the DIIS routine to
store past iteration results</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>diis_start= INT</literal></term>
<listitem><para>Read an integer telling when the DIIS procedure is to
start</para>
<itemizedlist>
<listitem><para>The default is 3</para></listitem>
<listitem><para>Refer also to <literal>diis_keep=</literal> and
<literal>diis=</literal></para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>eri_cutoff= REAL</literal></term>
<listitem><para>Read a number telling which integrals are to be ignored because
they are deemed too small</para>
<itemizedlist>
<listitem><para>The default is
<literal>10<superscript>-12</superscript></literal></para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>eri_limit= REAL</literal></term>
<listitem><para>Equivalent to <literal>eri_cutoff=</literal></para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>initial_density= STR</literal></term>
<listitem><para>Read a string indicating what initial guess for the
<emphasis>density matrix</emphasis> should be used</para>
<itemizedlist>
<listitem><para>Default is <literal>core</literal>, i.e. using the core
hamiltonian</para></listitem>
<listitem><para>Other options:
<simplelist type="Horiz" columns=1>
<member><literal>atom</literal>, i.e. start from a sum of spherically averaged
atomic densities;</member>
<member><literal>group</literal>, i.e. start from a sum of molecular group
densities</member>
</simplelist>
</para></listitem>
<listitem><para>The following options assume that the corresponding &TONTO;
archive (produced from a previous SCF run with the same archive name) exists in
the same directory where the executable is running:
<simplelist type="Horiz" columns=1>
<member><literal>restricted</literal>,</member>
<member><literal>unrestricted</literal>,</member>
<member><literal>general</literal>,</member>
<member><literal>restricted_complex</literal>,</member>
<member><literal>complex_unrestricted</literal>,</member>
<member><literal>unrestricted_complex</literal>,</member>
<member><literal>general_complex</literal>,</member>
<member><literal>complex_general</literal>.</member>
</simplelist>
Note that these densities are <quote>converted</quote> to the right
type if the <literal>scf_kind=</literal> is not compatible</para></listitem>
<listitem><para>Refer <literal>to scf_kind=</literal></para></listitem>
<listitem><para>Other option: <literal>fock</literal>, start from an existing
(in memory) fock matrix. Note that this is not starting from an initial density
whereas all other options are</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>initial_mos= STR</literal></term>
<listitem><para>Read in a string indicating that initial molecular orbitals are
to be used to start the SCF cycle</para>
<itemizedlist>
<listitem><para>Allowed options are:
<simplelist type="Horiz" columns=1>
<member><literal>restricted</literal>,</member>
<member><literal>unrestricted</literal>,</member>
<member><literal>general</literal>,</member>
<member><literal>restricted_complex</literal>,</member>
<member><literal>complex_unrestricted</literal>,</member>
<member><literal>unrestricted_complex</literal>,</member>
<member><literal>general_complex</literal>,</member>
<member><literal>complex_general</literal>.</member>
</simplelist></para></listitem>
<listitem><para>Where possible molecular orbitals of one type are
<quote>converted</quote> to the calculation type if the
<literal>scf_kind=</literal> is not compatible</para></listitem>
<listitem><para>Refer to <literal>scf_kind=</literal></para></listitem>
<listitem><para>It is assumed that the corresponding &TONTO; archive (produced
from a previous SCF run with the same archive name) exists in the same directory
where the executable is running</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>initial_lambda= STR</literal></term>
<listitem><para>Read the initial &lambda; value used in the constrained SCF
procedure</para>
<itemizedlist>
<listitem><para>This value is incremented by <literal>lambda_step</literal>
until <literal>lambda_max</literal> is attained</para></listitem>
<listitem><para>See <literal>lambda_step=</literal> and
<literal>lambda_max</literal></para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>kind= STR</literal></term>
<listitem><para>Equivalent to <literal>scf_kind=</literal></para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>lambda_min= REAL</literal></term>
<listitem><para>Read the initial <literal>&lambda;</literal> value used in the
constrained SCF procedure</para>
<itemizedlist>
<listitem><para>This value is incremented by <literal>lambda_step</literal>
until <literal>lambda_max</literal> is attained</para></listitem>
<listitem><para>See <literal>lambda_step=</literal> and
<literal>lambda_max</literal></para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>lambda_max= REAL</literal></term>
<listitem><para>Read the maximum <literal>&lambda;</literal> value to be used 
in the constrained SCF procedure</para>
<itemizedlist>
<listitem><para>The initial <literal>&lambda;</literal> is set using
<literal>initial_lambda=</literal> or <literal>lambda_min=</literal>
</para></listitem>
<listitem><para><literal>&lambda;</literal> is incremented by the value set in
<literal>lambda_step=</literal></para></listitem>
<listitem><para>The cycle terminated when the value set in
<literal>lambda_max=</literal> is exceeded</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>lambda_step= REAL</literal></term>
<listitem><para>Read the <literal>&delta; &lambda;</literal> value used to
increment the <literal>&lambda;</literal> value in the constrained SCF
procedure</para>
<itemizedlist>
<listitem><para>The initial <literal>&lambda;</literal> is set using
<literal>initial_lambda=</literal> or <literal>lambda_min=</literal>
</para></listitem>
<listitem><para>The cycle terminated when the value set in
<literal>lambda_max=</literal> is exceeded</para></listitem>
<listitem><para>Refer to <literal>lambda_max=</literal></para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>level_shift= REAL</literal></term>
<listitem><para>Read a number used for level shifting the Fock matrix</para>
<itemizedlist>
<listitem><para>The diagonals of the virtual-virtual block of the
pre-diagonalised fock matrix are shifted upward by this value</para></listitem>
<listitem><para>This has the effect of damping SCF oscillation</para></listitem>
<listitem><para>Level shifting is applied by default until iteration
3</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>level_shift_finish= INT</literal></term>
<listitem><para>Read an integer at which level shifting is to stop</para>
<itemizedlist>
<listitem><para>Default value is 3</para></listitem>
<listitem><para>Setting a value zero turns this feature off</para></listitem>
<listitem><para>Refer to <literal>level_shift=</literal></para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>min_it= INT</literal></term>
<listitem><para>Read an integer representing the minimum number of iterations to
be used in the SCF procedure</para>
<itemizedlist>
<listitem><para>The default value is 1</para></listitem>
<listitem><para>See also <literal>max_it=</literal></para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>min_iterations= INT</literal></term>
<listitem><para>Equivalent to <literal>min_it=</literal></para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>max_it= INT</literal></term>
<listitem><para>Read an integer representing the maximum number of iterations to
be used in the SCF procedure</para>
<itemizedlist>
<listitem><para>The default value is 100</para></listitem>
<listitem><para>See also <literal>min_it=</literal></para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>max_iterations= INT</literal></term>
<listitem><para>Equivalent to <literal>max_it=</literal></para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>nddo= BIN</literal></term>
<listitem><para>If <literal>TRUE</literal>, an NDDO (Neglect of Diatomic
Differential Overlap) calculation is performed</para>
<itemizedlist>
<listitem><para>Currently only available for RHF</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>nudo= BIN</literal></term>
<listitem><para>If <literal>TRUE</literal>, an NUDO (Neglect of Unconnected
Differential Overlap) calculation is performed</para>
<itemizedlist>
<listitem><para>In this method, only the integrals atoms which are
connected---that is within a certain bonding radius---are
calculated</para></listitem>
<listitem><para>Currently only available for RHF</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>output= BIN</literal></term>
<listitem><para>If set <literal>FALSE</literal>, no output is presented by
<literal>put</literal> routines</para>
<itemizedlist>
<listitem><para>Default is <literal>TRUE</literal></para></listitem>
<listitem><para>This is useful for calling modules which wish to have a hook
into turining off any SCF output---e.g. atomic guess routines</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>rough_convergence= REAL</literal></term>
<listitem><para>Read a number which indicates rough convergence in the SCF
energy value</para>
<itemizedlist>
<listitem><para>Default value is
<literal>10<superscript>-2</superscript></literal></para></listitem>
<listitem><para>Rough convergence is when the difference between the energies
from two succesive iterations is less than the inputted value and greater than
the first iteration</para></listitem>
<listitem><para>Usually when rough convergence is attained, full convergence is
attempted</para></listitem>
<listitem><para>This can save integral computation time</para></listitem>
<listitem><para>See <literal>use_rough_convergence=</literal></para></listitem>
<listitem><para>Other convergence criteria also apply; see
<literal>convergence=</literal> and
<literal>diis_convergence=</literal></para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>rough_diis_convergence= REAL</literal></term>
<listitem><para>Read a number which indicates rough DIIS convergence in the SCF
energy </para>
<itemizedlist>
<listitem><para>Default value is
<literal>10<superscript>-2</superscript></literal></para></listitem>
<listitem><para>Rough convergence is when the difference between the energies
from two succesive iterations is less than the inputted value and greater than
the first iteration</para></listitem>
<listitem><para>Usually when rough convergence is attained, full convergence is
attempted</para></listitem>
<listitem><para>This can save integral computation time</para></listitem>
<listitem><para>See <literal>use_rough_convergence=</literal></para></listitem>
<listitem><para>Other convergence criteria also apply; see
<literal>convergence=</literal> and
<literal>diis_convergence=</literal></para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>scf_kind= STR</literal></term>
<listitem><para>The kind of SCF calculation to be performed</para>
<itemizedlist>
<listitem><para>Thereis no default; this value must be
specified</para></listitem>
<listitem><para>Allowed values are:
<simplelist type="Horiz" columns=1>
<member><literal>rhf</literal>,</member>
<member><literal>restricted_hartree_fock</literal>,</member>
<member><literal>xray_rhf</literal>,</member>
<member><literal>rohf</literal>,</member>
<member><literal>restricted_open_shell_hartree_fock</literal>,</member>
<member><literal>uhf</literal>,</member>
<member><literal>unrestricted_hartree_fock</literal>,</member>
<member><literal>ghf</literal>,</member>
<member><literal>general_hartree_fock</literal>,</member>
<member><literal>rchf</literal>,</member>
<member><literal>restricted_complex_hartree_fock</literal>,</member>
<member><literal>uchf</literal>,</member>
<member><literal>unrestricted_complex_hartree_fock</literal>,</member>
<member><literal>gchf</literal>,</member>
<member><literal>general_complex_hartree_fock</literal>,</member>
<member><literal>noninteracting-group-rhf</literal>.</member>
</simplelist></para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>scf_type= STR</literal></term>
<listitem><para>Equivalent to <literal>scf_kind=</literal></para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>sl_1e_factor= REAL</literal></term>
<listitem><para>Equivalent to <literal>1e_sl_factor=</literal></para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>sl_2e_factor= REAL</literal></term>
<listitem><para>Equivalent to <literal>2e_sl_factor=</literal></para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>test= BIN</literal></term>
<listitem><para>If <literal>TRUE</literal>, some testing code may be
evaluated</para>
<itemizedlist>
<listitem><para>This is useful for programmers who want a simple hook into the
input</para></listitem>
<listitem><para>This should not be used by regular users</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>use_delta_build= BIN</literal></term>
<listitem><para>If <literal>TRUE</literal>, the fock matrix is built
incrementally</para>
<itemizedlist>
<listitem><para>Default is <literal>FALSE</literal></para></listitem>
<listitem><para>If <literal>direct=</literal> is set <literal>TRUE</literal>,
the default is <literal>TRUE</literal></para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>use_diis= BIN</literal></term>
<listitem><para>If set <literal>TRUE</literal>, DIIS extrapolation is
used</para>
<itemizedlist>
<listitem><para>Default value is <literal>TRUE</literal></para></listitem>
<listitem><para>By default, the method turn on only at iteration 3, and only 8
vectors are kept</para></listitem>
<listitem><para>Refer to <literal>diis_start=</literal> and
<literal>diis_keep=</literal></para></listitem>
<listitem><para>Note: some archive files are created by the DIIS routine to
store past iteration results</para></listitem>
<listitem><para>The DIIS method extrpolates the fock matrix</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>use_rough_convergence= BIN</literal></term>
<listitem><para>If <literal>TRUE</literal>, rough convergence is used</para>
<itemizedlist>
<listitem><para>Refer to <literal>rough_convergence=</literal></para></listitem>
<listitem><para>Rough convergence is when the difference between the energies
from two succesive iterations is less than the inputted value and greater than
the first iteration</para></listitem>
<listitem><para>Usually when rough convergence is attained, full convergence is
attempted</para></listitem>
<listitem><para>This can save integral computation time</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>use_damping= BIN</literal></term>
<listitem><para>If <literal>TRUE</literal>, density damping is used</para>
<itemizedlist>
<listitem><para>Density damping refers to a technique whereby a certain
percentage of the previous iteration density matrix is added to the
complementary percentage of the current density matrix, <literal>D = x
D<subscript>i</subscript> + (1-x)
D<subscript>i-1</subscript></literal></para></listitem>
<listitem><para>It is used to stop wild oscillations near the start of the SCF
procedure</para></listitem>
<listitem><para>To input <literal>x</literal> refer to
<literal>damp_factor=</literal></para></listitem>
<listitem><para>Refer to <literal>damp_finish=</literal></para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>use_level_shift= BIN</literal></term>
<listitem><para>If <literal>TRUE</literal>, level shifting is used</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>use_level_shifting= BIN</literal></term>
<listitem>
<itemizedlist>
<listitem><para>The diagonals of the virtual-virtual block of the
pre-diagonalised fock matrix are shifted upward by this value</para></listitem>
<listitem><para>This has the effect of damping SCF oscillation</para></listitem>
<listitem><para>Level shifting is applied by default until iteration
3</para></listitem>
<listitem><para>Refer to
<literal>level_shift_finish=</literal></para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>use_bl_term= BIN</literal></term>
<listitem><para>If <literal>FALSE</literal>, the magnetic-field angular-momentum
term <literal>B.L</literal> is ignored in general relativistic Hartree Fock
calculations</para>
<itemizedlist>
<listitem><para>The default is <literal>TRUE</literal></para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>use_bs_term= BIN</literal></term>
<listitem><para>If <literal>FALSE</literal>, the magnetic-field spin
angular-momentum term <literal>B.S</literal> is ignored in general relativistic
Hartree Fock calculations</para>
<itemizedlist>
<listitem><para>The default is <literal>TRUE</literal></para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>use_bs_t_term= BIN</literal></term>
<listitem><para>If <literal>FALSE</literal>, the magnetic-field kinetic term
<literal>(B.S)&nabla;<superscript>2</superscript></literal> is ignored in
general relativistic Hartree Fock calculations</para>
<itemizedlist>
<listitem><para>The default is <literal>TRUE</literal></para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>use_aa_term= BIN</literal></term>
<listitem><para>If <literal>FALSE</literal>, the magnetic vector field term
<literal>A.A</literal> is ignored in general relativistic Hartree Fock
calculations</para>
<itemizedlist>
<listitem><para>The default is <literal>TRUE</literal></para></listitem>
<listitem><para>This is the diamagnetic term</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>use_1e_sl_term= BIN</literal></term>
<listitem><para>If <literal>FALSE</literal>, the 1-electron spin orbit integrals
are not used</para>
<itemizedlist>
<listitem><para>The default is <literal>TRUE</literal></para></listitem>
<listitem><para>See also <literal>1e_sl_factor=</literal></para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>use_1e_s(rxa)_term= BIN</literal></term>
<listitem><para>If <literal>FALSE</literal>, the 1-electron spin orbit gauge
invariant integrals are not used</para>
<itemizedlist>
<listitem><para>The default is <literal>TRUE</literal></para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>use_2e_sl_term= BIN</literal></term>
<listitem><para>If <literal>FALSE</literal>, the 2-electron spin orbit integrals
are not used</para>
<itemizedlist>
<listitem><para>The default is <literal>TRUE</literal></para></listitem>
<listitem><para>See also <literal>2e_sl_factor=</literal></para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>use_1e_zora_term= BIN</literal></term>
<listitem><para>If <literal>FALSE</literal>, the 1-electron ZORA (Zero Order
Regular Hamiltonian) integrals are not used</para>
<itemizedlist>
<listitem><para>The default is <literal>TRUE</literal></para></listitem>
<listitem><para>You should not use these integrals with the one electron spin
orbit integrals, which are calculated in the Briet-Pauli
approxintmation</para></listitem>
<listitem><para>Calling modules will require a numerical integration to evaluate
these integrals, probably via <literal>DFTGRID</literal></para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>quantization_axis= REALVEC(3)</literal></term>
<listitem><para>Read in a vector around which to quantise the spin </para>
<itemizedlist>
<listitem><para>This is used to quantise the initial spin when using UHF
orbitals as an initial guess to <literal>general_complex_hartree_fock</literal>
calculations</para></listitem>
<listitem><para>It may be required, for example, in <literal>g</literal>-tensor
calculations</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

</sect2>
</sect1>

<!-- *********************************************************************** -->

<sect1 id="SHELL">
<title><literal>SHELL</literal></title>

<sect2 id="SHELL-purpose">
<title>Purpose</title>

<para>An object describing a contracted shell of gaussian functions</para>
</sect2>

<sect2 id="SHELL-synopsis">
<title>Synopsis</title>

<para>The module consists mainly of a contraction coefficient vector, and
exponent vector, an integer describing the <quote>angular momentum</quote> of
the shell <literal>l = n<subscript>1</subscript> + n<subscript>2</subscript> +
n<subscript>3</subscript></literal>, where the <literal>n</literal> are the
powers of the cartesian gaussian function.</para>

<para>The position of the shell is <emphasis>not</emphasis> stored. See the
<literal>SHELL1</literal> module for that.  The modules primary purpose is for
storing basis sets. See the <literal>BASIS</literal> module.</para>

<para>At the moment, only <quote>segmented</quote> cartesian shells are
modelled.</para>

<para>The order of the cartesian components is given by routine
<literal>INT:make_gaussian_xyz_powers</literal>.  Refer to the online
documentation for module <literal>INT</literal></para>
</sect2>

<sect2 id="SHELL-input">
<title>Default input data order</title>

<programlisting>
SHELL_INPUT_DATA_ORDER     [ l= n_cc= ex,cc= ]
</programlisting>
</sect2>

<sect2 id="SHELL-keywords">
<title>Listing of keywords</title>

<variablelist>
<varlistentry>
<term><literal>cc= REALVEC(n_cc)</literal></term>
<listitem><para>Enter a vector of contraction coefficients</para>
<itemizedlist>
<listitem><para>The value of <literal>n_cc</literal> must be entered beforehand;
see <literal>n_cc=</literal></para></listitem>
<listitem><para>Normally modules will assume the coefficients are with respect
to normalised gaussian</para></listitem>
<listitem><para>Default units are atomic units</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>ex= REALVEC(n_cc)</literal></term>
<listitem><para>Enter a vector of exponents </para>
<itemizedlist>
<listitem><para>The value of <literal>n_cc</literal> must be entered beforehand;
see <literal>n_cc=</literal></para></listitem>
<listitem><para>Normally modules will assume the coefficients are with
respect to normalised gaussian</para></listitem>
<listitem><para>Default units are atomic units</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>ex,cc= REALVEC(n_cc),REALVEC(n_cc)</literal></term>
<listitem><para>Enter alternating vector of exponents and contraction
coefficients</para>
<itemizedlist>
<listitem><para>The value of <literal>n_cc</literal> must be entered beforehand;
see <literal>n_cc=</literal></para></listitem>
<listitem><para>Normally modules will assume the coefficients are with respect
to normalised gaussian</para></listitem>
<listitem><para>Default units are atomic units</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>junk,ex,cc= REALVEC(n_cc),REALVEC(n_cc),REALVEC(n_cc)</literal></term>
<listitem><para>Enter alternating vector of a junk string, an exponent, and a
contraction coefficient</para>
<itemizedlist>
<listitem><para>The value of <literal>n_cc</literal> must be entered beforehand;
see <literal>n_cc=</literal></para></listitem>
<listitem><para>Normally modules will assume the coefficients are with respect
to normalised gaussian</para></listitem>
<listitem><para>Default units are atomic units</para></listitem>
<listitem><para>This style is useful for the GAMESS-US program</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>l= INT|STR</literal></term>
<listitem><para>Read either an integer representing the <literal>l</literal>
value of the gaussian; or read a single character representing the angular
momentum</para>
<itemizedlist>
<listitem><para>If the inputted data in an integer, it must be
non-negative</para></listitem>
<listitem><para>If the inputted data in a character is must be
<literal>s</literal>, <literal>p</literal>, <literal>d</literal>,
<literal>f</literal>, <literal>g</literal>, <literal>...</literal>,
<literal>z</literal></para></listitem>
<listitem><para>See also <literal>l_chr=</literal> and
<literal>l_int=</literal></para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>l_chr= STR</literal></term>
<listitem><para>Read a single character representing the angular momentum of the
gaussian</para>
<itemizedlist>
<listitem><para>Must be <literal>s</literal>, <literal>p</literal>,
<literal>d</literal>, <literal>f</literal>, <literal>g</literal>,
<literal>...</literal>, <literal>z</literal></para></listitem>
<listitem><para>See also <literal>l=</literal> and
<literal>l_int=</literal></para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>l_int= INT</literal></term>
<listitem><para>Read a single integer which is the angular momentum of the
gaussian</para>
<itemizedlist>
<listitem><para>Inputted data must be non-negative</para></listitem>
<listitem><para>See also <literal>l=</literal> and
<literal>l_chr=</literal></para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>n_cc= INT</literal></term>
<listitem><para>Enter the number od contractions in this shell</para>
<itemizedlist>
<listitem><para>This must be enetred before <literal>ex=</literal> or
<literal>cc=</literal></para></listitem>
<listitem><para>A shell is a sum of gausian functions; this number is the length
of the sum</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>put</literal></term>
<listitem><para>Print out information about the <literal>SHELL</literal> to the
<literal>stdout</literal> file in human readable form</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>units= STR</literal></term>
<listitem><para>Read a string which describes the units of the next inputted
numerical entity; that is, the next real or complex number, real or complex
vector, or real or complex matrix.</para>
<itemizedlist>
<listitem><para>The default atomic units are restored after the numerical entity
has been inputted</para></listitem>
<listitem><para>Warning: if the next inputted datum is not a numerical entity,
the new units keyword remains in force</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

</sect2>
</sect1>

<!-- *********************************************************************** -->

<sect1 id="SHELL1">
<title><literal>SHELL1</literal></title>

<sect2 id="SHELL1-purpose">
<title>Purpose</title>

<para>An object describing a contracted shell of gaussian functions,
<emphasis>including</emphasis> the position of the gaussian</para>
</sect2>

<sect2 id="SHELL1-synopsis">
<title>Synopsis</title>

<para>The module consists mainly of a contraction coefficient vector, and
exponent vector, an integer describing the <quote>angular momentum</quote> of
the shell <literal>l = n<subscript>1</subscript> + n<subscript>2</subscript> +
n<subscript>3</subscript></literal>, where the <literal>n</literal> are the
powers of the cartesian gaussian function, and a position.</para>

<para>This module differes from <literal>SHELL</literal> in that the position is
stored.</para>

<para>The module contains routines for normalisation, and calculating the value
of the contracted shell for various functions, such as the kinetic density, or
laplacian.</para>

<para>At the moment, only <quote>segmented</quote> cartesian shells are
modelled.</para>

<para>The order of the cartesian components is given by routine
<literal>INT:make_gaussian_xyz_powers</literal>.  Refer to the online
documentation for module <literal>INT</literal></para>
</sect2>

<sect2 id="SHELL1-input">
<title>Default input data order</title>

<para>There is currently no <literal>SHELL1VEC</literal> module. However, the
data order is defined as:
<programlisting>
SHELL1_INPUT_DATA_ORDER     [ l= pos= n_cc= ex,cc= ]
</programlisting>
</para>
</sect2>

<sect2 id="SHELL1-keywords">
<title>Listing of keywords</title>

<variablelist>
<varlistentry>
<term><literal>cc= REALVEC(n_cc)</literal></term>
<listitem><para>Enter a vector of contraction coefficients</para>
<itemizedlist>
<listitem><para>The value of <literal>n_cc</literal> must be entered beforehand;
see <literal>n_cc=</literal></para></listitem>
<listitem><para>Normally modules will assume the coefficients are with respect
to normalised gaussian</para></listitem>
<listitem><para>Default units are atomic units</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>ex= REALVEC(n_cc)</literal></term>
<listitem><para>Enter a vector of exponents </para>
<itemizedlist>
<listitem><para>The value of <literal>n_cc</literal> must be entered beforehand;
see <literal>n_cc=</literal></para></listitem>
<listitem><para>Normally modules will assume the coefficients are with
respect to normalised gaussian</para></listitem>
<listitem><para>Default units are atomic units</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>ex,cc= REALVEC(n_cc),REALVEC(n_cc)</literal></term>
<listitem><para>Enter alternating vector of exponents and contraction
coefficients</para>
<itemizedlist>
<listitem><para>The value of <literal>n_cc</literal> must be entered beforehand;
see <literal>n_cc=</literal></para></listitem>
<listitem><para>Normally modules will assume the coefficients are with respect
to normalised gaussian</para></listitem>
<listitem><para>Default units are atomic units</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>junk,ex,cc= REALVEC(n_cc),REALVEC(n_cc),REALVEC(n_cc)</literal></term>
<listitem><para>Enter alternating vector of a junk string, an exponent, and a
contraction coefficient</para>
<itemizedlist>
<listitem><para>The value of <literal>n_cc</literal> must be entered beforehand;
see <literal>n_cc=</literal></para></listitem>
<listitem><para>Normally modules will assume the coefficients are with respect
to normalised gaussian</para></listitem>
<listitem><para>Default units are atomic units</para></listitem>
<listitem><para>This style is useful for the GAMESS-US program</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>l= INT|STR</literal></term>
<listitem><para>Read either an integer representing the <literal>l</literal>
value of the gaussian; or read a single character representing the angular
momentum</para>
<itemizedlist>
<listitem><para>If the inputted data in an integer, it must be
non-negative</para></listitem>
<listitem><para>If the inputted data in a character is must be
<literal>s</literal>, <literal>p</literal>, <literal>d</literal>,
<literal>f</literal>, <literal>g</literal>, <literal>...</literal>,
<literal>z</literal></para></listitem>
<listitem><para>See also <literal>l_chr=</literal> and
<literal>l_int=</literal></para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>l_chr= STR</literal></term>
<listitem><para>Read a single character representing the angular momentum of the
gaussian</para>
<itemizedlist>
<listitem><para>Must be <literal>s</literal>, <literal>p</literal>,
<literal>d</literal>, <literal>f</literal>, <literal>g</literal>,
<literal>...</literal>, <literal>z</literal></para></listitem>
<listitem><para>See also <literal>l=</literal> and
<literal>l_int=</literal></para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>l_int= INT</literal></term>
<listitem><para>Read a single integer which is the angular momentum of the
gaussian</para>
<itemizedlist>
<listitem><para>Inputted data must be non-negative</para></listitem>
<listitem><para>See also <literal>l=</literal> and
<literal>l_chr=</literal></para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>n_cc= INT</literal></term>
<listitem><para>Enter the number od contractions in this shell</para>
<itemizedlist>
<listitem><para>This must be enetred before <literal>ex=</literal> or
<literal>cc=</literal></para></listitem>
<listitem><para>A shell is a sum of gausian functions; this number is the length
of the sum</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>pos= REALVEC(3)</literal></term>
<listitem><para>Enter the position of the center of the shell</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>put</literal></term>
<listitem><para>Print out information about the <literal>SHELL1</literal> to the
<literal>stdout</literal> file in human readable form</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>units= STR</literal></term>
<listitem><para>Read a string which describes the units of the next inputted
numerical entity; that is, the next real or complex number, real or complex
vector, or real or complex matrix.</para>
<itemizedlist>
<listitem><para>The default atomic units are restored after the numerical entity
has been inputted</para></listitem>
<listitem><para>Warning: if the next inputted datum is not a numerical entity,
the new units keyword remains in force</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

</sect2>
</sect1>

<!-- *********************************************************************** -->

<sect1 id="SPACEGROUP">
<title><literal>SPACEGROUP</literal></title>

<sect2 id="SPACEGROUP-purpose">
<title>Purpose</title>

<para>An object for representing a crystal space group</para>
</sect2>

<sect2 id="SPACEGROUP-synopsis">
<title>Synopsis</title>

<para>This module inputs either the international symmetry symbol or Hall
symbol, and makes the Seitz matrices for that particular spacegroup. </para>

<para>The module also provides routines for transforming coordinates into units
cells, obtaining asymmetric units, repretation factors, unique sietz operators
for a given fragment, and partition factors for structure factor calculations
based on non-asymmetric unit fragments.</para>
</sect2>

<sect2 id="SPACEGROUP-references">
<title>References</title>

<para>S. R. Hall, Acta Cryst. A37, 517 (1981)</para>
</sect2>

<sect2 id="SPACEGROUP-input">
<title>Default input data order</title>

<para>There is no associated <literal>SPACEGROUPVEC</literal> module.</para>
</sect2>

<sect2 id="SPACEGROUP-keywords">
<title>Listing of keywords</title>

<variablelist>
<varlistentry>
<term><literal>it_symbol=</literal></term>
<listitem><para>Read the international table (IT) symbol for the
spacegroup</para>
<para>Example:
<programlisting>
   spacegroup_it_symbol=   P2_13
</programlisting></para>
<itemizedlist>
<listitem><para>Use a caret <literal>^</literal> before a character to represent
a bar over that character; e.g <literal>^P</literal></para></listitem>
<listitem><para>Use an underscore <literal>_</literal> after a character to
represent a subscript; e.g. <literal>2<subscript>ab</subscript></literal> is
<literal>2_ab</literal></para></listitem>
<listitem><para>Use a slash <literal>/</literal> where a slash should
go</para></listitem>
<listitem><para>Do not use spaces between symbols</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>hall_symbol=</literal></term>
<listitem><para>Enter the spacegroup in Hall notation</para>
<itemizedlist>
<listitem><para>Refer to <literal>it_symbol=</literal></para></listitem>
<listitem><para>Refer to <literal>SPACEGROUP:set_Hall_conversion_table</literal>
so see the relationship between Hall symbols and international table
symbols</para></listitem>
<listitem><para>For details of notation and non standard axis and origin
settings, see: S. R. Hall, Acta Cryst. A37, 517 (1981)</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>put</literal></term>
<listitem><para>Print out information about the <literal>SPACEGROUP</literal> to
the <literal>stdout</literal> file in human readable form</para>
</listitem>
</varlistentry>
</variablelist>

</sect2>
</sect1>

<!-- *********************************************************************** -->

<sect1 id="TEXTFILE">
<title><literal>TEXTFILE</literal></title>

<sect2 id="TEXTFILE-purpose">
<title>Purpose</title>

<para>An object for reading or writing ASCII textfiles</para>
</sect2>

<sect2 id="TEXTFILE-synopsis">
<title>Synopsis</title>

<para><literal>TEXTFILE</literal> is a line-oriented formatted sequential
advancing file.  It can handle input and output, including input from standard
input, and output to standard output.</para> 

<para>The <literal>TEXTFILE</literal> object is a <literal>FILE</literal> with a
<literal>BUFFER</literal> and a <literal>REALFMT</literal> formatting object. The
input/output proceeds via a line buffer. It is forbidden to open a TEXTFILE
simultaneously for input and output.</para>

<para>There is a default internal standard input object,
<literal>stdin</literal>, and a default standard output object,
<literal>stdout</literal>. Usually these are connected to real files with those
names, <emphasis>not</emphasis> the terminal.</para>

<para>A line count is maintained to allow back-tracking to previous lines, and
particular items on each line. This is useful for input.</para>

<para>For output, items can be put in columns of a specified width, with double
precision numbers having a specified precision and "style" (set using fortran
conventions). This is useful for dynamic tables, which the user can change at
run time. Rewind and backtracking are not allowed for output files.</para>

<para>It is possible to redirect the input or output to a new file using the
"redirect" command. The previous file can be recovered using "revert", or it
will revert back automatically to the previous file if the redirected file ends.
It is also possibile to redirect input to an internal file. This is useful for
processing a list of text as if it were a file. Output to an internal file is
not allowed.</para>

<para>Note that the input buffer is limited to size
<literal>BSTR_SIZE</literal>, set in the <literal>macros</literal> file.</para>

<para>The system information in the system variable <literal>tonto</literal> is
updated whenever a I/O operation or a buffer operation is performed, so that
&TONTO; knows where it is at and can tell you where it was up to in processing
any file.  </para>
</sect2>

<sect2 id="TEXTFILE-note">
<title>Important note</title>

<para>Keywords are normally inputted from <literal>stdin</literal> using the
<literal>read</literal> routine and processed by the conventional routine
<literal>process_input</literal>.</para>

<para>In the case of <literal>TEXTFILE</literal>, these keywords are processed
by <literal>process(word,in)</literal>.  There is no input from
<literal>stdin</literal> since this file defined the properties of
<literal>stdin</literal>.</para>

<para>The keywords in this module only affect the way output is
presented.</para> 
</sect2>

<sect2 id="TEXTFILE-input">
<title>Default input data order</title>

<para>There is no associated <literal>TEXTFILEVEC</literal> module.</para>
</sect2>

<sect2 id="TEXTFILE-keywords">
<title>Listing of keywords</title>

<variablelist>
<varlistentry>
<term><literal>real_precision= INT</literal></term>
<listitem><para>Equivalent to <literal>precision=</literal></para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>real_style= STR</literal></term>
<listitem><para>Read a character indicating the style of output wanted for
real numbers</para>
<itemizedlist>
<listitem><para>The default is <literal>f</literal></para></listitem>
<listitem><para>The style symbols are those used in the fortran language:
<literal>f</literal>, <literal>g</literal>, <literal>e</literal>,
etc.</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>real_width= INT</literal></term>
<listitem><para>Equivalent to <literal>field_width=</literal></para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>fields= INT</literal></term>
<listitem><para>Read a number indicating the number of fields across the page
wanted when outputting a vector or matrix</para>
<itemizedlist>
<listitem><para>The default is 5</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>field_width= INT</literal></term>
<listitem><para>Read an integer indicating the width of a field required for
real numbers</para>
<itemizedlist>
<listitem><para>The default is 20</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>int_width= INT</literal></term>
<listitem><para>Read an integer indicating the width of a field required for an
integer, or string variable</para>
<itemizedlist>
<listitem><para>The default is 9</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>labels= BIN</literal></term>
<listitem><para>If set <literal>TRUE</literal>, integer labels are used on the
columns or rows of vectords and matrices when they are outputted</para>
<itemizedlist>
<listitem><para>The default is <literal>TRUE</literal></para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>margin= INT</literal></term>
<listitem><para>Read an integer setting the number of blank characters used in
the margin when outputting text</para>
<itemizedlist>
<listitem><para>The default is 0</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>precision= INT</literal></term>
<listitem><para>Read an integer telling the number of significant figures
desired when outputting real number</para>
<itemizedlist>
<listitem><para>The default is 9</para></listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>style= STR</literal></term>
<listitem><para>Equivalent to <literal>real_style=</literal></para>
</listitem>
</varlistentry>
</variablelist>

</sect2>
</sect1>
</chapter>

<!-- *********************************************************************** -->
<!-- *********************************************************************** -->

<chapter id="writing-programs">
<title>Writing programs with &TONTO;</title>

<!-- *********************************************************************** -->

<sect1 id="tonto-design">
<title>The design of &TONTO;</title>

<para>In this chapter we will describe the overall design of the &TONTO; system,
and the reasons why the design was adopted.</para>

<para>In the following chapters, these issues are explored in more
detail.</para>

<para>This chapter and those following are primarily for those interested in
programming with &TONTO;.</para>
</sect1>

<!-- *********************************************************************** -->

<sect1 id="tonto-modules">
<title>Modules in &TONTO;</title>

<para>&TONTO; is different from most programs used in computational chemistry
because it does not have a <quote>main program</quote> (although for convenience
a few common <quote>main programs</quote> are already set up for you to use).
Instead, &TONTO; consists of about fifty independent modules.  In most cases the
more sophisticated modules will make use of the simpler ones.  Once compiled,
however, each single module can be used separately, in its own right. It is the
documentation for each of these modules which appears on the &TONTO;
homepage.</para>

<para>The module which probably will be used most often is
<literal>MOL</literal>, since it contains routines which deal with the
<quote>molecule data type</quote>.  The executable, or <quote>main
program</quote> associated with this module is called
<literal>run_mol.x</literal>. Indeed, the executable associated with any module
with name <literal>XXXX</literal> is, by convention, always called
<literal>run_xxxx.x</literal>.</para>

<para>Each module in &TONTO; is organised so that it is concerned only with
tasks which deal with a specific data type.  For example, the module
<literal>REALMAT</literal> deals with the data type <quote>matrices of real
numbers</quote>, and consists of routines, such as
<literal>swap_columns</literal> or <literal>solve_eigenproblem</literal>, which
only deal with matrices.  That is, their first argument is always a matrix of
real numbers.</para>

<para>More complicated modules are designed around Fortran95 derived data types.
For example, the <quote>molecule data type</quote> which is used in module
<literal>MOL</literal>  is built from a collection of items, called
<emphasis>components</emphasis>, of a simpler data type.  There is one component
called <literal>name</literal> of <quote>string type</quote> which holds the
name of the molecule. There is also another component called
<literal>atom</literal>, which is a vector.  Each element of this vector is of
<quote>atom type</quote>, and holds information about each of the atoms which
make up the molecule.  Each of the routines in module <literal>MOL</literal>
(for example, <literal>center_of_mass</literal>, which returns the center of
mass of the molecule) always takes as its first argument, a variable of the
molecule data type.</para>

<para>The style of module programming used in &TONTO; is known as abstract data
type programming, or more loosely, object based programming.</para>

<para>This style of module was chosen because we believe it has a simplicity of
structure and ease of modification which was one of the main design goals of
&TONTO;. </para>

</sect1>

<!-- *********************************************************************** -->

<sect1 id="foo">
<title>The &foo; language in &TONTO;</title>

<para>&TONTO; is different from other programs because it is written in a
preprocessor language called &foo;. This language is essentially a terse form of
Fortran95. Indeed, it currently translates into Fortran95.</para>

<para>The <literal>foo</literal> language has been adopted for two
reasons.</para>

<para>The first reason is because the object based paradigm is easily expressed
in the &foo; language. A dot notation has been introduced which blurs the
distinction between a routine and a derived type component. This makes it very
flexible to further change. &TONTO; has already been written from the ground up
about four times.  There are other advantages when using &foo; which involve the
automation of a few laborious tasks associated with object based
programmming---for example the automated generation of interface definitions or
overloaded names.</para>

<para>The second reason to use &foo; is because the documentation can easily be
extracted from the code. Indeed, the code is intended to be self documenting
(although in practice this is entirely dependent on the discipline of the
programmer).</para>

<para>We have chosen to use Fortran95 as the base language in recognition of its
its tradition of providing highly optimizing compilers for heavy numerical
computation. This tradition is due in part to Fortran's good aliasing properties
for pointers, and to favourable expression re-arrangement properties. Another
significant reason for using Fortran95 is that it is backwards compatible with
Fortran77, so the significant existing body of old code can be used as a
starting point, and then gradually replaced.  Fortran95 also has some very
elegant built-in array manipulation mechanisms which are not available, or not
so elegant, in other languages.</para>

<para>We have chosen to use a preprocessor because we believe that the code will
then be more robust and portable. In particular, it is hoped that algorithms
written in &foo; will be language independent.</para>

<para>While we have chosen to use a preprocessor in our system, we do not desire
to force people to use it. The system is flexible enough to allow standard
Fortran programming, or linking to other Fortran programs.</para>
</sect1>

<!-- *********************************************************************** -->

<sect1 id="documentation-style">
<title>The documentation and style in &TONTO;</title>

<para>The ability to make use of a package effecitively depends critically on
the available documentation.</para>

<para>Since &TONTO; is primarily aimed at programers, the documentation is
geared toward them.</para>

<para>The documentation is comprised of two parts---the short and long
documentation.  Both parts are extracted directly from the &foo; code.  The
short documentation is comprised of routine names with their documentation and
variable declarations immediately afterwards; data components are also
documented in a similar style. The body of the routine is not displayed.  The
long documentation is comprised of the entire &foo; code.</para>

<para>In both the long and short documentation, it is possible to to traverse
the call-tree by hyperlinks, simply by clicking on underlined items. This can
save much time when learning or remembering how an algorithm works.</para>

<para>Although both data and routines are accessed in the same way, by a dot
notation, the documentation distinguished by colour those that are data (in
green), and those that are routines (in red). Since efficiency is a prime goal
of &TONTO;, it is hoped that the presence of many <quote>red</quote> routines in
a hot loop would warn the programmer of any efficiencies.</para>

<para>A well written &TONTO; routine is short, and has a clear purpose which is
reflected in its name. In order that the purpose of the routine is quite clear,
its name can sometimes be quite long, and it will often use the underscore
character.  We hope that most routines in &TONTO; are well written.</para>

<para>There are a few other essential conventions: specifically, the first
argument to every routine has the name <literal>self</literal> and is of the
same type as the module it belongs to. In this way, the language is very similar
to Python, for example.</para>

<para>The <literal>self</literal> variable is not explicitly seen in the
documentation, or the <literal>foo<literal> code but its presence can be
inferred by entities which begin with a dot, e.g.  </literal>.name</literal>  is
the component <literal>name</literal> of the self variable.</para>
</sect1>

<!-- *********************************************************************** -->

<sect1 id="conventional-routines">
<title>Conventional routines</title>

<para>If you look at a number of &TONTO; modules, you will find that almost all
of them will have a number of routines with the same name. These are called
<emphasis>conventional</emphasis> routines, and they are always associated with
the same kind of task in every module.</para>

<para>The presence of conventional routines makes the task of understanding and
using a module slightly easier, since one has a pre-expectation of what tasks
are performed by a certain routine. Indeed, if you want to write a new module
within the &TONTO; system, it is best not to use the conventional routine names
except for their intended purpose, otherwise you will confuse people.  </para>

<para>The purpose of these conventional routines will be described below.</para>

<para>If you are interested in running &TONTO;, the most important conventional
routine for you is the <literal>read</literal> routine or the
<literal>process_input</literal> routine.  You should read about them
below.</para>

<variablelist>
<varlistentry>
<term><literal>copy(object)</literal></term>
<listitem><para>This routine makes a copy of another <literal>object</literal>
of the same type.  Any pointers to objects are allocated before copying, so the
routine leads to a memory leak.</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>create; destroy</literal></term>
<listitem><para>The <literal>create</literal> routine is used to allocate memory
for a pointer to a data type described by the module.  Sometimes arguments are
supplied to <literal>create</literal> in order to set default values at
allocation time.</para>

<para>The <literal>destroy</literal> routine is used to deallocate memory for a
pointer to a data type described by the module.</para>

<para>The use of these routine causes a memory <quote>leak</quote> which is
monitored by memory checking routines in &TONTO;, provided these routines have
been enabled at compile time.</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>created; destroyed</literal></term>
<listitem><para>The <literal>created</literal> routine returns
<literal>TRUE</literal> if the data object (assumed to be a pointer) has been
allocated.</para>

<para>The <literal>destroyed</literal> routine returns <literal>TRUE</literal>
if the data object (assumed to be a pointer) has been deallocated.</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>create_copy(object)</literal></term>
<listitem><para>This routine first creates (i.e. allocates) a new object and
then makes a copy of it, in the sense of the <literal>copy(object)</literal>
routine.</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>data_length(keywords)</literal></term>
<listitem><para>This routine is used to determine the length of a list of input
data for a vector type object. The data is inputted from the
<literal>stdin</literal> file and is assumed to be in the order specified in the
<literal>keywords</literal> variable.</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>destroy_ptr_part</literal></term>
<listitem><para>If a data type has and components which are pointers, then this
routine is used to deallocate memory for pointer components.</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>nullify_ptr_part</literal></term>
<listitem><para>If a data type has and components which are pointers, then this
routine is used to nullify these pointer components. This is useful in cases
where the multiple pointers are pointing to the same piece of memory. Multiple
aliasing is rare in &TONTO; (it is inefficient and leads to concoluted code),
but it is sometimes used to save memory.</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>process_input(word); process_input(keyword)</literal></term>
<listitem><para>There are usually two routines with the name
<literal>process_input</literal>. Both are used to map an inputted keyword,
detected by routine <literal>read</literal>, to the actual module routine which
performs the task.</para>

<para>The <literal>process_input(word)</literal> routine processes a single
<literal>STR</literal> variable <literal>word</literal>, while the
<literal>process_input(keyword)</literal> routine takes a sequence of
<literal>STR</literal> values <literal>keyword</literal> as input.  This latter
routine is typically used to input lists of derived data according to a
predefined sequence of keywords, specified in the macros file in the
<literal>INPUT_DATA_ORDER</literal> variable for the module, or specified
manually via a <literal>list_order=</literal> keyword.</para>

<para>Note that if any single <literal>STR</literal> variable is comprised of a
list of blank separated keywords or data, then the
<literal>process_input</literal> routine will recursively process these keywords
or data as a separate file using the <literal>read</literal> routine. This is
useful for embedding commands in list oriented data.</para>

<para>See <xref linkend="calc-chap"/> for more details.</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>put</literal></term>
<listitem><para>The <literal>put</literal> routine, or any routine beginning
with <literal>put</literal> is used to output information concerning the object
to the textfile <literal>stdout</literal>.</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>read</literal></term>
<listitem><para>The <literal>read</literal> routine is used to input a sequence
of <quote>keywords</quote> from an input file. These keywords are then
interpreted using the <literal>process_input</literal> routine, which may cause
the input of additional data from the input file, or cause certain calculation
to be performed, or both.</para>

<para>In the case of array or list type objects, there are three special
keywords alwaqys recognised by the <literal>read</literal> routine:
<literal>list=</literal> and <literal>list_order=</literal>.</para>

<para>The form of the input style for data and the allowed keywords for any
module have been described respectively in <xref linkend="calc-chap"/>
and <xref linkend="keywords"/>.</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>read_data</literal></term>
<listitem><para>The <literal>read_data</literal> routine is used to input a
sequence of <quote>keywords</quote> for a list or vector type object. It is
always called from the <literal>read</literal> routine.</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>read_units</literal></term>
<listitem><para>This is an input routine which is used to set the default units
to something other than atomic units. <literal>read_units</literal> reads a
string from the input stream which it interprets as a new units symbol. The next
object that is inputted is assumed to be in these units; after the next object
has been inputted, the default units is returned back to the default atomic
units. It is always associated with the <literal>units=</literal>
keyword.</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>redirect; revert</literal></term>
<listitem><para>When the <literal>redirect</literal> routine is available and
called, the name of a new file is read from the <literal>stdin</literal> file,
and this file is opened and used as the new <literal>stdin</literal>. </para>

<para>When the <literal>revert</literal> routine is used, the
<literal>stdin</literal> reverts back to the original file.</para>

<para>These routines are quite similar to <literal>save</literal> and
<literal>unsave</literal> but they are used in the context of I/O
operations.</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>same_as; equals</literal></term>
<listitem><para>These routines test whether the object has the same data values
as another data object. The routines should be synonymous and provide a
generalisation of the <literal>==</literal> operation.</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>save; unsave</literal></term>
<listitem><para>When the <literal>save</literal> routine is available and
called, a new object is created and a pointer to the original object is saved as
a component of this new object. </para>

<para>The <literal>unsave</literal> routine will deallocate the new object and
then create an object with its original state. </para>

<para>These routines are useful for objects that can create new versions of
themselves from themselves.</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>set_defaults</literal></term>
<listitem><para>This routine is used to set certain default values for the
components of the data type described in the module. Default values may also be
set by explicit initialisation of the type components using the
<literal>DEFAULT</literal> or <literal>DEFAULT_NULL</literal> macros defined in
the <literal>macros</literal> file. (These latter macros are not available on
systems where the <literal>LANGUAGE_FORTRAN_90</literal> compile option has been
set due to unavailablity or problems with Fortran 95 compilers).</para>
</listitem>
</varlistentry>
</variablelist>

<variablelist>
<varlistentry>
<term><literal>set_to</literal></term>
<listitem><para>Assigns parts of the data object from other data types. For
pointer objects, copies are <emphasis>not</emphasis> made, but pointer
assignments are used.  This routine can be thought of as an alias for, or
generalisation of, the <literal>=</literal> operation.</para>
</listitem>
</varlistentry>
</variablelist>
</sect1>

<!-- *********************************************************************** -->

<sect1 id="customisability">
<title>Customisability and efficiency of &TONTO;</title>

<para>We recognise that certain tasks in computational chemistry are very time
consuming.</para>

<para>Therefore, we have designed &TONTO; so that different versions of the code
may easily be compiled. For example, one can easily generate highly optimised
versions, or versions with debugging and full error checking and memory
management by changing a few compile switched.</para>

<para>Likewise, the development process, involving the making of dependent files
and issues involving whether certain modules should, or should not be recompiled
has been automated. In this was the development process for code in &TONTO; can
be expected to be very efficient.</para>
</sect1>

<!-- *********************************************************************** -->

<sect1 id="communication">
<title>Communication and data storage in &TONTO;</title>

<para>It is extremely important to have a well defined but flexible way to write
input files, in order to facilitate data deposition and database construction.
Mining of databases for critical information will be a significant way in which
future scientific research will be conducted.</para>

<para>&TONTO; defines a standard database format for input and command
execution.</para>

<para>The format is built into the way modules access data. Because of its clear
definition, tools can easily be developed to read a general &TONTO; database
file.</para>

<para>The format is closely based on the CIF database format, except that the
&TONTO; data format allows nested lists of structures.</para>

<para>&TONTO; also uses the <literal>CVS</literal> revision contraol system, so
that multiple users at different sites can be developing the code at once. The
<literal>cvs</literal>  system is not descibed here, but those programmers
interested in it can contact us directly for access to the repository.</para>

</sect1>
</chapter>

<!-- *********************************************************************** -->
<!-- *********************************************************************** -->

<chapter id="customised-compilation">
<title>Compiling customised versions of &TONTO;</title>

<para>There are two distinct ways to customise &TONTO;: by altering compiler
flags, or by altering C-preprocessor macros.</para>

<para>If you are a programmer, or of you need to port &TONTO; to another
platform, you should read this chapter.</para>

<para>If you are a user, it still might be convenient to have several versions
of a &TONTO; program.  For example, you might might want one version which is
highly optimised, to be used for production calculations; and you might want
another version compiled with no optimisation and full memory management and
error checking turned on, to be used for code development or testing input
decks.</para>

<!-- *********************************************************************** -->

<sect1 id="customising">
<title>What can be customised, and what is the default?</title>

<para>By altering compile options, you can make versions with
<itemizedlist>
<listitem><para>high optimisation (this is the default)</para></listitem>
<listitem><para>high optimisation and profiling</para></listitem>
<listitem><para>no optimisation and debugging switches</para></listitem>
<listitem><para>different mathematical libraries</para></listitem>
<listitem><para>different compilers on the same platform</para></listitem>
</itemizedlist></para>

<para>By altering certain C-preprocessor macros you can make versions of &TONTO;
which will
<itemizedlist>
<listitem><para>Issue error messages labelled with their calling routine when
anticipated problems are detected (turned on by default)</para></listitem>
<listitem><para>Issue error messages labelled with their calling routine when
certain preconditions for executing a routine are not satisfied (turned off by
default).</para></listitem>
<listitem><para>Issue a full routine call-stack traceback when an error
condition is detected; and at the same time issue error messages when routines
contain unintentional memory leaks (turned off by default)</para></listitem>
<listitem><para>Generate a version of &TONTO; which reverts to Fortran90
language definitions (turned off when the compiler is Fortran95
compliant)</para></listitem>
<listitem><para>Generate a version of &TONTO; which does not use derived type
initialisation (turned off when the compiler is Fortran95
compliant)</para></listitem>
</itemizedlist></para>
</sect1>

<!-- *********************************************************************** -->

<sect1 id="compiler-options">
<title>Which Fortran compiler options to use?</title>

<para>To get &TONTO; to work on any platform, or to understand how to change it
to produce certain version for debugging or profiling, you need to decide what
compile options to use on the Fortran compiler that you have. In general these
changes are compiler specific, but there are usually compler options which
correspond to each other across platforms.</para>

<para>In all cases, you should alter the <literal>Makefile</literal> variables
<literal>FC</literal>, <literal>FOPTNS</literal>, <literal>FFLAGS</literal>,
<literal>FPROF</literal>, <literal>FDEBUG</literal>, <literal>FFAST</literal>,
<literal>FSUFFIX</literal>, <literal>PROGSUFFIX</literal>,
<literal>MODSUFFIX</literal>, <literal>OBJSUFFIX</literal>,
<literal>LIBS</literal>, and <literal>DEFS</literal>.  For example, here are the
values for the <literal>COMPAQ</literal> <command>f95</command> compiler on the
<literal>OSF1</literal> operating system. These options can be found in the
<literal>COMPAQ-f95-on-OSF1</literal> file in the <literal>site_config</literal>
directory.</para>

<programlisting>
FC       = f95
FOPTNS   = $(FFAST)
FFLAGS  := -cpp -module ./new_modules  \
           -I. -I./f90files -I./interfaces -I./modules -I./objects
FPROF   := -p -g3 -gen_feedback
FDEBUG  := -g -ladebug -check bounds -check format -check overflow \
           -warn argument_checking -warn declarations -warn unused \
           -warn truncated_source -error_limit 10 -std
FFAST   := -g0 -O4 -arch host -align dcommons -assume noaccuracy_sensitive \
           -pipeline -unroll 8 -threads -speculate by_routine -transform_loops
FSUFFIX := f90
 
LIBS    := -lcxml
DEFS    := -DCOMPAQ -DUSE_ERROR_MANAGEMENT
</programlisting>

<para>The meaning of each of these variables is now discussed.</para>

<sect2 id="FC">
<title>The <literal>FC</literal> variable</title>

<para>The variable <literal>FC</literal> is set to the command for the Fortran95
compiler on your machine,
<programlisting>
FC       = f95
</programlisting>
It consists of the <literal>FC</literal> variable, followed by the assignment
operator <literal>=</literal>, and then command <literal>f95</literal>, which is
the name of the Fortran95 compiler to use.  If you don't know what this command
is, try typing
<programlisting>
man -k fortran
</programlisting>
</para>
</sect2>

<sect2 id="FOPTNS">
<title>The <literal>FOPTNS</literal> variable</title>

<para>The <literal>FOPTNS</literal> variable is not set to have any specific
compiler optionsr; instead, it is is set to be equal to one of three other
variables, as shown by the three possibile the lines below:
<programlisting>
FOPTNS   = $(FFAST)
FOPTNS   = $(FDEBUG)
FOPTNS   = $(FFAST) $(FPROF)
</programlisting>
Which one you choose depends on the type of executable that you want to
generate.  If set to <literal>$(FFAST)</literal> then the options used will be
those for producing the optimal executable for &TONTO;. If set to
<literal>$(FDEBUG)</literal> the options used will be those appropriate for
using &TONTO; in a debugger, and will usually involve no optimisation at all. If
set to <literal>$(FFAST) $(FPROF)</literal> then the executable generated will
be appropriate for profiling using a profiling tools, to see where the
bottlenecks in exdecutaion speed will occur.</para>

<para>The complie options to set for the variables <literal>FFAST</literal>,
<literal>FDEBUG</literal> and <literal>FPROF</literal> are described
below.</para>

</sect2>

<sect2 id="FFLAGS">
<title>The <literal>FFLAGS</literal> variable</title>

<para>The <literal>FFLAGS</literal> variable must be set to the basic option
flags that are needed to compile &TONTO; which are common to all
compilations.For example,
<programlisting>
FFLAGS  := -cpp -module ./new_modules  \
           -I. -I./f90files -I./interfaces -I./modules -I./objects
</programlisting>
This line consists of the <literal>FFLAGS</literal> variable, followed by an
assignment operator, <literal>:=</literal>, followed by the list of standard
options which the compiler is to use.  The <literal>\</literal> character at the
end of the first two lines means that the line following the
<literal>\</literal> character should be joined onto the first, as if the
<literal>\</literal> character was not there, as if there were only one line in
all. It is useful for splitting up long lines.</para>

<para>To get &TONTO; to compile and work, Fortran compiler options must be found
for the tasks described below, and they must replace or substitute for all the
options to the right of the <literal>FFLAGS</literal> variable assignment in the
example above.
<itemizedlist>
<listitem><para>All the module files from the compilation (they will usually be
files which end in a <literal>.mod</literal> suffix) must be deposited in the
module subdirectory, <literal>./module</literal>. In the above example, this
is achieved by the compiler flags:
<programlisting>
   -module ./module
</programlisting></para></listitem>
<listitem><para>The compiler must know where Fortran95 files, module information
files, and object files reside during intermediate stages of compilation.  In
the example above, this is given by (respectively) the options
<programlisting>
   -I./f90files -I./modules -I./objects
</programlisting></para></listitem>
<listitem><para>The Fortran code must be preprocessed using the C preprocessor
before being compiled by the Fortran compiler. In the example above this was
achieved by the compiler option
<programlisting>
   -cpp
</programlisting>
Furthermore, the C preprocessor must be given the names of certain
directories that it needs, in order to include the appropriate files.
In the example above this is achieved by the following compiler options,
<programlisting>
   -I. -I./interfaces
</programlisting>
</para></listitem>
</itemizedlist>
</para>

</sect2>

<sect2 id="FFAST">
<title>The <literal>FFAST</literal> variable</title>

<para>The <literal>FFAST</literal> variable must be set to the options flags
that are needed to compile &TONTO; with as high a degree of optimisation as is
reasonably possible. For example,
<programlisting>
FFAST   := -g0 -O4 -arch host -align dcommons -assume noaccuracy_sensitive \
           -pipeline -unroll 8 -threads -speculate by_routine -transform_loops
</programlisting>
In this case, the <literal>-g0</literal> option indicates that no debugging
information is to be used.  The <literal>-O4</literal> indicates that
optimisation level 4 is to be used, which is the highest appropriate for
intra-module optimisation on the COMPAQ compiler. SImilar options will be
available on other compilers.</para>

<para>Other options which may not appear on other compilers are:
<itemizedlist>
<listitem><para>The <literal>-arch host</literal>  option, which produces code
optimal for the particular COMPAQ chip the compiler is working on.
</para></listitem>
<listitem><para>The <literal>-align dcommons</literal> option, which places
variables on appropriate bit boundaries to allow faster memory
access</para></listitem>
<listitem><para>The <literal>-assume noaccuracy_sensitive</literal> which allows
mathematically equivalent transformations of the code to speed
execuation.</para></listitem>
<listitem><para>The <literal>-pipeline</literal> option which allows a form of
software pipelining to speed execution</para></listitem>
<listitem><para>The <literal>-unroll 8</literal> option which separates loops
into blocks of 8, to allow effeicient use of cache memory</para></listitem>
<listitem><para>The <literal>-threads</literal> which allows some form of
parallelisation</para></listitem>
<listitem><para>The <literal>-speculate by_routine</literal> which allows the
compiler to inline certain routines which it feels may enhance
optimisation</para></listitem>
<listitem><para>The <literal>-transform_loops</literal> options which rearranges
loop orders if it will lead to better memory access and hence better
performance.</para></listitem>
</itemizedlist>
</para>

</sect2>

<sect2 id="FDEBUG">
<title>The <literal>FDEBUG</literal> variable</title>

<para>The <literal>FDEBUG</literal> variable must be set to the options flags
that are needed to compile &TONTO; so that it works with a debugger and so that
appropriate warnings are issued for unusual or non-conformant code. This is
recommended for developers.
<programlisting>
FDEBUG  := -g -ladebug -check bounds -check format -check overflow \
           -warn argument_checking -warn declarations -warn unused \
           -warn truncated_source -error_limit 10 -std
</programlisting>
In this case, the <literal>-g</literal> option indicates that full debugging
information is to be used.  Sometimes, the <literal>-O0</literal> option may
also need to be specified to indicate that there is to be no optimisation used.
(In this case, it is assumed as the default). </para>

<para>The options which may be compiler specific are:
<itemizedlist>
<listitem><para>The <literal>-ladebug</literal> option, which indicates that
specific debugging information needed for the COMPAQ <literal>ladebug</literal>
debugger is to be generated.</para></listitem>
<listitem><para>The <literal>-check bounds</literal> argument, which checks if
array bounds have been exceeded.  This may severely affect performance, but it
is recommended fir developers</para></listitem>
<listitem><para>The <literal>-check format</literal> option which checks for
formatting errors</para></listitem>
<listitem><para>The <literal>-check overflow</literal> option, which prints
information on the type of incorrect operation that was attampted (e.g.
divide-by-zero, or exponentiation of too large or too small an
exponent)</para></listitem>
<listitem><para>The <literal>-warn argument_checking</literal> which informs if
incorrect types are passed to certain subroutines. This should only be necessary
for non &TONTO; code since argument checking is gauranteed by the Fortran 90
standard.</para></listitem>
<listitem><para>The <literal>-warn declarations</literal> and <literal>-warn
unused </literal> which warns if there are incorrect declarations or any usused
variables</para></listitem>
<listitem><para>The <literal>-warn truncated_source</literal> which warns if
there are any lines which have been truncated with remaining characters. This is
very useful for &TONTO; because sometimes the preprocessor can generate lines
which are excessively long.</para></listitem>
<listitem><para>The <literal>-error_limit 10</literal> option which limits the
number of errors to a manageable number, 10.</para></listitem>
<listitem><para>The <literal>-std</literal> options which forces the compiler to
accept only standard Fortran95 syntax</para></listitem>
</itemizedlist>
</para>

</sect2>

<sect2 id="FPROF">
<title>The <literal>FPROF</literal> variable</title>

<para>The <literal>FPROF</literal> variable is set to the compiler options
needed to perform profiling tests on &TONTO; programs. That is, tests which
examine the speed of execution of various routines in &TONTO;.  Profiling tests
are often done in conjunction with the highest levels of optimisation (it
doesn't make sense to check the speed of an unoptimised program).</para>

<para>For the COMPAQ compiler, the following options are required
<programlisting>
FPROF   := -p -g3 -gen_feedback
</programlisting>
The <literal>-p</literal> indicates profiling options should be turned on. The
<literal>-g3</literal> indicates a high level of debugging information is to be
included with the executable.  The <literal>-gen_feedback</literal> indicates
that a statistics file is to be generated at the time of execuation, which can
be later analysed by a profiling tool.</para>

</sect2>

<sect2 id="FSUFFIX">
<title>The <literal>FSUFFIX</literal> variable</title>
<para>This is set to the suffix used to indicate a Fortran90 or Fortran95
program to your compiler. Typically, it will be
<programlisting>
FSUFFIX := f90
</programlisting>
Although other common possibilities are <literal>.F90</literal>,
<literal>.f95</literal> or <literal>.F95</literal>.  The default is
<literal>.F90</literal>.  Note that unix is case-sensitive for filenames.</para>
<para>It is important to note that on some systems, the type of suffix
determines whether the C-preprocessor is executed.</para>
</sect2>

<sect2 id="PROGSUFFIX">
<title>The <literal>PROGSUFFIX</literal> variable</title>
<para>This is set to the suffix used to indicate an executable program to your
compiler.  The default is
<programlisting>
PROGSUFFIX := exe
</programlisting>
if none is specified.  Note that unix is case-sensitive for filenames.</para>
</sect2>

<sect2 id="MODSUFFIX">
<title>The <literal>MODSUFFIX</literal> variable</title>
<para>This is set to the suffix used for module information files by your
compiler.  It is by the makefile while building the program.  The default is
<programlisting>
MODSUFFIX := mod
</programlisting>
if none is specified.  Other possibilities include <literal>.d</literal> and
<literal>.vo</literal>.  Note that unix is case-sensitive for filenames.</para>
</sect2>

<sect2 id="OBJSUFFIX">
<title>The <literal>OBJSUFFIX</literal> variable</title>
<para>This is set to the suffix used for object files used by your compiler.
The default is
<programlisting>
OBJSUFFIX := o
</programlisting>
if none is specified.  A common possibility on the Windows platform is
<literal>.obj</literal>.  Note that unix is case-sensitive for filenames.</para>
</sect2>

<sect2 id="LIBS">
<title>The <literal>LIBS</literal> variable</title>

<para>The <literal>LIBS</literal> variable is set so that the compiler can use
the BLAS and LAPACK libraries.  On the COMPAQ system these are bundled together
in the <literal>libcxml</literal> library, which is included by the line
<programlisting>
LIBS  := -lcxml
</programlisting>
Other common possibilities may be
<programlisting>
LIBS  := -llapack -lblas
</programlisting>
or
<programlisting>
LIBS  := -L /usr/lib/gcc-lib/i386-redhat-linux/2.96 -lg2c -llapack -lblas
</programlisting>
The above lines are what you would use if you compile and install the freely
available BLAS and LAPACK libraries with your own compiler. The procedure for
doing this is described in a separate section.</para>

</sect2>

<sect2 id="MODCASE">
<title>The <literal>MODCASE</literal> variable</title>
<para>This is to tell the Makefile whether the module names get converted to
uppercase or lowercase when outputting module information files.
The default is
<programlisting>
MODCASE := -lc
</programlisting>
if none is specified.  The other alternative is <literal>-uc</literal> to
specify conversion to uppercase.</para>
</sect2>

<sect2 id="DEFS">
<title>The <literal>DEFS</literal> variable</title>

<para>The <literal>DEFS</literal> variable is set to enable any machine specific
commands in the fortran code, via the C-preprocessor. On the COMPAQ machine, we
have
<programlisting>
DEFS    := -DCOMPAQ -DUSE_ERROR_MANAGEMENT
</programlisting>
Here, the <literal>-DCOMPAQ</literal> indicates that any C-processor directives
which apply to the <literal>COMPAQ</literal> switch are to be activated. The
<literal>-DUSE_ERROR_MANAGEMENT</literal> instructs the C-preprocessor to use
code appropriate for generating an error-managed executable.  You can also
generate version which check for memory leaks, and test preconditions are
postconditions to a routine. These possibilities are discussed in
<xref linkend="customised-compilation"/>.</para>

</sect2>
</sect1>

<!-- *********************************************************************** -->

<sect1 id="c-preprocessor">
<title>Which C-preprocessor options to use?</title>

<para>In addition to different compiler-switch versions, you can generate
versions of &TONTO; which will
<itemizedlist>
<listitem><para>Issue minimal error messages when anticipated problems are
detected</para></listitem>
<listitem><para>Issue error messages when certain preconditions for executing a
subroutine are not satisfied, so that it becomes impossible for the subroutine
to complete its task</para></listitem>
<listitem><para>Issue a full call-stack traceback when an error condition is
detected <footnote><para>This is only available for routines which are not pure
according to the fortran definition; pure routines are not allowed to have any
I/O operations embedded within them, including I/O operations which issue error
messages</para></footnote>.</para></listitem>
<listitem><para>Generate a version of &TONTO; which reverts to Fortran90
language definitions</para></listitem>
<listitem><para>Issue error messages when certain routines contain unintentional
memory leaks</para></listitem>
</itemizedlist>
</para>

<para>The following sections describe how to compile &TONTO; so that these
additional features become available.</para>

<para>All these options are controlled by C-preprocessor directives which appear
in the <literal>macros</literal> file; the features can be turned on or off
independently.</para>

<informalexample>
<para>Note that you must recompile &TONTO; if any of the features described in
the section are to be activated</para>
</informalexample>

<sect2 id="use-error-management">
<title>The <literal>USE_ERROR_MANAGEMENT</literal> switch</title>

<para>Error checking in &TONTO; is achieved using C preprocessor macros
which stand for calls to certain routines in the &TONTO; system.</para>

<para>To remove this facility, delete the
<literal>-DUSE_ERROR_MANAGEMENT</literal> switch in the Makefile near the top,
e.g.
<programlisting>
DEFS    := -DCOMPAQ -DUSE_ERROR_MANAGEMENT
</programlisting>
</para>

<para>The way this switch works is as follows:</para>

<para>In the <literal>macros</literal> file, a test is done to establish if the
<literal>USE_ERROR_MANAGEMENT</literal> switch has been defined by the
preprocessor (for example, because it has been set as a compile switch in ther
<literal>Makefile</literal> as above). If this switch is defined, other macros
<literal>DIE</literal>, <literal>WARN</literal>, <literal>DIE_IF</literal>, and
<literal>WARN_IF</literal> are defined to be calls to certain Fortran
subroutines which issue the required warnings.</para>

<para>It is not recommended that you remove this switch, as it does not affect
performance greatly.</para>

<para>Once the change has been made, you will have to recompile &TONTO; for that
change to take effect.</para>

</sect2>

<sect2 id="use-pre-and-post-conditions">
<title>The <literal>USE_PRE_AND_POST_CONDITIONS</literal> switch</title>

<para>This switch is turned off by default.</para>

<para>To include precondition and postcondition facilities, add the
<literal>-DUSE_PRE_AND_POST_CONDITIONS</literal> macros to the
<literal>DEFS</literal> variable in the Makefile, e.g.
<programlisting>
DEFS    := -DCOMPAQ -DUSE_PRE_AND_POST_CONDITIONS
</programlisting>
</para>

<para>Note that enabling the <literal>USE_CALL_STACK_MANAGEMENT</literal> switch
automatically turns on the <literal>USE_ERROR_MANAGEMENT</literal>
switch.</para>

<para>Note that using this switch can lead to significant performance
degradation (say up to 30% in execuation time).</para>

<para>The way this switch works is as follows:</para>

<para>In the <literal>macros</literal> file, a test is done to establish if the
above <literal>USE_PRE_AND_POSTCONDITIONS</literal> switch has been defined by
the preprocessor (for example, because it has been set as a compile switch in
the <literal>Makefile</literal>, as above). If it is defined, other macros
<literal>ENSURE</literal> and <literal>VERIFY</literal> are defined to be calls
to certain Fortran subroutines which issue the required warnings.</para>

</sect2>

<sect2 id="use-call-stack-management">
<title>The <literal>USE_CALL_STACK_MANAGEMENT</literal> switch</title>

<para>This switch is turned off by default.</para>

<para>To include precondition and postcondition facilities, add the
<literal>-DUSE_CALL_STACK_MANAGEMENT</literal> switch to the
<literal>DEFS</literal> variable in the Makefile, e.g.
<programlisting>
DEFS    := -DCOMPAQ -DUSE_CALL_STACK_MANAGEMENT
</programlisting>
</para>

<para>Using this switch not only produces a calling stack whenever an error is
generated, but it also turns on memory management facilities and pre and post
condition checking. The memory management facility will issue a warning whenever
the routine exits with a memory leak --- unless the routine is explicitly marked
<literal>[leaky]</literal> on its definition line. For further information on
<literal>[leaky]</literal>, look in <xref linkend="foo-chap"/>.</para>

<para>Note that using this switch can lead to significant performance
degradation (up to 30% in execution time).</para>

</sect2>

<sect2 id="language-fortran-90">
<title>The <literal>LANGUAGE_FORTRAN_90</literal> switch</title>

<para>This switch is turned off by default for Fortran95 compliant
compilers.</para>

<para>If you want to set the Fortran language level to Fortran90 (if it is not
already set) simply add the <literal>-DLANGUAGE_FORTRAN_90</literal> switch to
the definition of the <literal>DEFS</literal> variable in the
<literal>Makefile</literal>, e.g.
<programlisting>
DEFS    := -DCOMPAQ -DLANGUAGE_FORTRAN_90
</programlisting>
</para>

<para>The way this works is as follows:</para>

<para>The <literal>pure</literal> and <literal>elemental</literal> keywords are
usually conditionally compiled in the &TONTO; system, using C preprocessor
macros <literal>PURE</literal>  and <literal>ELEMENTAL</literal>. There are also
macros <literal>ALWAYS_PURE</literal> and <literal>ALWAYS_ELEMENTAL</literal>.
These are required because some routines must always be pure or elemental---for
example if they appear in the initialization of variables in a declaration line.
(In this case, programmers should note that separate definition lines should be
used when the language level is reduced to Fortran90). Note that, if the &foo;
preprocessor is being used the <literal>pure</literal>,
<literal>elemental</literal>, <literal>always_pure</literal>, and
<literal>always_elemental</literal> attributes of a routine are activated by
square brakets on the routine declaration line.  For further detailes, refer to
the chapter describing the &foo; preprocessor.</para>

</sect2>

<sect2 id="broken-type-initialization">
<title>The <literal>BROKEN_TYPE_INITIALIZATION</literal> switch</title>

<para>Unfortunately it seems to be quite common that many Fortran95 compilers
cannot correctly cope with derived type initialization.</para>

<para>Derived type initialization can be switched off via the
<literal>BROKEN_TYPE_INITIALIZATION</literal> switch,
<programlisting>
DEFS    := -DCOMPAQ -DBROKEN_TYPE_INITIALIZATION
</programlisting>
</para>

<para>This switch is automatically activated when the
<literal>LANGUAGE_FORTRAN_90</literal> switch is set, since type initialization
is a Fortran95 feature.</para>

</sect2>
</sect1>
</chapter>

<!-- *********************************************************************** -->
<!-- *********************************************************************** -->

<chapter id="building-executables">
<title>How &TONTO; builds executables</title>

<para>This section is for programmers who want to understand how the &TONTO;
system builds executables using <literal>perl -w Makefile.pl</literal> and then
the <literal>make</literal> program. </para>

<para>In particular, how &TONTO; deals with machine dependencies, and how it
avoids unnecessary recompilation.</para>

<!-- *********************************************************************** -->

<sect1 id="make">
<title>The make program and the Makefile</title>

<para><literal>make</literal> is a program that controls how a program is
compiled.</para>

<para>The <literal>Makefile</literal> is a database used by the
<literal>make</literal> program to provide the instructions to compile
&TONTO;.</para>

<para>The <literal>Makefile</literal> is comprised of the following important
sections:
<itemizedlist>
<listitem><para>A part defining the machine specific compilation options to be
used, and where the executable is to be installed.</para>

<para>---This part is changed by the <literal>Makefile.pl</literal> program as
detailed in the next section.</para>

<para>---This part is the part that is changed by hand to make customised
versions of &TONTO;.</para></listitem>

<listitem><para>A part defining where the all the required files are located;
that is, the locations of the <quote><literal>foo</literal></quote> source code,
fortran code, fortran interface files, object code, module files, dependency
files, documentation directories, and compile scripts.  The directories which
contain all these files are easily identified.</para>

<para>---These names of these directories are never altered.</para></listitem>

<listitem><para>A part listing the object files in hierarchical module order;
that is, arranged in an order such that the objects which use other objects come
later in the ordered list.</para>

<para>---You will only need to modify hierarchical object files if you are
writing a new module.  If you want to do this you should refer to 
<xref linkend="fortran-modules"/> or to <xref
linkend="foo-modules"/>.</para></listitem>

<listitem><para>A part which includes a <literal>dependfile</literal> containing
the dependencies of each of the listed object files. These dependencies are
found in the <literal>dependencies</literal> directory, and are make by the
<literal>make_dependencies.perl</literal> script.</para>

<para>---You will only need to modify the <literal>dependfile</literal> file if
you are writing a Fortran module. If you are writing a &foo; module, which is
the recommended procedure, then this is done automatically.</para></listitem>

<listitem><para>A part describing how to make the dependency files, fortran,
html documentation, object, module, and executable files.</para>

<para>---This section makes use of <command>make</command> <quote>pattern
rules</quote>. You should not need to alter this section unless your compiler
makes unusual files which need to be included.  For example, the
<literal>SGI</literal> compiler produces module files with capitalised
names.</para></listitem>
</itemizedlist>
</para>
</sect1>

<!-- *********************************************************************** -->

<sect1 id="code-portability">
<title>Machine specific code in &TONTO;</title>

<para>When generating code which can be used on many platforms, invariably there
are pieces of code which are needed only on certain platforms and not others.
For example, compiler options, which are contained in a
<literal>Makefile</literal> are specific to a platform.</para>

<para>&TONTO; uses a perl script <literal>Makefile.pl</literal> to generate
machine specfic files such as <literal>Makefiles</literal>. It also uses the C
preprocessor to make sure certain lines of code are compiled only for certain
machines.</para>

<para>This is the way it works:</para>

<para>In the top directory are files <literal>Makefile.pl</literal> and
<literal>Makefile.in</literal>. When you type <literal>perl -w
Makefile.pl</literal>, the perl script <literal>Makefile.pl</literal> is
executed to determine what kind of operating system you have, what kind of
compiler, and if everything you need to make &TONTO; is available. </para>

<para>Once this information is known, <literal>Makefile.pl</literal> decides the
correct <literal>site_config</literal> file to use by looking in the directory
<literal>site_config</literal> which contains a series of files for machine
specific compile options. <literal>Makefile.pl</literal> then includes the
appropriate machine specific compile-option file, and any other machine specific
information it knows about, into the generic template
<literal>Makefile.in</literal> to make the correct
<literal>Makefile</literal>.</para>

</sect1>

<!-- *********************************************************************** -->

<sect1 id="make-dependencies">
<title>Code dependencies in &TONTO;</title>

<para>It is often the case that when a certain program file is compiled, other
<emphasis>dependent</emphasis> files must also be compiled.</para>

<para>There are two ways to tell <command>make</command> about dependencies;
either hard code them into the makefile or an included file, or have a script
automatically extract them from the source code.  &TONTO; uses the latter
method.</para>

<para>The <command>perl</command> script
<command>make_dependencies.perl</command> extracts all the
<literal>USE</literal> statements out of the source files, to build a dependency
list. (Note however that the script does not look at <literal>#include</literal>
statements.) These are then concatenated together to form a single file
containing all <literal>USE</literal> dependencies, which is then
<literal>include</literal>-ed in the <literal>Makefile</literal>.  Also, &TONTO;
makes use of a <literal>make</literal> pattern rules to summarise the common
mode of compilation for all its modules.</para>

<para>In the stylised example  below the source, object, script and module
information files have all been separated into their own directories; this
makies it tidy for large projects.  The <literal>VPATH</literal> variable in the
<literal>Makefile</literal> tells <literal>make</literal> to search in these
separate directories for dependencies.</para>

<informalexample>
<para>Say we have modules <literal>a</literal>, <literal>b</literal>,
<literal>c</literal> which are used to construct program <literal>z</literal>,
and <literal>b</literal> uses <literal>a</literal>, <literal>c</literal> uses
<literal>b</literal>, and <literal>z</literal> uses <literal>c</literal>. (i.e.
a simple linear hierarchy). Also presume each module resides in its own
file.</para>

<para>Normally in the Makefile, we just have
<programlisting>
b.o : a.o
c.o : b.o
z.x : a.o b.o c.o
</programlisting>
where <literal>z.x</literal> is the executable, and the <literal>.o</literal>
files are the object files.</para>

<para>In our Makefiles, we have
<programlisting>
b.o : a.mod
c.o : b.mod
a.mod :
    make a.o
b.mod :
    make b.o
z.x : a.o b.o c.o
</programlisting>
where <literal>z.x</literal> is the executable, and the <literal>.o</literal>
files are the object files, and the <literal>.mod</literal> files are the module
information files.</para>

<para>If the interface to module <literal>b</literal> stays constant, then
modules <literal>a</literal> and <literal>c</literal> do not need recompiling,
and only module <literal>b</literal> and program <literal>z</literal> need
recompiling.</para>

<para>If the interface to module <literal>b</literal> changes, then module
<literal>a</literal> does not need recompiling, and modules <literal>b</literal>
and <literal>c</literal> and program <literal>z</literal> need
recompiling.</para>
</informalexample>
</sect1>

<!-- *********************************************************************** -->

<sect1 id="module-recompilation">
<title>The problem of unnecessary recompilation of Fortran90 modules</title>

<para>A problem with the current use of modules in Fortran90 is the unnecessary
recompilation of dependent files when the interface has not changed.</para>

<para>If the interface to a module is not changed, and there are no inter-module
optimisations, then there is no logical reason why other modules that depend on
this module need recompiling. Compilers of today however do not allow for this,
as they replace a module information file even if it's contents have not
changed. To make matters worse, some compilers insert the compilation date into
the module information file, and often this can be the only change made to that
file.</para>

<sect2>
<title><literal>make</literal> and the recompilation strategy used in
&TONTO;</title>

<para>The <literal>make</literal> command uses file time stamps to determine
whether dependencies need recompiling. </para>

<para>To solve the problem of unchanging, or hardly changing module files, what
we need to do is use the old time stamp if an updated module information file is
the same as the old one. In this way, <literal>make</literal> will determine
that the module file has not been changed and will not recompile any
dependents.</para>

</sect2>
</sect1>
</chapter>

<!-- *********************************************************************** -->
<!-- *********************************************************************** -->

<chapter id="tech-input">
<title>The &TONTO; input file: technical specification</title>

<para>The &TONTO; input file serves the dual purpose of being a database style
specification, and a command language interface.</para>

<para>The input file itself is a sequence of characters written in a certain
way, according to certain <emphasis>grammar rules</emphasis>.  In order to
explain these grammar rules, a Backus-Naur notation is first introduced. The
specification is given in this notation.</para>

<para>Programmers who write new modules should stick to the input format
described</para>

<para>The ideas for the input file described here are similar to the STAR (Self
defining Text Archive) format already used and standardised in crystallographic
databases.</para>

<para>It is extremely important to have a well defined but flexible way to
write input files, in order to facilitate data deposition and database
construction.  Mining of databases for critical information will be a
significant way in which future scientific research will be conducted.</para>

<!-- *********************************************************************** -->

<sect1 id="input-rules">
<title>Rules to explain the rules for writing input file</title>

<para>An input file is made up of a sequence of <emphasis>grammar
elements</emphasis>.  Grammar elements are represented in uppercase type-font,
possibly followed by a comma separated list of other grammar elements all
surrounded by round brackets, <literal>LIKE-THIS</literal>, or
<literal>THIS(2,3)</literal>, or <literal>EVEN(LIKE,THIS)</literal>.  A grammar
element does not stand for itself, literally, but for a specific sequence of
characters. The exact sequence of characters is given after an arrow symbol.
Thus:
<programlisting>
ZERO     -> 0
GREETING -> hi 
MY-NAME  -> dylan
</programlisting>
means that the grammar element <literal>ZERO</literal> stands for the digit
<literal>0</literal>, while grammar elements <literal>GREETING</literal> and
<literal>MY-NAME</literal> stand for the characters <literal>hi</literal> and
<literal>dylan</literal>, respectively.  Here, <literal>0</literal> and
<literal>hi</literal> and <literal>dylan</literal> stand literally for
themselves, and not any other group of characters. Except for the special
characters discussed below, literal text will be always represented in
lowercase.</para>

<para>Although it is possible to use uppercase characters in an input file, we
shall not do so here to avoid confusion with the uppercase grammar element
symbols. Uppercase characters in the input file are equivalent to lower case
characters, unless surrounded by a double quote characters. </para>

<para>Grammar elements can be composed of a number of alternatives.  The
different possibilities are separated by a <literal>|</literal> symbol. Thus:
<programlisting>
POSITIVE-DIGITS -> 1|2|3|4|5|6|7|8|9
</programlisting>
represents all the symbols <literal>1</literal> to <literal>9</literal>,
inclusive. </para>

<para>Sometimes, to save typing, we will use the ellipsis,
<literal>...</literal>, to indicate an obvious range of characters. For example,
in the previous example, we might type
<programlisting>
POSITIVE-DIGITS -> 1| ... |9
</programlisting>
</para>

<para>Grammar elements can be composed of concatenations of characters.  The
characters to be concatenated are enclosed by curly brackets,
<literal>&lcub;</literal> and <literal>&rcub;</literal> and are followed
immediately by a descriptor. Thus:
<programlisting>
MANY-X -> &lcub;x&rcub;*
</programlisting>
stands for any number of the letter <literal>x</literal> concatenated together,
including none at all. For example <literal>MANY-X</literal> represents
<literal>xxxxx</literal>.  Similarly
<programlisting>
AT-LEAST-ONE-X -> &lcub;x&rcub;+
</programlisting>
stands for <literal>xxxxx</literal>, but it does not stand for zero
<literal>x</literal> characters.  Finally,
<programlisting>
TRIPLE-X -> &lcub;x&rcub;3
</programlisting>
stands for three <literal>x</literal> characters in succession,
<literal>xxx</literal>. Note that a curly bracket which is not matched, or not
followed by a descriptor just stands for itself. (Sorry about the confusion, we
should really be using a different font for these syntax elements).</para>

<para>Grammar elements can be composed of optional strings of characters.  The
optional characters are enclosed in square brackets <literal>[</literal> and
<literal>]</literal>.  Thus
<programlisting>
TO-BE -> to be [or not to be]
</programlisting>
says that <literal>TO-BE</literal> stands either for <literal>to be</literal>,
or <literal>to be or not to be</literal>.</para>

<para>Grammar elements can be composed of other grammar elements, like this:
<programlisting>
SELF-GREETING -> GREETING MY-NAME
</programlisting>
Note that blank spaces are always significant. The blank spaces before
<literal>GREETING</literal>, between <literal>GREETING</literal> and
<literal>MY-NAME</literal>, and after <literal>MY-NAME</literal> do not stand
for themselves, literally, but it instead stand for
<literal>WHITESPACE</literal>.  <literal>WHITESPACE</literal> is any combination
of: blank spaces; end-of-line characters; or, comment characters
(<literal>!</literal>, and <literal>#</literal>) and all the characters
inclusive to the end of line.  Thus, <literal>SELF-GREETING</literal> represents
<programlisting>
   hi        dylan
</programlisting>
and also
<programlisting>
hi 
dylan
</programlisting>
and even
<programlisting>
hi      ! this is a greeting
dylan   ! this is my name
</programlisting>
In the above, the characters following the exclamation mark are treated as
<literal>WHITESPACE</literal>, and hence ignored, because the exclamation mark
is a comment character. Since <literal>WHITESPACE</literal> is quite
complicated, but effectively just means a blank character or its equivalents, we
represent it just as a blank character, for simplicity. The proper definition of
it is:
<programlisting>
WHITESPACE      -> &lcub;WHITESPACE-CHAR&rcub;+
WHITESPACE-CHAR -> BLANK-CHAR |END-OF-LINE-CHAR | COMMENT
COMMENT         -> COMMENT-CHAR &lcub;^END-OF-LINE-CHAR&rcub;* END-OF-LINE-CHAR
COMMENT-CHAR    -> !|#
</programlisting>
In the above, the symbol <literal>^END-OF-LINE</literal> represents any
character which is not the <literal>END-OF-LINE-CHAR</literal> character.
<literal>BLANK-CHAR</literal> is, of course the blank character, which we have
to represent by <literal>BLANK-CHAR</literal>, since we have agreed a literal
blank character means <literal>WHITESPACE</literal>.  The default
<literal>COMMENT-CHAR</literal> characters shown above are defined in the
<literal>macros</literal> file in a variable <literal>COMMENT-CHARS</literal>,
and they may be changed when the program is compiled.</para>
</sect1>

<!-- *********************************************************************** -->

<sect1 id="input-data">
<title>The input file: <literal>KEYWORD</literal> and
<literal>DATA</literal></title>

<para>A <emphasis>module</emphasis> with name <literal>MODULE</literal>
describes a particular kind of data or collection of data, and also the
operations that can be performed on this data.  An allowed sequence of
operations on this data can be performed by writing and compiling a program
which uses the data and routines in that module.</para>

<para>Alternatively, a program can be written for every module which reads
instructions and data from a text file called
an <emphasis>input file</emphasis>. 
Desired operations on the data described by the module
are then carried out by specifying appropriate instructions
in the input file. <footnote><para>The input file is therefore a simple kind of
program to use the module.  Ideally, there would be no difference between a
program which uses a module, and the input file which uses the module, but this
is not possible, but it is something which we have tried to achieve, since it is
an important part of the goal to make &TONTO; simple to
use.</para></footnote></para>

<para>The input file required by any module <literal>MODULE</literal> is an
alternating sequence of valid keywords for that module, followed by valid data,
if data is required. This is alternating keyword-data pattern is represented by
the grammar element <literal>KEYWORD-DATA(MODULE)</literal>:
<programlisting>
KEYWORD-DATA(MODULE) -> &lcub; KEYWORD(MODULE,1) DATA(MODULE,1) 
                          KEYWORD(MODULE,2) DATA(MODULE,2) ... &rcub;

KEYWORD(MODULE,K) -> TASK-KEYWORD(MODULE)|DATA-KEYWORD(MODULE)
DATA(MODULE,K)    -> DATA|NULL

K -> POSITIVE-INTEGER

TASK-KEYWORD(MODULE) -> STR
DATA-KEYWORD(MODULE) -> STR

POSITIVE-INTEGER -> POSITIVE-DIGIT&lcub;DIGIT&rcub;*
POSITIVE-DIGIT   -> 1|...|9
DIGIT            -> 0|...|9
</programlisting>
A <literal>DATA-KEYWORD(MODULE)</literal> for a particular
<literal>MODULE</literal> is used to input data into a particular type for later
tasks or calculations. A <literal>DATA-KEYWORD(MODULE)</literal> is always
followed by <literal>DATA</literal>.</para>

<para>A <literal>TASK-KEYWORD(MODULE)</literal> is used to invoke a specific
task or calculation.  The <literal>TASK-KEYWORD(MODULE)</literal> will usually
corresponds to a routine in the module with the exactly the same name. The
documentation for this routine will also be the documentation for the
corresponding <literal>TASK-KEYWORD</literal>.  A
<literal>TASK-KEYWORD(MODULE)</literal> may be followed by
<literal>DATA(MODULE)</literal>, or nothing, <literal>NULL</literal>.  If
followed by <literal>DATA</literal>, the <literal>DATA</literal> will be used to
perform the particular task, or routine in question. </para>

<para>A <literal>KEYWORD(MODULE)</literal> is always a string,
<literal>STR</literal>, whose definition appears below.  The list of allowed
<literal>DATA-KEYWORD(MODULE)</literal>'s and <literal>TASK-KEYWORD</literal>'s
for any module can be found in the documentation for that module.</para>

<para>On the other hand, there are kinds of <literal>DATA</literal>:</para>

<para><literal>DATA ->
SIMPLE-DATA|SIMPLE-ARRAY-DATA|DERIVED-DATA</literal></para>
</sect1>

<!-- *********************************************************************** -->

<sect1 id="simple-data">
<title><literal>SIMPLE-DATA</literal></title>

<para>There are five kinds of <literal>SIMPLE-DATA</literal>,</para>

<para><literal>SIMPLE-DATA -> STR|BIN|INT|REAL|CPX</literal></para>

<para>These <literal>SIMPLE-DATA</literal> correspond to the five basic types in
Fortran: <literal>STR</literal> represents strings, <literal>BIN</literal>
represents binary or logical values, <literal>INT</literal> represents integers,
<literal>REAL</literal> represents 8-byte real numbers, and
<literal>CPX</literal> represents 8-byte complex numbers. The Fortran kind of
each of these basic types is set when the program is compiled, and defined in
the <literal>macros</literal> file. It can be changed.</para>

<para>The following are the specific definitions which you may type to
have valid representations of these <literal>SIMPLE-DATA</literal>:
<programlisting>
STR  -> &lcub;^BLANK&rcub;*|"&lcub;^"&rcub;*"
BIN  -> true|t|yes|y|false|f|no|n
INT  -> [+|-] POSITIVE-INT
REAL  -> PLAIN-REAL [UNIT-SPECIFIER]
CPX -> PLAIN-REAL PLAIN-REAL [UNIT-SPECIFIER]

PLAIN-REAL      -> INT[.[POSITIVE-INT]][d|eINT]
UNIT-SPECIFIER -> angstrom|angstrom^2|meter|amu|wavenumber|ev|
                  kelvin|joule|kilojoule|kjoule|kj|kcal/mol|
</programlisting>
Examples of input for these basic types may be found in <xref
linkend="simple-data-table"/>.</para>

<para>Note that <literal>REAL</literal> and <literal>CPX</literal> quantities
may be followed by a <literal>UNIT-SPECIFIER</literal>, which defined that
number with respect to a specific units system. For example, the following would
be a valid <literal>REAL</literal> token:</para>

<para>2.5 angstrom</para>

<para>The program will convert such numbers followed by a unit specifier into a
standard unit system, usually atomic units, or for angles, the generic unit
system is radians. Programmers should note that it is illegal for any keyword to
be the same as a <literal>UNIT-SPECIFIER</literal>.</para>
</sect1>

<!-- *********************************************************************** -->

<sect1 id="simple-array-data">
<title><literal>SIMPLE-ARRAY-DATA</literal></title>

<para><literal>SIMPLE-ARRAY-DATA</literal> is composed of lists of
<literal>SIMPLE-DATA</literal> which are separated by
<literal>WHITESPACE</literal>. There are two kinds of
<literal>SIMPLE-ARRAY-DATA</literal>,</para>

<para><literal>SIMPLE-ARRAY-DATA ->
SIMPLE-VECTOR-DATA|SIMPLE-MATRIX-DATA</literal></para>

<para>and <literal>SIMPLE-VECTOR-DATA</literal> can be of two types,</para>

<para><literal>SIMPLE-VECTOR-DATA   ->
FIXED-VECTOR-DATA|VARIABLE-VECTOR-DATA</literal></para>

<para>The definitions of each of these types are:
<programlisting>
VARIABLE-VECTOR-DATA -> STRVEC|BINVEC|INTVEC|REALVEC|CPXVEC
FIXED-VECTOR-DATA    -> STRVEC(D)|BINVEC(D)|INTVEC(D)|REALVEC(D)|CPXVEC(D)

D  -> POSITIVE-INT

STRVEC(D) -> &lcub;STR &rcub;D
BINVEC(D) -> &lcub;BIN &rcub;D
INTVEC(D)   -> &lcub;INT &rcub;D
REALVEC(D)    -> &lcub;PLAIN-REAL &rcub;D [UNIT-SPECIFIER]
CPXVEC(D)   -> &lcub;PLAIN-REAL PLAIN-REAL &rcub;D [UNIT-SPECIFIER]

STRVEC -> &lcub; &lcub;STR &rcub;* &rcub;
BINVEC -> &lcub; &lcub;BIN &rcub;* &rcub;
INTVEC   -> &lcub; &lcub;INT &rcub;* &rcub;
REALVEC    -> &lcub; &lcub;PLAIN-REAL &rcub;* &rcub; [UNIT-SPECIFIER]
CPXVEC   -> &lcub; &lcub;PLAIN-REAL PLAIN-REAL &rcub;* &rcub; [UNIT-SPECIFIER]
</programlisting>
In the above definitions the grammar element <literal>D</literal> stands for an
integer which also forms part of the name of other grammar element symbol, for
example <literal>STRVEC(D)</literal>.  <literal>STRVEC(D)</literal> thus stands
for an infinite number of specific grammar element symbols,
<literal>STRVEC(1)</literal>, STRVEC(2), <literal>...</literal>, etc.  According
to the definition of <literal>STRVEC(D)</literal>, it is a sequence of
<literal>STR</literal> elements separated by whitespace of length
<literal>D</literal>.</para>

<para>As for <literal>REAL</literal> and <literal>CPX</literal>, vectors of
these types may be followed by a <literal>UNIT-SPECIFIER</literal>, which is
used to convert he values of the entire vector into an internal units
system.</para>

<para>Unlike <literal>SIMPLE-VECTOR-DATA</literal>,
<literal>SIMPLE-MATRIX-DATA</literal> can only be of the fixed variety, 
<programlisting>
SIMPLE-MATRIX-DATA ->
   STRMAT(D(1),...,D(N))|BINMAT(D(1),...,D(N))|INTMAT(D(1),...,D(N))|
   REALMAT(D(1),...,D(N))|CPXMAT(D(1),...,D(N))

N    -> 2|3|4|5
D(N) -> POSITIVE-INT
L    -> PRODUCT(D(1),...,D(N))

STRMAT(D(1),D(2)) -> [by_row|by_column] &lcub;STR &rcub;L
BINMAT(D(1),D(2)) -> [by_row|by_column] &lcub;BIN &rcub;L
INTMAT(D(1),D(2))   -> [by_row|by_column] &lcub;INT &rcub;L
REALMAT(D(1),D(2))    -> [by_row|by_column] &lcub;PLAIN-REAL &rcub;L [UNIT-SPECIFIER]
CPXMAT(D(1),D(2))   -> [by_row|by_column] &lcub;PLAIN-REAL PLAIN-REAL &rcub;L [UNIT-SPECIFIER]

M    -> 3|4|5

STRMAT(D(1),...,D(M)) -> &lcub;STR &rcub;L
BINMAT(D(1),...,D(M)) -> &lcub;BIN &rcub;L
INTMAT(D(1),...,D(M))   -> &lcub;INT &rcub;L
REALMAT(D(1),...,D(M))    -> &lcub;PLAIN-REAL &rcub;L [UNIT-SPECIFIER]
CPXMAT(D(1),...,D(M))   -> &lcub;PLAIN-REAL PLAIN-REAL &rcub;L [UNIT-SPECIFIER]
</programlisting>
As before <literal>M</literal> and <literal>D(M)</literal> stands for any
positive integers, and they form part of the name of other grammar elements, for
example <literal>REALMAT(D(1),D(2))</literal>. Also, in the above definitions,
<literal>PRODUCT(D(1),...,D(N))</literal> stands for the integer which is the
product of the integers <literal>D(1)</literal> to <literal>D(N)</literal>
inclusive.  That is, <literal>L</literal> is the number of elements in the
array.</para>

<para>From these definitions, it is seen that two dimensional matrices are
slightly different to three and higher dimensional matrices: two dimensional
matrices may be preceded by the descriptor <literal>by_row</literal>, or
<literal>by_column</literal>.  This is to indicate whether the following
sequence of <literal>SIMPLE-DATA</literal> is to be interpreted as being
inputted in either row order, or column order, respectively. The default order
is <literal>by_row</literal>, and this is set when the program is compiled.  For
multidimensional arrays, the default order is always so that the first index of
the multidimensional array increments most rapidly---that is, the normal Fortran
column order.</para>

<para>As usual, matrices of <literal>REAL</literal> and <literal>CPX</literal>
values may be followed by a <literal>UNIT-SPECIFIER</literal> which will convert
the inputted matrix <literal>DATA</literal> from the specified unit system, into
the default internal unit system.</para>
</sect1>

<!-- *********************************************************************** -->

<sect1 id="derived-data">
<title><literal>DERIVED-DATA</literal></title>

<para><literal>DERIVED-DATA</literal> are used to represent a collected group of
<literal>DATA</literal> as a single entity. As with any data, the full
description <literal>DERIVED-DATA</literal> , and the allowed operations on this
data appears in a module with name <literal>DERIVED</literal>. </para>

<para>There are two types of <literal>DERIVED-DATA</literal>:</para>

<para><literal>DERIVED-DATA ->
KEYWORD-DATA(DERIVED)|VECTOR-DATA(DERIVED)</literal></para>

<para><literal>KEYWORD-DATA(DERIVED)</literal> applies when module
<literal>DERIVED</literal> does not describe a list of derived data type,
whereas <literal>VECTOR-DATA(DERIVED)</literal>  applies when module
<literal>DERIVED</literal> does describe a list of derived data type.  In the
latter case, the module name <literal>DERIVED</literal> will always end in the
suffix <quote><literal>REALVEC</literal></quote>, while the prefix will be the name
of the data type of each element of the list. For example, a list of derived
<literal>ATOM</literal> data would have the name <literal>ATOMVEC</literal>.  In
general, the grammar element which represents the name of the data type of each
element of the list is <literal>DERIVED-ELEMENT</literal>. Thus, if
<literal>ATOMVEC</literal> is the <literal>DERIVED</literal> type, then
<literal>ATOM</literal> is the <literal>DERIVED-ELEMENT</literal>.</para>

<para>The most important thing to note is that the input for
<literal>DERIVED-DATA</literal> may be just a valid input file for this type of
data. Thus, we have ended where we began, by defining
<literal>KEYWORD-DATA(DERIVED)</literal>.</para>

<para><literal>VECTOR-DATA(DERIVED)</literal> is defined as follows:
<programlisting>
VECTOR-DATA(DERIVED) -> 
&lcub; 
  [list_order= &lcub; PLAIN-DATA-ORDER &rcub; ]
  [list= &lcub;]
     &lcub;PLAIN-DATA(DERIVED)&rcub;*
  [&rcub;] 
&rcub;

PLAIN-DATA-ORDER    -> ORDERED-KEYWORD(DERIVED,1) ... ORDERED-KEYWORD(DERIVED,NC) 
PLAIN-DATA(DERIVED) -> ORDERED-DATA(DERIVED,1) ...   ORDERED-DATA(DERIVED,NC)

ORDERED-KEYWORD(DERIVED,C) -> TASK-KEYWORD(DERIVED)|DATA-KEYWORD(DERIVED)|
                              "KEYWORD-DATA(DERIVED)"|DERIVED-ELEMENT
ORDERED-DATA(DERIVED,C)    -> DATA|NULL|KEYWORD-DATA(DERIVED)

NC -> POSITIVE-INT
C  -> POSITIVE-INT
</programlisting>
In the above, <literal>PLAIN-DATA(DERIVED)</literal>  is simply a sequential
list of <literal>DATA</literal> components of the module
<literal>DERIVED</literal>---without the associated data keywords.</para>

<para>If the optional <literal>list_order=</literal> keyword
<emphasis>is</emphasis> present in the definition of
<literal>VECTOR-DATA(DERIVED)</literal>, the ordering of this
<literal>PLAIN-DATA(DERIVED)</literal> is exactly equivalent in effect to the
following <literal>KEYWORD-DATA(DERIVED)</literal> for each element of the list:
<programlisting>
ORDERED-KEYWORD(DERIVED,1)  ORDERED-DATA(DERIVED,1) ...
ORDERED-KEYWORD(DERIVED,NC) ORDERED-DATA(DERIVED,NC)
</programlisting>
In this way, the repeated use of the same keywords for every element in the list
is avoided. </para>

<para>Note that the <literal>PLAIN-DATA(DERIVED)</literal> may be enclosed by an
optional <literal>list= &lcub; ...  &rcub;</literal> block.  For clarity it is a
good idea to use the <literal>list= &lcub; ... &rcub;</literal> block whenever
the <literal>list_order=</literal>  sequence has been used.</para>

<para>What if the <literal>list_order=</literal> keyword is missing? In this
case, the order of the <literal>ORDERED-DATA</literal> which defines
<literal>PLAIN-DATA(DERIVED)</literal> is <emphasis>inferred</emphasis> from a
default ordering, which is set when the program is compiled. This default order
is defined by a variable called the module <literal>INPUT_DATA_ORDER</literal>
variable, defined in the <literal>macros</literal>  file, and it may be changed.
For example, the default order for the <literal>ATOM</literal>  module is set in
the <literal>ATOM_INPUT_DATA_ORDER</literal> variable. Thus, the
<literal>data</literal> keyword is used to reset the default input data order
used for <literal>PLAIN-DATA</literal>. Because the default orderings may
change, this is another good reason to use the <literal>list_order=</literal>
keyword.</para>

<para>One special possibility for <literal>ORDERED-KEYWORD</literal> is a quoted
keyword-data sequence, <literal>"KEYWORD-DATA(DERIVED)"</literal>. In this case,
the corresponding <literal>ORDERED-DATA</literal> must be
<literal>NULL</literal>, and the effect of this possibility is as if the quoted
keyword-data sequence were had been placed in the plain data list. One often
uses this mechanism to change the units system, by including the sequence
<literal>"&lcub; units angstrom &rcub;"</literal>.  Note that curly brackets
must enclose the keywords, because <literal>KEYWORD-DATA(DERIVED)</literal>  is
essentially an input file by itself.</para>

</sect1>
</chapter>

<!-- *********************************************************************** -->
<!-- *********************************************************************** -->

<chapter id="fortran-modules">
<title><literal>Writing Fortran modules for &TONTO;</literal></title>

<para>The overriding principle which is used in writing modules in &TONTO; is
this:
<informalexample><para>
      A module is used to describe a single data type. 
      That is, all the routines within the module concern 
      manipulations on the data type. 
</para></informalexample>
This is a very general principal. In practice, there are a number of
<emphasis>critical requirements</emphasis> which need to be specified so that
different users can make use of each others work in an effective way. 
There are also <emphasis>aesthetic requirements</emphasis> which make the code
more uniform and easily read. </para>

<para>The &foo; preprocessor automatically generated code which conforms 
to both the critical and aesthetic requirements, but you are not
required to use it; this Chapter will be useful for those programmers
who want to use only Fortran.</para>

<para>The &foo; preprocessor, and how to write &foo; modules for &TONTO; are
described in separate Chapters.</para>

<!-- *********************************************************************** -->

<sect1 id="critical-requirements">
<title><literal>Critical requirements</literal></title>

<para>Here is the list of critical requirements which are used in &TONTO; :

<itemizedlist>
<listitem><para>The first argument of each routine in a module is always a
variable of the data type used in that module. </para></listitem>
<listitem><para>Every module routine is private, but appears in at least one
public generic interface. The generic name is the same as the routine name with
and underscore appended.</para></listitem>
</itemizedlist></para>

<para>The reason for making every routine in the module private is to prevent
namespace pollution.  For example, the routine <literal>get_item</literal> may
be a common possibility for a routine name; using the <literal>private</literal>
attribute prevents any possible name clash, since the routine may not be used.
Instead, only the generic name may be used. Indeed, the provision of a generic
interface means that other modules may deliberately re-use the name of the
routine without a name conflict.  This is called
<emphasis>overloading</emphasis>.  Overloading a generic name in different
modules should be employed whenever the overloaded routine name performs a
similar function in the different modules. </para>

<para>For example, suppose <literal>REALMAT</literal> and <literal>CPXMAT</literal>
are two modules which describe matrices of real and complex numbers,
respectively. The same generic interface name <literal>trace_</literal> might be
used in both modules to describe a routine which returns the trace of the
matrix, whether real or complex.  If every procedure in <literal>REALMAT</literal>
had a corresponding procedure in <literal>CPXMAT</literal> with the same generic
name, any code written initially using real matrices using the
<literal>trace_</literal> routine will also work for complex matrices, if the
variables involved are redeclared.  This is a simple example of the concept of
<emphasis>code inheritance</emphasis>.</para>
</sect1>

<!-- *********************************************************************** -->

<sect1 id="aesthetic-requirements">
<title><literal>Aesthetic requirements</literal></title>

<para>Here is a list of highly recommended conventions to be used in
&TONTO;:</para>

<itemizedlist>
<listitem><para>Only one module statement can be used per
file.</para></listitem>
<listitem><para>Except for module names and preprocessor macros, lowercase is
always used.</para></listitem>
<listitem><para>The name of module always ends in
<literal>_MODULE</literal>.</para></listitem>
<listitem><para>The name of the derived type used in a module to represent the
abstract data type has the same name as the module name followed by
<literal>_type</literal>.</para>
<informalexample>
<para><literal>shell_type</literal> is the name of the derived type defined and
manipulated within the module <literal>SHELL</literal>.</para>
</informalexample></listitem>
<listitem><para>For every module, a macro with the same name as the module name
is always defined, and expands to the actual type used and manipulated in that
module.</para>
<informalexample>
<para><literal>SHELL</literal> is a macro for the type definition
<literal>type(shell_type)</literal>. </para>
</informalexample>
<informalexample>
<para>Using the same name for the type and the module name hides the distinction
between modules and types. This is the main feature of a <quote>class</quote> in
object oriented languages.</para>
</informalexample>
<informalexample>
<para><literal>INT</literal> is a macro for the type <literal>integer</literal>,
and it is a built-in type.  The use of macros hides the distinction between
built-in and derived types.  This is also a feature of many object oriented
languages.</para>
</informalexample></listitem>
<listitem><para>The <literal>result</literal> syntax for a function routine is
always used.</para></listitem>
<listitem><para>The name <literal>self</literal> is always used as the first
dummy argument to any routine.</para></listitem>
</itemizedlist>
</sect1>

<!-- *********************************************************************** -->

<sect1 id="linking-code">
<title><literal>Linking your Fortran code</literal></title>

<para>Once you have written your fortran code with the above requirements, you
will want to link it with &TONTO; to make an executable.</para>

<para><xref linkend="building-executables"/> describes the linking procedure.
</para>

<para>If you want &TONTO; to automatically compile your module, you will need
to</para>

<itemizedlist>
<listitem><para>place the files for your Fortran code into the
<literal>f90files</literal>  directory.</para></listitem>
<listitem><para>manually edit the <literal>dependfile</literal> to insert the
commands for your fortran module and its dependents.</para></listitem>
<listitem><para>place the object file corresponding to your fortran module in
the cocrrect hierarchical position in the module file list</para></listitem>
<listitem><para>type <literal>make</literal> to make your executable, (assuming
it is <literal>run_mol.x</literal>; otherwise type <literal>make</literal> and
the name of your executable whose dependent line you should have already defined
in the <literal>dependfile</literal>).</para></listitem>
</itemizedlist>
</sect1>
</chapter>

<!-- *********************************************************************** -->
<!-- *********************************************************************** -->

<chapter id="foo-chap">
<title>The &foo; preprocessor</title>

<para>
The &TONTO; system is written in &foo;, a preprocessor which encourages a good
object-oriented programming style. &foo; is closely related to Fortran95, and
indeed, &foo; code currently translates into standard compliant Fortran95 code. </para>

<para>The following sections describe the rules for valid input to the
<command>foo</command> preprocessor, and the actual transformation process
performed by the preprocessor. </para>

<para>Although the rules are quite simple, and examples are given, it is
probably easier to examine &foo; modules that have already been written.  It
should be possible to understand &foo; code without reading the formal rules, if
you already have a basic knowledge of object-oriented programming techniques and
syntax.</para>

<para>The most important element of the &foo; language is the introduction of a
<quote>dot notation</quote>. In this notation, a dot
<quote><literal>.</literal></quote> expands either into the Fortran95
<quote><literal>%</literal></quote> type separator symbol, or a procedure call,
depending respectively on whether there is, or is not, a type component with the
appropriate name defined in the type. Thus, using the dot notation, it is
possible for the programmer to <quote>hide</quote> the detailed implementation
of a type (and hence a module) from a casual user.  In this way, the computer
code becomes robust to future changes, sincethe distinction between a routine
and actual data becomes blurred.</para>

<para>
Note that you don't have to write your code in the &foo; language --- plain
Fortran95 is fine, provided you stick to the guidelines in the previous chapter
-- but &foo; has many advantages, and is worth the minimal effort required to
learn it.  </para>

<!-- *********************************************************************** -->

<sect1 id="why-foo">
<title>Key advantages of the &foo; preprocessor</title>

<para>If you do choose write your code in &foo;, then the following advantages
are available to you:</para>

<itemizedlist>

<listitem><para><emphasis>HTML code documentation facility</emphasis>.  The code
you write will be used to generate, automatically, fully hyperlinked synopsis-style
<literal>html</literal> documentation.</para> </listitem>

<listitem><para><emphasis>Hyperlinked procedures and colour-coded
syntax</emphasis>.  Using the <literal>vim</literal> editor and the
<literal>ctags</literal> program, the code you write can be coloured by syntax,
folded by procedure, and fully hyperlinked with all other procedures in the
system, greatly increasing your productivity.</para> </listitem>

<listitem><para><emphasis>Overloading and interface files</emphasis>.  You can
write routines with exactly the same name (provided that they can be
distinguished by their call signature).  The interface file required for this
automatic overloading is automatically generated.</para></listitem>

<listitem><para><emphasis>Automatic use statement generator</emphasis>.  You
don't have to write <literal>use</literal> stetements, because the preprocessor
will automatically generate them for you. This can make compile times much
faster on many systems when you use highly nested modules.</para></listitem>

<listitem><para><emphasis>Dot notation</emphasis>.  A dot notation is available,
as used in most object oriented languages.  The <literal>call</literal>
statement is no longer required.  In effect, a &foo; module module becomes a
<quote>class</quote> which implements a so-called abstract data type (ADT). The
dot notation allows you full data-hiding (i.e. encapsulation) for your
module.</para></listitem>

<listitem><para><emphasis>Multiple template inheritance</emphasis>.  A multiple
template-based inheritance scheme has been implemented, based on code inclusion.
The inheritance scheme does not depend on subtyping, so opportunities for code
re-use are not constrained in any way by language design and code structure. The
scheme is not based on dynamic dispatch, ans so is efficient</para></listitem>

<listitem><para><emphasis>Preconditions, postconditions, and error management
facilities</emphasis>.  To help in writing bug-free code, you can place preconditions
and postconditions into your routines to codify the minimum requirements for
your routine to perform its task correctly.  If an error is detected you have a
traceback of the call stack to tell you where it happened. You can elect not to
use this facility if you are afraid it will make your code less
efficient.</para></listitem>

<listitem><para><emphasis>Memory management facilities</emphasis>.  Fortran95
offers full support dynamical memory and pointers, but this can lead to serious
problems with memory management, such as the famous <quote>memory-leak</quote>
problem. &Foo; automatically checks is each routine you write is memory-tight.
You can elect not to use it this facility facility (for reasons of fast code).
Full traceback and memory monitoring is also available to help track difficult
memory leaks.
</para></listitem>

<listitem><para><emphasis>Conditional compilation of <literal>PURE</literal> and
<literal>ELEMENTAL</literal> routines</emphasis>.  Fortran95 disallows write
statements to be placed within routines marked <literal>PURE</literal> or
<literal>ELEMENTAL</literal>, which may be an annoyance for testing purposes.
You can elect to compile your code without these keywords.</para></listitem>

<listitem><para><emphasis>Automatic <literal>end</literal> keyword
completion</emphasis>.  You can use the <literal>end</literal> keyword to stand
for any of the usual block termination words: <literal>end program</literal>,
<literal>end module</literal>, <literal>end subroutine</literal>, <literal>end
function</literal>, <literal>end if</literal>, <literal>end do</literal>,
<literal>end interface</literal>, <literal>end select</literal>, <literal>end
type</literal>, <literal>end forall</literal>.  This is less typing for you and
makes the code less cluttered <footnote><para>But this makes it nearly mandatory
to use indentation, which is good programming
practice</para></footnote>.</para></listitem>

<listitem><para><emphasis>Automatic <literal>subroutine</literal> and
<literal>function</literal> detection</emphasis>.  You don't need to use the
<literal>subroutine</literal> and <literal>function</literal> keywords. These
are automatically detected for you. It means less typing and less cluttered
code.</para></listitem>

<listitem><para><emphasis>Protection against changes in the language
elements</emphasis>.  The &foo; preprocessor represents a minimal approach to
object oriented programming, and it is conceivable that it may be translated
into a language other than Fortran95 at a future date, should Fortran95 no
longer be the best choice for fast, numerical programs.</para></listitem>
</itemizedlist>
</sect1>

<!-- *********************************************************************** -->

<sect1 id="how-foo-works">
<title>How &foo; works</title>

<para>Currently, &foo; is implemented as a <acronym>UNIX</acronym>
<literal>csh</literal> script, which makes use of the <literal>perl</literal>
text processing language which comes standard with
<acronym>UNIX</acronym><footnote><para>However, there is no guarantee that
future versions of &foo; will be implemented in this way</para></footnote>.  You
will rarely, if ever, need to use &foo; on its own. </para>

<para>If you write a new module, you will place the module file with a
<literal>.foo</literal> extension in the <literal>foofiles</literal> directory.
After modifying the <literal>Makefile</literal> to place your module in the
correct hierarchical position, you just type <literal>make</literal>.</para>

<para>You can, if you wish, apply the &foo; preprocessor separately.</para>

<para>When the &foo; command is applied to a file <literal>x.foo</literal> with
the <literal>.foo</literal>  extension, the &foo; code in this file is changed
into Fortran95 code which includes some C-preprocessor macros, and this code is
written to a specified file. In addition, another file is generated which
contains the Fortran95 generic interfaces which are required if you want to
program using &TONTO;.</para>

<para>In order to work, the &foo; command uses two files:
<literal>foo.perl</literal> and <literal>types.foo</literal>.  The file
<literal>foo.perl</literal> contains instructions that the
<literal>perl</literal> language needs to change &foo; code into Fortran95. The
<literal>types.foo</literal> file contains type information which is relevant to
the &TONTO; system. </para>

<informalexample>
<para>The &TONTO; file gaussian.foo contains code which describes gaussian
functions which are commonly used in quantum chemistry.  To use the &foo;
preprocessor on the file <literal>gaussian.foo</literal>, and to see what the
emitted Fortran95 code looks like, type:
<programlisting>
perl -w scripts/foo.perl foofiles/gaussian.foo gaussian.f90 gaussian.int
</programlisting>
The file <literal>foofiles/gaussian.foo</literal> is the inputted &foo; code.
The script <literal>foo.perl</literal> assumes that the
<literal>types.foo</literal> file resides in the <literal>foofiles</literal>
directory.  <literal>gaussian.f90</literal> contains the emitted Fortran95 code.
The file <literal>gaussian.int</literal> contains a list of the generic
interfaces for this module. You can use your editor to examine these outputted
files. </para>
</informalexample>
</sect1>

<!-- *********************************************************************** -->

<sect1 id="foo-rules">
<title>Rules for valid &foo; preprocessor code</title>

<para>There are only a few extra rules to write valid &foo; code for use in
&TONTO;, in addition or contradiction to the usual rules of Fortran95.</para>

<itemizedlist>
<listitem><para>Lower case letters must be used for all Fortran95
keywords.</para></listitem>
<listitem><para>All C-preprocessor macros must be placed in the file called
<literal>macros</literal></para></listitem>
<listitem><para>All derived type definitions used must be placed in the file
<literal>types.foo</literal>.</para></listitem>
<listitem><para>Capital letters must be used for every module name, and for
every macro definition. Capitalised names are only allowed if their intended
meaning does not clash with any C-preprocessor macros.</para>

<informalexample>
<para>Although it is allowed, it is best to avoid using capitalised names,
except for module names and C-preprocessor macros.</para>
</informalexample></listitem>

<listitem><para>Every &foo; module <literal>XXXX</literal> must consist of a set
of routines concerned with actions on a Fortran95 type <literal>XXXX</literal>.
The name <literal>XXXX</literal> stand for a C-preprocessor macro which defines
the type.  If the types is a Fortran95 derived type, then the name of the
derived type must be <literal>xxxx_type</literal>.</para>
<informalexample>
<para>The module <literal>GAUSSIAN</literal>, contained in file
<literal>gaussian.foo</literal>, is concerned with actions of gaussian
functions. These functions are represented by a type
<literal>gaussian_type</literal>, defined in file <literal>types.foo</literal>
as follows:
<programlisting>
type gaussian_type
   INT :: l 
   REALVEC(3) :: pos
   REAL :: ex
end 
</programlisting>
In the file <literal>macros</literal>, the following definition appears
<programlisting>
#define GAUSSIAN  type(gaussian_type)
</programlisting>
NOTE: the types <literal>INT</literal>, <literal>REAL</literal>, and
<literal>REALVEC(3)</literal> used in the definition of
<literal>gaussian_type</literal> are macros for other (previously defined)
types.  In this specific case, the stand (respectively) for the
<quote>integer</quote> type, the <quote>double precision</quote> type, and a
<quote>three-dimensional vector</quote> type.
</para></informalexample></listitem>

<listitem><para>For any &foo; module <literal>XXXX</literal>, the
<literal>macros</literal> file and the automatically generated interface file
<literal>xxxx.int</literal> must be included, using the C-preprocessor, after
any <literal>use</literal> and <literal>implicit</literal> statements

<informalexample>
<para>The following is an extract of the code in file
<literal>gaussian.foo</literal> that illustrates this rule.
<programlisting>
module GAUSSIAN

   use TYPES
   use ERROR
   use MM
   use OUTPUT

   implicit none         

#  include "macros"
#  include "gaussian.int"
</programlisting></para>
</informalexample></para></listitem>

<listitem><para>It is illegal to use any routine name which ends in the
characters <literal>_n</literal>, where <literal>n</literal> is an integer
greater than 0.
<informalexample>
<para>The reason is that these names which end like this may be used by &foo;
for overloading purposes to define generic interfaces in the interface file
<literal>xxxx.int</literal>.</para>
</informalexample></para></listitem>

<listitem><para>The arguments to a &foo; routine must be on one single
line.</para></listitem>

<listitem><para>The Fortran95 keywords: <literal>subroutine</literal>,
<literal>function</literal>, and <literal>module procedure</literal> are not
allowed. 
<informalexample>
<para>&foo; automatically inserts the appropriate keywords. </para>
</informalexample></para></listitem>

<listitem><para>The <literal>result</literal> syntax must always be used to
define functions
<informalexample>
<para>&foo; determined which routines are functions using this syntax.</para>
</informalexample></para></listitem>

<listitem><para>The Fortran95 syntax for declaring <literal>recursive</literal>,
<literal>pure</literal>, and <literal>elemental</literal> routines is modified
by placing the strings <literal>[recursive]</literal>,
<literal>[pure]</literal>, and <literal>[elemental]</literal> after the routine
name</para></listitem>

<listitem><para>The Fortran95 keywords: <literal>program</literal>,
<literal>module</literal>, <literal>interface</literal>,
<literal>select</literal>, <literal>type</literal>, <literal>else</literal>,
<literal>do</literal>, <literal>contains</literal>, <literal>if</literal>,
<literal>then</literal>, must not be used on a line with multiple statement,
involving the character <literal>;</literal></para></listitem>

<listitem><para>Expressions involving the dot character <literal>.</literal> are
banned except for real number constants. In particular, C-preprocessor macros
<literal>TRUE</literal>, <literal>FALSE</literal>, <literal>NOT</literal>,
<literal>AND</literal>, and <literal>OR</literal> must be used for the logicals
<literal>.true.</literal> , <literal>.false.</literal>,
<literal>.not.</literal> and <literal>.or.</literal></para></listitem>

<listitem><para>Procedures which are <literal>contain</literal>ed within another
procedure are not allowed.</para></listitem>
</itemizedlist>
</sect1>

<!-- *********************************************************************** -->

<sect1 id="foo-to-f95">
<title>What &foo; does to produce Fortran95 code</title>

<para>The actual text transformations that are performed by the &foo;
preprocessor are now described.</para>

<sect2 id="automatic-functions">
<title>Automatic <literal>function</literal> and <literal>subroutine</literal>
detection</title>

<itemizedlist>
<listitem><para>The keyword <literal>function</literal> is automatically
prepended to every &foo; routine name contained in a module or program which
uses the <literal>result</literal> syntax.  Otherwise the routine is assumed to
be a subroutine, and the <literal>subroutine</literal> keyword is
prepended.</para></listitem>
</itemizedlist>
</sect2>

<sect2 id="self-arguments">
<title>Automatic insertion of first argument to a routine</title>

<itemizedlist>
<listitem><para>A dummy variable <literal>self</literal> is automatically
inserted as the first argument of every &foo; routine.</para></listitem>

<listitem><para>Every &foo; routine contained in a module
<literal>XXXX</literal> which is not deemed to be a functional or subroutinal
(see <xref linkend="functionals-subroutinals"/>) has appended a type declaration
of the form <literal>XXXX :: self</literal>.</para>

<informalexample>
<para>The following transformation is performed by &foo; on routine
<literal>arcsin</literal> in module <literal>REAL</literal>
<informaltable frame="none" pgwide="1">
<tgroup cols="3">
<tbody>
<row>
<entry><programlisting>
arcsin result(res)
</programlisting></entry>
<entry><programlisting>
-->
</programlisting></entry>
<entry><programlisting>
function arcsin(self) result(res); REAL :: self
</programlisting></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</para>
</informalexample></listitem>

</itemizedlist>
</sect2>

<sect2 id="end-completion">
<title>Automatic <literal>end</literal> keyword completion</title>

<itemizedlist>
<listitem><para>The <literal>end</literal> keyword may be substituted for
<literal>end do</literal>, <literal>end if</literal>, <literal>end
subroutine</literal>, <literal>end function</literal>, <literal>end
module</literal>, <literal>end select</literal> <literal>end type</literal>,
<literal>end interface</literal>.</para>

<informalexample>
<para>The following transformation is performed by &foo; :
<informaltable frame="none" pgwide="1">
<tgroup cols="3">
<tbody>
<row>
<entry><programlisting>
do i = 1,.n_shell
   n_bf = n_bf + shell(i).n_bf
end
</programlisting></entry>
<entry><programlisting>
-->
</programlisting></entry>
<entry><programlisting>
do i = 1,self%n_shell
   n_bf = n_bf + n_bf_(shell(i))
end do
</programlisting></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</para></informalexample></listitem>

</itemizedlist>
</sect2>

<sect2 id="dot-notation">
<title>Dot notation</title>

<itemizedlist>
<listitem><para>In module <literal>XXXX</literal>, if <literal>x</literal>,
<literal>y</literal>, <literal>...</literal>, <literal>z</literal> stand for
allowed Fortran95 names, and if <literal>x</literal> is the name of a record of
the derived type <literal>xxxx_type</literal> used in that module, and defined
in file <literal>types.foo</literal>, then the following transformation is
performed:
<informaltable frame="none" pgwide="1">
<tgroup cols="3">
<tbody>
<row>
<entry><programlisting>
.x(y, ... , z)
</programlisting></entry>
<entry><programlisting>
-->
</programlisting></entry>
<entry><programlisting>
self%x(y, ... , z)
</programlisting></entry>
</row>
</tbody>
</tgroup>
</informaltable>
If <literal>x</literal> is <emphasis>not</emphasis> the name of a record of the
derived type used in the module, and if <literal>.x(y, ... , z)</literal> is
<emphasis>not</emphasis> part of an expression, then following transformation is
performed:
<informaltable frame="none" pgwide="1">
<tgroup cols="3">
<tbody>
<row>
<entry><programlisting>
.x(y, ... , z)
</programlisting></entry>
<entry><programlisting>
-->
</programlisting></entry>
<entry><programlisting>
call x_(self,y, ... , z)
</programlisting></entry>
</row>
</tbody>
</tgroup>
</informaltable>
If <literal>x</literal> is <emphasis>not</emphasis> the name of a record of the
derived type used in the module, and if <literal>.x(y, ... , z)</literal>
<emphasis>is</emphasis> part of an expression, then the following transformation
is performed:
<informaltable frame="none" pgwide="1">
<tgroup cols="3">
<tbody>
<row>
<entry><programlisting>
.x(y, ... , z)
</programlisting></entry>
<entry><programlisting>
-->
</programlisting></entry>
<entry><programlisting>
x_(self,y, ... , z)
</programlisting></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<informalexample>
<para>Within module <literal>SHELL</literal>, the following transformation is
performed on <literal>.ex</literal> and <literal>.n_cc</literal>, since
<literal>ex</literal> and <literal>n_cc</literal> are both records of derived
type <literal>shell_type</literal>:
<informaltable frame="none" pgwide="1">
<tgroup cols="3">
<tbody>
<row>
<entry><programlisting>
.ex(.n_cc)
</programlisting></entry>
<entry><programlisting>
-->
</programlisting></entry>
<entry><programlisting>
self%ex(self%n_cc)
</programlisting></entry>
</row>
</tbody>
</tgroup>
</informaltable>
The following transformations are performed on <literal>.unnormalise</literal>
and <literal>.l_chr</literal> since they are not records of derived
<literal>shell_type</literal>:
<informaltable frame="none" pgwide="1">
<tgroup cols="3">
<tbody>
<row>
<entry><programlisting>
.unnormalize
</programlisting></entry>
<entry><programlisting>
-->
</programlisting></entry>
<entry><programlisting>
call unnormalize_(self)
</programlisting></entry>
</row>
<row>
<entry><programlisting>
str = .l_chr
</programlisting></entry>
<entry><programlisting>
-->
</programlisting></entry>
<entry><programlisting>
str = l_chr_(self)
</programlisting></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</para></informalexample></para></listitem>

<listitem><para>If <literal>x</literal>, <literal>y</literal>,
<literal>...</literal>, <literal>z</literal> stand for allowed Fortran95 names,
and if <literal>w</literal> is the name of a Fortran variable, and if
<literal>w.x(y, ... , z)</literal> is <emphasis>not</emphasis> part of an
expression, and if <literal>x</literal> is a type component of the variable
<literal>w</literal> then following transformation is performed:
<informaltable frame="none" pgwide="1">
<tgroup cols="3">
<tbody>
<row>
<entry><programlisting>
w.x(y, ... , z)
</programlisting></entry>
<entry><programlisting>
-->
</programlisting></entry>
<entry><programlisting>
w%x(y, ... , z)
</programlisting></entry>
</row>
</tbody>
</tgroup>
</informaltable>
If <literal>w.x(y, ... , z)</literal> is <emphasis>not</emphasis> part of an
expression, and If <literal>x</literal> is <emphasis>not</emphasis> a type
component of the variable <literal>w</literal> the following transformation is
performed:
<informaltable frame="none" pgwide="1">
<tgroup cols="3">
<tbody>
<row>
<entry><programlisting>
w.x(y, ... , z)
</programlisting></entry>
<entry><programlisting>
-->
</programlisting></entry>
<entry><programlisting>
call x_(w,y, ... , z)
</programlisting></entry>
</row>
</tbody>
</tgroup>
</informaltable>
If <literal>w.x(y, ... , z)</literal> <emphasis>is</emphasis> part of an
expression, then the following and if <literal>x</literal> is a type component
of the variable <literal>w</literal> then following transformation is performed:
<informaltable frame="none" pgwide="1">
<tgroup cols="3">
<tbody>
<row>
<entry><programlisting>
w.x(y, ... , z)
</programlisting></entry>
<entry><programlisting>
-->
</programlisting></entry>
<entry><programlisting>
w%x(y, ... , z)
</programlisting></entry>
</row>
</tbody>
</tgroup>
</informaltable>
If <literal>w.x(y, ... , z)</literal> <emphasis>is</emphasis> part of an
expression, then the following and if <literal>x</literal> is
<emphasis>not</emphasis> a type component of the variable <literal>w</literal>
then following transformation is performed:
<informaltable frame="none" pgwide="1">
<tgroup cols="3">
<tbody>
<row>
<entry><programlisting>
w.x(y, ... , z)
</programlisting></entry>
<entry><programlisting>
-->
</programlisting></entry>
<entry><programlisting>
x_(w,y, ... , z)
</programlisting></entry>
</row>
</tbody>
</tgroup>
</informaltable>

<informalexample><para>
The following transformations are performed by &foo; in module
<literal>SHELL</literal>:
<informaltable frame="none" pgwide="1">
<tgroup cols="3">
<tbody>
<row>
<entry><programlisting>
e = shell.l*(shell.l+1)/2
</programlisting></entry>
<entry><programlisting>
-->
</programlisting></entry>
<entry><programlisting>
e = shell%l*(shell%l+1)/2
</programlisting></entry>
</row>
<row>
<entry><programlisting>
e = shell.ex
</programlisting></entry>
<entry><programlisting>
-->
</programlisting></entry>
<entry><programlisting>
e = shell%ex
</programlisting></entry>
</row>
<row>
<entry><programlisting>
e = shell.ex(n)
</programlisting></entry>
<entry><programlisting>
-->
</programlisting></entry>
<entry><programlisting>
e = shell%ex(n)
</programlisting></entry>
</row>
<row>
<entry><programlisting>
shell.unnormalize
</programlisting></entry>
<entry><programlisting>
-->
</programlisting></entry>
<entry><programlisting>
call unnormalize_(shell)
</programlisting></entry>
</row>
<row>
<entry><programlisting>
sh.ex(b+1:b+nb).put
</programlisting></entry>
<entry><programlisting>
-->
</programlisting></entry>
<entry><programlisting>
call put_(sh%ex(b+1:b+nb))
</programlisting></entry>
</row>
<row>
<entry><programlisting>
e = shell.ex(shell.n_cc)
</programlisting></entry>
<entry><programlisting>
-->
</programlisting></entry>
<entry><programlisting>
e = shell%ex(shell%n_cc)
</programlisting></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</para></informalexample>
<informalexample><para>
The dot notation <literal>.</literal> can be viewed as a synonym for the
structure separator <literal>%</literal>.  They are not the same, however, since
the internal type structure of the variable <literal>shell</literal> may change
at some later date so that component <literal>shell%ex</literal> is no longer
present.  A routine <literal>ex_(shell)</literal> can always be arranged to
exist to simulate the missing structure component. This greatly facilitates the
maintainability of the code supposing that the internal structure of the type
changes. However, it should be kept in mind for compute intensive routines that
the <literal>%</literal> notation is more efficient than a routine call.
</para></informalexample></para></listitem>

</itemizedlist>
</sect2>

<sect2 id="automatic-overloading">
<title>Automatic overloading and interface files</title>

<itemizedlist>
<listitem><para>A generic interface file <literal>xxxx.int</literal> is
automatically generated for module <literal>XXXX</literal>, The generic name
used for every routine <literal>f</literal> in the module is
<literal>f_</literal>.</para></listitem>

<listitem><para>If the same routine name <literal>f</literal> appears in a
module or program <literal>(k+1)</literal> times, then &foo; changes these names
into the Fortran95 names <literal>f</literal>, <literal>f_1</literal>,
<literal>...</literal>, <literal>f_k</literal>.

<informalexample><para>
The following transformation is performed by &foo; on the overloaded routine
names <literal>read</literal> in module <literal>ARCHIVE</literal>. Both
routines are called by the single generic name <literal>read_</literal>.
<informaltable frame="none" pgwide="1">
<tgroup cols="3">
<tbody>
<row>
<entry><programlisting>
read(item,kind)
   REALVEC :: item
   ...
</programlisting></entry>
<entry><programlisting>
-->
</programlisting></entry>
<entry><programlisting>
subroutine read(self,item,kind); ARCHIVE :: self
   REALVEC :: item
   ...
</programlisting></entry>
</row>
<row>
<entry><programlisting>
read(item,kind)
   CPXVEC :: item
   ...
</programlisting></entry>
<entry><programlisting>
-->
</programlisting></entry>
<entry><programlisting>
subroutine read(self,item,kind); ARCHIVE :: self
   CPXVEC :: item
   ...
</programlisting></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</para></informalexample></para></listitem>

</itemizedlist>
</sect2>

<sect2 id="explicit-overloading">
<title>Explicit overloading</title>

<itemizedlist>

<listitem><para>The <literal>module procedure</literal> keyword is automatically
inserted within any explicit generic interface definition appearing in a module.

<informalexample><para>
The following transformation is performed by &foo; :
<informaltable frame="none" pgwide="1">
<tgroup cols="3">
<tbody>
<row>
<entry><programlisting>
interface f
   fa, fb, fc, ...
end
</programlisting></entry>
<entry><programlisting>
-->
</programlisting></entry>
<entry><programlisting>
interface f_
   module procedure fa, fb, fc, ...
end interface
</programlisting></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</para></informalexample>
</para></listitem>
</itemizedlist>

</sect2>

<sect2 id="function-attributes">
<title>New syntax for <literal>recursive</literal>, <literal>pure</literal> and
<literal>elemental</literal> routines</title>

<itemizedlist>
<listitem><para>If the string <literal>[recursive]</literal> appears at the end
of the line where the routine name appears, the routine is deemed recursive, and
the keyword <literal>recursive</literal> is placed before the keyword
<literal>function</literal> or <literal>subroutine</literal> in the emitted
Fortran95 code.</para>

<informalexample>
<para>In module <literal>XXXX</literal>, &foo; performs the following
transformation on the recursive routine shown below:
<informaltable frame="none" pgwide="1">
<tgroup cols="3">
<tbody>
<row>
<entry><programlisting>
f(y, ... , z) result(w) [recursive]
</programlisting></entry>
<entry><programlisting>
-->
</programlisting></entry>
<entry><programlisting>
recursive function f(self,y, ... , z) result(w); XXXX :: self
</programlisting></entry>
</row></tbody></tgroup></informaltable>
</para></informalexample>
</listitem>

<listitem><para>If the string <literal>[pure]</literal> appears at the end of
the line where the routine name appears, the routine is deemed conditionally
pure, and the keyword <literal>PURE</literal> is placed before the keyword
<literal>function</literal> or <literal>subroutine</literal> in the emitted
Fortran95 code. The attribute <literal>intent(in)</literal> is also added to the
first argument <literal>self</literal>.</para>

<informalexample>
<para>A conditionally pure routine is one that can be declared
<literal>pure</literal> or not when the routine is compiled. In this way, write
statements may easily be placed within the routines, and later removed, for
debugging purposes.
</para></informalexample>
</listitem>

<listitem><para>If the string <literal>[PURE]</literal> appears at the end of
the line where the routine name appears, the routine is deemed unconditionally
pure, and the keyword <literal>pure</literal> is placed before the keyword
<literal>function</literal> or <literal>subroutine</literal> in the emitted
Fortran95 code. The attribute <literal>intent(in)</literal> is also added to the
first argument <literal>self</literal>.

<informalexample>
<para>An unconditionally <literal>pure</literal> routine is one that must always
<literal>pure</literal> at compile time. This may be required, for example, for
routines which are used in the specification part of a variable
declaration.</para>
</informalexample>
</para></listitem>

<listitem><para>If the string <literal>[elemental]</literal> appears at the end
of the line where the routine name appears, the routine is deemed conditionally
elemental, and the keyword <literal>ELEMENTAL</literal> is placed before the
keyword <literal>function</literal> or <literal>subroutine</literal> in the
emitted Fortran95 code. The attribute <literal>intent(in)</literal> is also
added to the first argument <literal>self</literal>.</para></listitem>

<listitem><para>If the string <literal>[ELEMENTAL]</literal> appears at the end
of the line where the routine name appears, the routine is deemed
unconditionally elemental, and the keyword <literal>elemental</literal> is
placed before the keyword <literal>function</literal> or
<literal>subroutine</literal> in the emitted Fortran95 code. The attribute
<literal>intent(in)</literal> is also added to the first argument
<literal>self</literal>.  In module <literal>XXXX</literal>, &foo; performs the
following transformation on the recursive routine shown below:</para>

<informalexample>
<para>In module <literal>XXXX</literal>, &foo; performs the following
transformation on the elemental routine shown below:
<informaltable frame="none" pgwide="1">
<tgroup cols="3">
<tbody>
<row>
<entry><programlisting>
f(y, ... , z) result(w) [elemental]
</programlisting></entry>
<entry><programlisting>
-->
</programlisting></entry>
<entry><programlisting>
elemental function f(self,y, ... , z) result(w); XXXX, IN :: self
</programlisting></entry>
</row></tbody></tgroup></informaltable>
The macro <literal>IN</literal>, which stands for <literal>intent(in)</literal>, is also added 
as an attribute in the declaration for <literal>self</literal>.</para>
</informalexample></listitem>

</itemizedlist>

</sect2>

<sect2 id="functionals-subroutinals">
<title>Functionals and subroutinals</title>

<itemizedlist>

<listitem><para>In a module <literal>XXXX</literal>, if the string
<literal>[functional]</literal> appears at the end of the line where a function
name appears, the function is deemed to be a functional, meaning that its first
argument <literal>self</literal> is a routine, and the automatic declaration
<literal>XXXX :: self</literal> is suppressed.</para></listitem>

<listitem><para>In a module <literal>XXXX</literal>, if the string
<literal>[subroutinal]</literal> appears at the end of the line where a
subroutine name appears, the subroutine is deemed to be a subroutinal, meaning
that its first argument <literal>self</literal> is a routine, and the automatic
declaration <literal>XXXX :: self</literal> is suppressed.</para>

<informalexample>
<para>The reason for declaring a functional or subroutinal explicitly is that
the automatic declaration of the first argument, <literal>self</literal>, must
be suppressed, in order that it does not conflict with the required explicit
interface for the routine <literal>self</literal>. In addition, the intention of
the routine is made clearer.</para>
</informalexample>
<informalexample>
<para>In module REAL, &foo; performs the following transformation on the
functional shown below:</para>
<informaltable frame="none" pgwide="1">
<tgroup cols="3">
<tbody>
<row>
<entry><programlisting>
integrate(self,a,b,accuracy) result(res) [recursive] [functional]
</programlisting></entry>
<entry><programlisting>
-->
</programlisting></entry>
<entry><programlisting>
recursive function integrate(self,a,b,accuracy) result(res)
</programlisting></entry>
</row></tbody></tgroup></informaltable>
<para>In addition, an explicit <literal>interface</literal> must be defined
for <literal>self</literal>, which is transformed as shown:</para>
<informaltable frame="none" pgwide="1">
<tgroup cols="3">
<tbody>
<row>
<entry><programlisting>
      interface
         self(x) result(res)
            REAL :: x,res
         end
      end
</programlisting></entry>
<entry><programlisting>
-->
</programlisting></entry>
<entry><programlisting>
   interface
      function self(x) result(res)
         REAL :: x,res
      end function
   end interface
</programlisting></entry>
</row></tbody></tgroup></informaltable>
</informalexample></listitem>

</itemizedlist>

</sect2>

<sect2 id="error-management">
<title>Preconditions, postconditions, and error management facilities</title>

<itemizedlist>

<listitem><para>If the macro <literal>ENSURE(cond,"message")</literal>,
<literal>DIE_IF(cond,"message")</literal>, or
<literal>WARN_IF(cond,"message")</literal> appears in routine
<literal>f</literal> of module <literal>XXXX</literal>, where
<literal>cond</literal> stands for a logical expression and
<literal>message</literal> stands for the text of some error message, then &foo;
will insert the name of the module and routine at the beginning of the error
message text, yielding the new error message text
<literal>"in XXXX:f ... message"</literal></para>

<informalexample>
<para>In routine <literal>read</literal> of module <literal>MOL</literal>, &foo;
changes the precondition macro <literal>ENSURE</literal> as follows:</para>
<informaltable frame="none" pgwide="1">
<tgroup cols="3">
<tbody>
<row>
<entry><programlisting>
ENSURE(word=="name","first keyword must be name")
</programlisting></entry>
<entry><programlisting>
-->
</programlisting></entry>
<entry><programlisting>
ENSURE(word=="name","in MOL:read ... first keyword must be name")
</programlisting></entry>
</row></tbody></tgroup></informaltable>
<para>If the <quote>first keyword is not name</quote>, i.e.
<literal>word/="name"</literal>, then the following error message is generated
by routine <literal>read</literal> in the output:
<programlisting>
ERROR: in MOL:read ... first keywrord must be name
</programlisting>
</para></informalexample>

<informalexample>
<para>The macros <literal>ENSURE</literal>, <literal>DIE_IF</literal>, or
<literal>WARN_IF</literal> are commonly used to ensure that a specific set of
conditions hold before the start, or at the end of, a routine. In this way,
errors can be detected and handled at an early stage without propagation. They
are therefore called precondition or postconditon macros. 
</para></informalexample></listitem>

<listitem><para>If the macro <literal>DIE("message")</literal> or
<literal>WARN("message")</literal> appears in routine <literal>f</literal> of
module <literal>XXXX</literal>, where <literal>message</literal> stands for the
text of some error message, then &foo; will insert the name of the module and
routine at the beginning of the error message text, yielding the new error
message text <literal>"in XXXX:f ... message"</literal></para>

<informalexample>
<para>The macro <literal>DIE</literal> is used for graceful program termination.
The macro <literal>WARN</literal> is used to warn of an unusual, and most likely
erroneous situation.</para>
</informalexample></listitem>

</itemizedlist>
</sect2>

<sect2 id="memory-management">
<title>Memory and call-stack management</title>

<itemizedlist>

<listitem><para>If the string <literal>[leaky]</literal> appears at the end of
the line where the routine name appears, the routine is deemed to be leaky,
meaning that within the body of the routine more memory has been allocated than
deallocated.</para>

<informalexample>
<para>In module <literal>MOL</literal>, the <literal>read</literal> routine has
been deemed leaky:
<programlisting>
read [leaky]
</programlisting>
</para></informalexample>
</listitem>

<listitem><para>Any routine with the string <literal>create</literal>, or
<literal>destroy</literal> as part of its name is automatically deemed to be
leaky.</para></listitem>

<listitem><para>For every routine <literal>f</literal> in module
<literal>XXXX</literal>, the macro <literal>STACK("XXXX:f")</literal> is
inserted before the first line of code which is not a precondition
macro.</para></listitem>

<listitem><para>For every routine <literal>f</literal> which is leaky or pure,
the macro <literal>UNSTACK</literal> is inserted before the <literal>end
function</literal> or <literal>end subroutine</literal> keywords in the last
line of the routine.</para></listitem>

<listitem><para>For every routine <literal>f</literal> which is not leaky or
pure, the macro <literal>CHECK</literal> is inserted before the first line of
code which is not a precondition macro.</para>

<informalexample>
<para>The macro <literal>STACK(X)</literal> stands for <literal>call
stack_(tonto,X)</literal>. <literal>tonto</literal> is a memory and call-stack
manager object used by &TONTO;. This routine call places the current routine
name <literal>X</literal> onto a call stack, which may later be used to print a
call-stack traceback in the event of controlled error. The routine call also
sets to zero a variable which is used to keep track of the memory used in this
routine.  The amount of memory used or released by dynamic allocation is
monitored in the <literal>tonto</literal> system variable.</para>
</informalexample>

<informalexample>
<para>The macro <literal>UNSTACK</literal> stands for <literal>call
unstack_(tonto)</literal>. It removes the current routine name
<literal>X</literal> from the call stack.</para>
</informalexample>

<informalexample>
<para>The macro <literal>CHECK</literal> stands for <literal>call
check_(tonto)</literal>. It removes the current routine name
<literal>X</literal> from the stack and checks if the routine has a memory leak
or not, by examining the memory usage variable for the routine.</para>
</informalexample>
</listitem>

</itemizedlist>

</sect2>

<sect2 id="c-preprocessort">
<title>C-preprocessor macros and type definitions</title>

<itemizedlist>

<listitem><para>The following transformations are made by
<literal>foo</literal></para>

<para>
<informaltable frame="none" pgwide="1">
<tgroup cols="3">
<tbody>
<row>
<entry><programlisting>
STR
</programlisting></entry>
<entry><programlisting>
-->
</programlisting></entry>
<entry><programlisting>
STR(STR_SIZE)
</programlisting></entry>
</row><row>
<entry><programlisting>
BSTR
</programlisting></entry>
<entry><programlisting>
-->
</programlisting></entry>
<entry><programlisting>
STR(BSTR_SIZE)
</programlisting></entry>
</row><row>
<entry><programlisting>
TRI
</programlisting></entry>
<entry><programlisting>
-->
</programlisting></entry>
<entry><programlisting>
TRI(:)
</programlisting></entry>
</row><row>
<entry><programlisting>
REALVEC
</programlisting></entry>
<entry><programlisting>
-->
</programlisting></entry>
<entry><programlisting>
REALVEC(:)
</programlisting></entry>
</row><row>
<entry><programlisting>
REALVECVEC
</programlisting></entry>
<entry><programlisting>
-->
</programlisting></entry>
<entry><programlisting>
REALVECVEC(:)
</programlisting></entry>
</row><row>
<entry><programlisting>
INTVEC
</programlisting></entry>
<entry><programlisting>
-->
</programlisting></entry>
<entry><programlisting>
INTVEC(:)
</programlisting></entry>
</row><row>
<entry><programlisting>
IVECVEC
</programlisting></entry>
<entry><programlisting>
-->
</programlisting></entry>
<entry><programlisting>
IVECVEC(:)
</programlisting></entry>
</row><row>
<entry><programlisting>
CPXVEC
</programlisting></entry>
<entry><programlisting>
-->
</programlisting></entry>
<entry><programlisting>
CPXVEC(:)
</programlisting></entry>
</row><row>
<entry><programlisting>
REALMATVEC
</programlisting></entry>
<entry><programlisting>
-->
</programlisting></entry>
<entry><programlisting>
REALMATVEC(:)
</programlisting></entry>
</row><row>
<entry><programlisting>
REALMAT3VEC
</programlisting></entry>
<entry><programlisting>
-->
</programlisting></entry>
<entry><programlisting>
REALMAT3VEC(:)
</programlisting></entry>
</row><row>
<entry><programlisting>
REALMAT4VEC
</programlisting></entry>
<entry><programlisting>
-->
</programlisting></entry>
<entry><programlisting>
REALMAT4VEC(:)
</programlisting></entry>
</row><row>
<entry><programlisting>
STRVEC
</programlisting></entry>
<entry><programlisting>
-->
</programlisting></entry>
<entry><programlisting>
STRVEC(:)
</programlisting></entry>
</row><row>
<entry><programlisting>
BINVEC
</programlisting></entry>
<entry><programlisting>
-->
</programlisting></entry>
<entry><programlisting>
BINVEC(:)
</programlisting></entry>
</row><row>
<entry><programlisting>
FILEVEC
</programlisting></entry>
<entry><programlisting>
-->
</programlisting></entry>
<entry><programlisting>
FILEVEC(:)
</programlisting></entry>
</row><row>
<entry><programlisting>
SHELLVEC
</programlisting></entry>
<entry><programlisting>
-->
</programlisting></entry>
<entry><programlisting>
SHELLVEC(:)
</programlisting></entry>
</row><row>
<entry><programlisting>
BASISVEC
</programlisting></entry>
<entry><programlisting>
-->
</programlisting></entry>
<entry><programlisting>
BASISVEC(:)
</programlisting></entry>
</row><row>
<entry><programlisting>
ATOMVEC
</programlisting></entry>
<entry><programlisting>
-->
</programlisting></entry>
<entry><programlisting>
ATOMVEC(:)
</programlisting></entry>
</row><row>
<entry><programlisting>
IRREPVEC
</programlisting></entry>
<entry><programlisting>
-->
</programlisting></entry>
<entry><programlisting>
IRREPVEC(:)
</programlisting></entry>
</row><row>
<entry><programlisting>
REALMAT
</programlisting></entry>
<entry><programlisting>
-->
</programlisting></entry>
<entry><programlisting>
REALMAT(:,:)
</programlisting></entry>
</row><row>
<entry><programlisting>
REALMAT3
</programlisting></entry>
<entry><programlisting>
-->
</programlisting></entry>
<entry><programlisting>
REALMAT3(:,:,:)
</programlisting></entry>
</row><row>
<entry><programlisting>
REALMAT4
</programlisting></entry>
<entry><programlisting>
-->
</programlisting></entry>
<entry><programlisting>
REALMAT4(:,:,:,:)
</programlisting></entry>
</row><row>
<entry><programlisting>
REALMAT5
</programlisting></entry>
<entry><programlisting>
-->
</programlisting></entry>
<entry><programlisting>
REALMAT5(:,:,:,:,:)
</programlisting></entry>
</row><row>
<entry><programlisting>
INTMAT
</programlisting></entry>
<entry><programlisting>
-->
</programlisting></entry>
<entry><programlisting>
INTMAT(:,:)
</programlisting></entry>
</row><row>
<entry><programlisting>
INTMAT3
</programlisting></entry>
<entry><programlisting>
-->
</programlisting></entry>
<entry><programlisting>
INTMAT3(:,:,:)
</programlisting></entry>
</row><row>
<entry><programlisting>
INTMAT4
</programlisting></entry>
<entry><programlisting>
-->
</programlisting></entry>
<entry><programlisting>
INTMAT4(:,:,:,:)
</programlisting></entry>
</row><row>
<entry><programlisting>
CPXMAT
</programlisting></entry>
<entry><programlisting>
-->
</programlisting></entry>
<entry><programlisting>
CPXMAT(:,:)
</programlisting></entry>
</row><row>
<entry><programlisting>
CPXMAT3
</programlisting></entry>
<entry><programlisting>
-->
</programlisting></entry>
<entry><programlisting>
CPXMAT3(:,:,:)
</programlisting></entry>
</row><row>
<entry><programlisting>
CPXMAT4
</programlisting></entry>
<entry><programlisting>
-->
</programlisting></entry>
<entry><programlisting>
CPXMAT4(:,:,:,:)
</programlisting></entry>
</row><row>
<entry><programlisting>
CPXMAT5
</programlisting></entry>
<entry><programlisting>
-->
</programlisting></entry>
<entry><programlisting>
CPXMAT5(:,:,:,:,:)
</programlisting></entry>
</row>
</tbody></tgroup></informaltable></para></listitem>

<listitem><para>The C preprocessor macros defined in the
<literal>macros</literal> file shall constitute part of the definition of the
&foo; language.</para></listitem>

</itemizedlist>
</sect2>
</sect1>
</chapter>

<!-- *********************************************************************** -->
<!-- *********************************************************************** -->

<chapter id="foo-modules">
<title>Writing &foo; modules for &TONTO;</title>

<para>The first step in writing a module for &TONTO; is to decide whether you
really need to do that.</para>

<para>&TONTO; is organised around about thirty data objects. Writing a whole
module is a fairly serious undertaking in which you are required to define what
data the object is supposed to store, and what operations might be performed on
this data.</para>

<para>Initially, you might only want to add particular functionality or routine
to an existing module. </para>

<para>If you really do want to write a whole module, or slash &TONTO; to bits
for your own project, this chapter gives you the required procedure for
constructing or deconstructing a module. </para>

<para>A particular style has been adopted within &TONTO;. This is not just for
aesthetics.  We believe that adhering to such a style will make it relatively
easy to port &foo; code to other languages. Hopefully this will not be a
neccesity, but writing code which has a multilingual character can only help in
its maintainence and understandability.</para>

<!-- *********************************************************************** -->

<sect1 id="module-purpose">
<title>What is the module supposed to do?</title>

<para>First, you must decide what the module is supposed to do. But this does
<emphasis>not</emphasis> define a module in &TONTO;.</para>

<para>Instead, a module is defined by the <emphasis>data</emphasis> which is
required to do the task.</para>

<para>Many people, especially Fortran programmers, come from a top-down design
philosophy. In this philosophy a desired task is broken into smaller bits, which
are eventually coded as separate routines. This philosophy must be
resisted.</para>

<para>For example, a common task in quantum chemistry is the requirement for
<quote>integrals</quote>. A typical Fortran programmer would write code for the
formulas required, breaking the code up into routines to save repetitive coding.
At the last stage, the programmer would write input routines, or provide
subroutine arguments, so the user could provide the data required to evaluate
the formulas. The final result would be a Fortran routine like this
<programlisting>
   call evaluate_integrals(result,input_data_1,input_data_2, ....)
</programlisting>
In a worst case scenario, common blocks and I/O statements would also
be used to introduce the required data into the routine.</para>

<para>By contrast, in an object-based design philosophy, you would start by
asking what data is required for the integrals. If you are using gaussian
functions, that data might be the information required to define these gaussian
functions. All this data would be used to define a <literal>gaussian</literal>
data type.  Routines and functionality would be provided so that the user could
introduce this data using I/O, or perhaps from other data types. The ability to
<literal>evaluate_integrals</literal> would only be one of many tasks that could
be performed on the <literal>guassian</literal>. The final result in &TONTO;
would be some lines like this
<programlisting>
   gaussian.read_data_from(stdin)
   gaussian.evaluate_integrals(result)
</programlisting>
In all cases, the interface to the routine is constant and involves the
<literal>gaussian</literal> data. </para>

<para>It is the encapsulation of data and functionality together, and the set
way to access a routine by its interface, which allows the object-based approach
better suited for large scale programs.</para>

<para>Whereas in the top-down design approach the details of how a task is
broken down may vary from programmer to programmer, in the object-based approach
used in &TONTO; the data required for a task, and the functionality that can be
performed on that data remains fairly universal within a specified problem
context.</para>

</sect1>

<!-- *********************************************************************** -->

<sect1 id="data-routines">
<title>Deciding what is data and what should be a routine</title>

<para>A simple rule is simply to ask yourself: what is the minimal data required
for the object to do the things I want it to? It is these data which are placed
into the type definition.</para>

<para>Sometimes, particular data are generated from the minimal required data,
and these data are re-used many times. In this case, it might be useful for
efficiency reasons to include such <quote>non-moinimal</quote> data also in the
type definition for efficiency reasons.</para>

<para>All the remaining functionality can be coded as subroutines or
functions.</para>

</sect1>

<!-- *********************************************************************** -->

<sect1 id="defining-types">
<title>Defining the type in the <filename>types.foo</filename> file</title>

<para>Once you have decided what is data and what should be a routine, you will
need to define a type to hold that data.</para>

<para>You need to decide a name for the type (which will be the name of the
module also) and the names of all the pieces of data that are held by that type.
For example, below is the definition of the BUFFER type:
<programlisting>
   type buffer_type

   INT :: pos
   ! The position of the last character of the last item processed in
   ! buffer_str

   INT :: item
   ! The item number of the last item processed in buffer_str

   INT :: n_items
   ! The total number of items in the buffer_str

   BIN :: analysed
   ! True, if the buffer_str has been analysed

   STR :: comment_chars
   ! The comment character symbols (concatenated) to be used in the
   ! buffer_str

   BSTR :: buffer_str
   ! The actual buffer string

   end 
</programlisting>
This type contains only simple data types, such as integers, strings, and
logical variables.  Notice how the intended meaning of each variable is fully
described below its declaration.  Notice also how long and descriptive names are
used when neccesary. This is important.  Notice that the
<literal>BUFFER</literal> type is actually declared as
<literal>buffer_type</literal>.</para>

<para>The above type definition is placed in the <literal>types.foo</literal>
file. It must be placed after all the types which it uses, and before all the
types which use it it their definition.</para>

</sect1>

<!-- *********************************************************************** -->

<sect1 id="preprocessor-modifications">
<title>Modifying the &foo; pre-processor</title>

<para>The preprocessor needs to be modified in order to convert capitalised
types into Fortran. For example, the conversion <literal>BUFFER</literal> to
<literal>buffer_type</literal> must be effected. This is done by placing a
C-preprocessor macro in the <literal>macros</literal> file:
<programlisting>
#define BUFFER             type(buffer_type)
</programlisting></para>

<para>For memory checkinhg purposes, you should define the size of the new type
that you are defining. For example, since a <literal>BUFFER</literal> is
comprised of three integers, a logical variable, a string, and a
<quote>big</quote> string, we would define in the <literal>macros</literal> file
<programlisting>
#define BUFFER_SIZE            3*INT_SIZE+BIN_SIZE+STR_SIZE+BSTR_SIZE
</programlisting></para>

</sect1>

<!-- *********************************************************************** -->

<sect1 id="array-type-modifications">
<title>Pre-processor changes for array types</title>

<para>Array types require additional modification of the pre-processor. </para>

<para>For a vector type, for example, we would define in the
<literal>macros</literal> file the following:
<programlisting>
#define REALVEC(A)             ARRAY(REAL,A)
</programlisting>
Similarly, for a <literal>BUFFERVEC</literal> type, representing a vector of
<literal>BUFFER</literal>'s we would define in the <literal>macros</literal> file
<programlisting>
#define BUFFERVEC(A)             ARRAY(BUFFER,A)
</programlisting>
This type does nopt currently exist in &TONTO;.</para>

<para>Array types also require a modification of the <literal>foo.perl</literal>
script.  You should tell the script what type of component each array holds. For
example, a <literal>REALVEC</literal> type hold an array where each element is a
<literal>REAL</literal> number
<programlisting>
%component_type = (     # Components of the vector types
    'REALVEC'           => 'REAL',
</programlisting>
If a <literal>BUFFERVEC</literal> types was defined, you would insert at the end
of the list in the <literal>foo.perl</literal> script
<programlisting>
%component_type = (     # Components of the vector types
    'BUFFERVEC'     => 'BUFFER',
</programlisting></para>

<para>For an array type, you must also tell the <literal>foo.perl</literal>
script how to convert assumed size arrays in type declarations. For example, for
a <literal>REALVEC</literal> type the following substitution must be effected
<programlisting>
%subst = (          # Substitutions .................
      :
    'REALVEC '      => 'REALVEC(:) ',
      :
</programlisting>
If a <literal>BUFFERVEC</literal> types was defined, you would insert at the end
of the list in the <literal>foo.perl</literal> script
<programlisting>
    'BUFFERVEC ' => 'BUFFERVEC(:) ',
</programlisting></para>

</sect1>

<!-- *********************************************************************** -->

<sect1 id="write-conventional-routines">
<title>The conventional routines</title>

<para>At the very least, every module should include all of the conventional
routines documented in <xref linkend="conventional-routines"/>.</para>

<para>Especially, if the module is to include any I/O, the
<literal>read</literal> and <literal>process_input</literal> routines must be
present, and must be substatially the same as provided in other routines.  All
you should have to change in these routines are the case statement options with
the correponding calls to the module routines, and, in the case of array types,
you will have to replace a call to the correponding component-type read
routine.</para>

<para>The reason for insisting on the use of common <literal>read</literal> and
<literal>process_input</literal> routines is so that the input files will
conform to the datbase specification given earlier.  That is important not only
for ease of data input, but for archiving purposes.</para>

<para>In a future release of the &foo; prrprocessor, some type of template
inheritance will be used to ensure all these conventional routines appear,
unchanged.</para>

</sect1>

<!-- *********************************************************************** -->

<sect1 id="well-designed-modules">
<title>Principles for well designed modules</title>

<para>Here are some golden rules for designing a module in the &TONTO;
style.</para>

<itemizedlist>
<listitem><para><emphasis>Document before writing</emphasis>. It is highly
recommended that you fully document the functions and routines that you want to
include in your module, including their arguments, <emphasis>before</emphasis>
you start any coding.  Often, if the plan of attack is clearly specified before
any coding proper is completed, bugs are less prevalent.</para></listitem>

<listitem><para><emphasis>Insert the type definition (commented out) at the
start of the module</emphasis>.  This is required for documentation purposes.
The reason the type does not appear in the module itself is because we wish
<emphasis>all</emphasis> modules to have access to the internals of a type. In
C++ parlance, all &TONTO; modules are friendly.</para></listitem>

<listitem><para><emphasis>Use long decriptive names</emphasis>. Most of the
effort in documentation can be made easier if you use descriptive names for
routines and variables. Please, spend some time on this.</para></listitem>

<listitem><para><emphasis>Ensure routines have few arguments</emphasis>.
Routines that have few, if any, arguments are easier to remember and easier to
use.</para></listitem>

<listitem><para><emphasis>Write simple routines</emphasis>. Is there more to be
said?</para></listitem>

<listitem><para><emphasis>Write short routines</emphasis>. There isn't really
any reason to write a long routine; a long routine can be separated into
separate tasks for the current module, or farmed out to tasks belonging to other
modules.</para></listitem>

<listitem><para><emphasis>Use preconditions liberally</emphasis>. When
developing, it is highly recomended that you use the
<literal>-DUSE_PER_AND_POST_CONDITIONS</literal> switch and the
<literal>-DUSE_CALL_STACK_MANAGEMENT</literal>
switch. By the same token, make sure you include before the start of a routine a 
a set of <literal>ENSURE</literal> commands which will detect any missing data
or incorrect conditions required for the routine to perform its task. Remember,
these can eventually be switched off and you will pay no performance penalty,
but you will get the productivity gain in fewer bugs.</para></listitem>

<listitem><para><emphasis>Mark routines <literal>[leaky]</literal></emphasis>.
It is useful to keep track of where your memory is going. Spend some time to
reduce the number of routines which deliberately have memory leaks, and for
those where leaks are unavoidable, mark them as
<literal>[leaky]</literal>.</para></listitem>

<listitem><para><emphasis>Add functionality to low-level modules where
possible</emphasis>. Try not to make your top-level routines too heavy. The more
you can place in lower level modules which are well decoupled, the faster will
be your compile times, and the quicker will your program be debugged, since
lower level routines are more exhaustively used.</para></listitem>

<listitem><para><emphasis>Do not remove your initial code; provide
redundancy</emphasis>. Often your initial code is very sinmple and clear. Then
it becomes wrecked asyou make it more efficient.  Please do not delete your
initial simple code. Routine names can be overloaded, and when bugs are detected
your simple code will be invaulable in testing.</para></listitem>

<listitem><para><emphasis>Provide all the conventional routines</emphasis>. They
will usually be needed at some stage.</para></listitem>

<listitem><para><emphasis>When using string case statements, use alphabetical
order</emphasis>. You should also use the <literal>UNKNOWN(word)</literal> so
that when there is an error, and alphabetical list of allowed options is echoed
to the user.</para></listitem>
</itemizedlist>

</sect1>

<!-- *********************************************************************** -->

<sect1 id="large-modules">
<title>Large modules</title>

<para>Sometimes, in order to avoid long compilation times, it is useful for to
split up long modules into parts in which different authors are working.</para>

<para>This has been done, for example, in the <literal>MOL</literal> module,
which has been split into <literal>MOL_REAPER</literal>,
<literal>MOL_DYLAN</literal>, and <literal>MOL_CHRIS</literal>, as well as
<literal>MOL_MAIN</literal>.</para>

<para>Unless the module is perpetually under development, this practice should
probably be avoided.</para>

</sect1>

<!-- *********************************************************************** -->

<sect1 id="function-arguments">
<title>Function arguments</title>

<para>Sometimes you may want to design routines which takes as its first
argument a function as an argument.</para>

<para>Currently, such functions are placed in the module according to the type
of argument the function returns, and these arguments are marked as
<literal>[routinal]</literal>.  What that means is that the first argument is
<emphasis>not</emphasis> assumed to be of the type contained inthe module, but
must be specified manually, say by an interface specification. For an example,
see the <literal>minimise_brent</literal> routine in the <literal>REAL</literal>
module.</para>

<para>Usually, such routinals are used in conjunction with a routine with the
<literal>[selfless]</literal> attribute.  Selfless routines are those whose
first argument is <emphasis>not</emphasis> the <literal>self</literal> argument
of type contained in the module. Instead, the <literal>self</literal> variable
is set at the first line of the selfless routine to be equal to a
<literal>saved_self</literal> variable which is globally visible within the
module. In this was, a selfless routine can be passed to a routinal (typically a
minimiser) which then calls the passed routine during the course of its
execution. The called selfless routine can have access to the current
<literal>self</literal> variable. In this way, a function and some of its
arguments can be passed to a minimiser. In some languages this is called
<quote>closure</quote>.  For an example, see the <literal>chi2</literal>
selfless routine in the <literal>CRSYTAL</literal> module.</para>

<para>Compilers are not often able to cope with this mechanism, so
unfortunately, it is rarely used.</para>

<para>Currently, there is no convention in &TONTO; on which module to place
routines which take subroutines as their first argument. Such routines are not
encountered in &TONTO;.</para>

</sect1>

<!-- *********************************************************************** -->

<sect1 id="run-xxxx">
<title>Writing the main <literal>run_XXXX</literal> program</title>

<para>If you want to make an executable from your module, you will have to write
a main program for it.</para>

<para>If your module is called <literal>XXXX</literal>, then the main program
should be called <literal>run_XXXX.foo</literal>.</para>

<para>Typically, in a production module, this main program will have only a
<literal>tonto</literal> initialization call, and then a call to a
<literal>read</literal> routine or a <literal>main</literal> routine. For
example, the <literal>run_mol.foo</literal> program looks like this:
<programlisting>
program run_mol
! $Id: tonto.docbook,v 1.2 2003/02/19 07:49:44 reaper Exp $

   use TYPES
   use SYSTEM
   use MOL_MAIN ,ONLY:main_

#  include "macros"

   implicit none

   MOL* :: m

   tonto.initialize
   m.main

end 
</programlisting></para>

<para>Alternatively, you can write a main program to perform a particular task.
For example, the following main program <literal>run_realmat.foo</literal> solves
for the eigenvalues and eigenvectors of the unit 2x2 matrix
<programlisting>
program run_realmat
! $Id: tonto.docbook,v 1.2 2003/02/19 07:49:44 reaper Exp $
  use TYPES
  use REALVEC
  use REALMAT

# include "macros"

  implicit none
  
  REALMAT* :: matrix
  REALMAT* :: eigenvectors
  REALVEC* :: eigenvalues

  matrix.create(2,2)
  eigenvectors.create(2,2)
  eigenvalues.create(2)

  matrix = ONE

  matrix.solve_eigenproblem(eigenvalues,eigenvectors)

  write(*,*) eigenvalues

end 
</programlisting></para>

<para>You must remember to <literal>USE</literal> those modules from which you
call routines. Here we must at least use the <literal>REALVEC</literal> and
<literal>REALMAT</literal> modules, since we use the <literal>create</literal>
routines in <literal>REALVEC</literal> and <literal>REALMAT</literal>, and we use the
<literal>solve_eigenproblem</literal> routine in <literal>REALMAT</literal>.</para>

<para>You can find examples of other one-off programs in <xref
linkend="example-programs"/>.</para>

</sect1>

<!-- *********************************************************************** -->

<sect1 id="hypocrites">
<title>Are we hypocrites?</title>

<para>You may notice that not all code in &TONTO; adheres to the guidelines
specified here.</para>

<para>That is because we are only human and we haven't achieved perfection
yet.</para>

<para>Nevertheless, we do at least <emphasis>try</emphasis> to stick to the
above guideleines, especially for released code. Eventually we will get
there.</para>

</sect1>
</chapter>

<!-- *********************************************************************** -->
<!-- *********************************************************************** -->

<chapter id="example-programs">
<title>Examples of simple &TONTO; programs</title>

<para>This chapter gives you some examples of simple &TONTO; programs that you
can study, compile, or extend.</para>

<para>All the programs are distributed with &TONTO; in the
<literal>foofiles</literal> directory, in files named
<literal>run_XXXX.foo</literal>, where <literal>XXXX</literal> is the name of
the module mainly being used.</para>

<para>To compile these programs just type <literal>make run_XXXX.x</literal> in
the <literal>tonto</literal> directory; an executable
<literal>run_XXXX.x</literal> will then be produced.</para>

<para>To run the program, just tupe <literal>run_XXXX.x</literal>.</para>

<para>Except for the <literal>TEXTFILE</literal> example, all results are
deposited in the "stdout" file.</para>

<!-- *********************************************************************** -->

<sect1 id="module-textfile">
<title>The <literal>TEXTFILE</literal> module</title>

<para>One of the most often used modules is <literal>TEXTFILE</literal>, which
is concerned with reading and writing ASCII textfiles. The following example
illustrates the basic use of this module, which used repeatedly in the following
examples.</para>

<para>You will need to edit a file "in" to get this program to work. This is
described in the program body, and the results are written to your terminal
screen.</para>

<sect2 id="code-textfile">
<title>Code</title>

<programlisting>
program run_textfile

   use TYPES              ! Always use the TYPES module
   use SYSTEM             ! Always use the SYSTEM module
   use STR
   use TEXTFILE

#include "macros"

   implicit none

   TEXTFILE*  :: in
   STR  :: junk,name
   REALMAT(2,2) :: m

   tonto.initialize      ! Always initialise "tonto" before anything

   stdout.create_stdout  ! Always create "stdout" before you use it
   stdout.flush          ! If you do not open "stdout" it goes to the terminal
   stdout.flush
   stdout.text('Hello! Welcome to TONTO!')
   stdout.flush

   stdout.flush
   stdout.text('This message goes to the stdout -- unless I explicitly "open" the "stdout" file.')

   stdout.flush
   stdout.text('Now edit a file "in" and put your name in it, and also a matrix of four numbers.')
   stdout.flush
   stdout.text('Type ^Z now to suspend this program. When you are done editing the file, recommence')
   stdout.text('the program by typing "fg" &lt;return&gt; and then "c" &lt;return&gt; to continue on.')

   ! Pause a while by reading a junk string from "stdin". We can't do more than this
   ! because fortran doesn't handle a stream very well yet.

   stdin.create_stdin   ! Always create "stdin" before using it
   stdin.read(junk)     ! Always open "stdin" except in this case where you want to "pause"

   ! Open the file "in" and read the info

   stdout.flush
   stdout.text('Explicitly opening the file "in" now ...')
   stdout.flush
   stdout.flush

   in.create("in")
   in.open(for="read")
   in.read(name)
   in.read(m)
   in.close

   stdout.flush
   stdout.text('Hello ' // name.trim// '!')
   stdout.flush
   stdout.text('If you see this message that means you succesfully edited the file "in"!') 
   stdout.flush

   stdout.flush
   stdout.text('Here is the matrix you entered:')
   stdout.flush
   stdout.put(m)

   stdout.flush
   stdout.text('Here is the same matrix printed witha different number of decimal places:')
   stdout.flush

   stdout.set_real_precision(3)
   stdout.set_real_width(8)
   stdout.put(m)

   stdout.flush
   stdout.text('Here is the first column:')
   stdout.flush
   stdout.put(m(:,1),"column")

   stdout.flush
   stdout.text('Here is the second column:')
   stdout.flush
   stdout.put(m(:,2),"column")

   stdout.flush
   stdout.text('Good luck with thye rest of &TONTO; ...')
   stdout.flush

end
</programlisting>
</sect2>

<sect2 id="results-textfile">
<title>Results</title>

<programlisting>
Hello! Welcome to TONTO!
 
 
This message goes to the stdout -- unless I explicitly "open" the "stdout" file.
 
Now edit a file "in" and put your name in it, and also a matrix of four numbers.
 
Type ^Z now to suspend this program. When you are done editing the file, recommence
the program by typing "fg" &lt;return&gt; and then "c" &lt;return&gt; to continue on.
c
 
Explicitly opening the file "in" now ...
 
 
 
Hello dylan!
 
If you see this message that means you succesfully edited the file "in"!
 
 
Here is the matrix you entered:
 
                            1                   2
 
        1         1.000000000         2.000000000
        2         3.000000000         4.000000000
 
Here is the same matrix printed witha different number of decimal places:
 
                1       2
 
        1   1.000   2.000
        2   3.000   4.000
 
Here is the first column:
 
        1   1.000
        2   3.000
 
Here is the second column:
 
        1   2.000
        2   4.000
 
Good luck with thye rest of &TONTO; ...
</programlisting>

</sect2>
</sect1>

<!-- *********************************************************************** -->

<sect1 id="module-buffer">
<title>The <literal>BUFFER</literal> module</title>

<para>The <literal>BUFFER</literal> is the basic component of a
<literal>TEXTFILE</literal> but is is very useful for many string
manupulations.</para>

<sect2 id="code-buffer">
<title>Code</title>
<programlisting>
program run_buffer

   use TYPES
   use SYSTEM
   use STR
   use BUFFER
   use TEXTFILE

#include "macros"

   implicit none

   BUFFER :: b
   STR :: word 
   REAL :: real
   INT :: int

   tonto.initialize

   stdout.create_stdout
   stdout.open
  
   stdout.text("I am creating a buffer below ...")
   stdout.flush

   b.set(" this is a buffer string, 0.1 0.2 10 ! comment","!")

   stdout.show("buffer string =",b.string)
   stdout.show("item start    =",b.item_start)
   stdout.show("item end      =",b.item_end)
   stdout.show("item index    =",b.item_index)
   stdout.show("n_items       =",b.n_items)
   stdout.show("analysed      =",b.analysed)
   stdout.show("comment_chars =",b.comment_chars)

   stdout.flush
   stdout.text("Now I am extracting from this buffer ...")
   stdout.flush

   b.get(word)  
   stdout.show("1st word =",word)

   b.get(word)  
   stdout.show("2nd word =",word)

   b.get(word)  
   stdout.show("3rd word =",word)

   b.get(word)  
   stdout.show("4th word =",word)

   b.get(word)  
   stdout.show("5th word =",word)

   b.get(word)  
   stdout.show("6th word =",word)

   b.get(real)  
   stdout.show("7th real  =",real)

   b.get(int)  
   stdout.show("8th int  =",int)

   stdout.flush
   stdout.text("Now move back to the 2nd item and get it ...")
   stdout.flush

   b.move_to_item(2)  
   b.get(word)  
   stdout.show("2nd word =",word)

   stdout.flush
   stdout.text("Now I will print out a cursor to the current position")
   stdout.flush

   stdout.flush
   stdout.show("buffer string =", b.string)
   stdout.text("Cursor---------"//b.cursor_pointer.align_left.trim)

   stdout.flush
   stdout.text('The last item I processed was "'// b.previous_item.trim //'"')

end 
</programlisting>
</sect2>

<sect2 id="results-buffer">
<title>Results</title>
<programlisting>
I am creating a buffer below ...

buffer string = this is a buffer string, 0.1 0.2 10 ! comment
item start    =        0
item end      =        0
item index    =        0
n_items       =        8
analysed      =        T
comment_chars =                   !

Now I am extracting from this buffer ...

1st word =                this
2nd word =                  is
3rd word =                   a
4th word =              buffer
5th word =             string,
6th word =                 0.1
7th real  =         0.200000000
8th int  =       10

Now move back to the 2nd item and get it ...

2nd word =                  is

Now I will print out a cursor to the current position


buffer string = this is a buffer string, 0.1 0.2 10 ! comment
Cursor----------------^

The last item I processed was "is"
</programlisting>
</sect2>
</sect1>

<!-- *********************************************************************** -->

<sect1 id="module-int">
<title>The <literal>INT</literal> module</title>

<para>The <literal>INT</literal> module is concerned with integers. This
illustrates basic functionality including a routine to return the Legendre
polynomial coefficients.</para>

<sect2 id="code-int">
<title>Code</title>
<programlisting>
program run_int

  use TYPES
  use SYSTEM
  use STR
  use INT
  use REAL
  use TEXTFILE

#include "macros"

  implicit none

  INT  :: i
  REALVEC* :: answer

  tonto.initialize

  stdout.create_stdout
  stdout.open

  stdout.flush
  stdout.text("Factorials:")
  stdout.flush
  do i = 0,15
    stdout.text( i.to_str.trim //"! = " &
              // i.factorial.to_str_no_zeros.trim )
  end

  stdout.flush
  stdout.text("Double factorials:")
  stdout.flush
  do i = 0,15
    stdout.text( i.to_str.trim //"!! = " &
              // i.double_factorial.to_str_no_zeros.trim )
  end

  stdout.set_real_precision(2)
  stdout.set_real_width(7)
  stdout.set_fields(10)

  stdout.flush
  stdout.text("Coefficients of the Legendre polynomials:")
  stdout.flush
  do i = 0,8
    allocate(answer(i+1))
    answer = i.legendre_polynomials
    stdout.show("n = "//i.to_str.trim//", coeffs = ",answer)
    deallocate(answer)
  end

end 
</programlisting>
</sect2>

<sect2 id="results-int">
<title>Results</title>
<programlisting>
Factorials:

0! = 1
1! = 1
2! = 2
3! = 6
4! = 24
5! = 120
6! = 720
7! = 5040
8! = 40320
9! = 362880
10! = 3628800
11! = 39916800
12! = 479001600
13! = 6227020800
14! = 87178291200
15! = 1307674368000

Double factorials:

0!! = 1
1!! = 1
2!! = 3
3!! = 15
4!! = 105
5!! = 945
6!! = 10395
7!! = 135135
8!! = 2027025
9!! = 34459425
10!! = 654729075
11!! = 13749310575
12!! = 316234143225
13!! = 7905853580625
14!! = 213458046676875
15!! = 6190283353629375

Coefficients of the Legendre polynomials:

n = 0, coeffs =    1.00
n = 1, coeffs =    0.00   1.00
n = 2, coeffs =   -0.50   0.00   1.50
n = 3, coeffs =    0.00  -1.50   0.00   2.50
n = 4, coeffs =    0.38   0.00  -3.75   0.00   4.38
n = 5, coeffs =    0.00   1.88   0.00  -8.75   0.00   7.88
n = 6, coeffs =   -0.31   0.00   6.56   0.00 -19.69   0.00  14.44
n = 7, coeffs =    0.00  -2.19   0.00  19.69   0.00 -43.31   0.00  26.81
n = 8, coeffs =    0.27   0.00  -9.84   0.00  54.14   0.00 -93.84   0.00  50.27
</programlisting>
</sect2>
</sect1>

<!-- *********************************************************************** -->

<sect1 id="module-strvec">
<title>The <literal>STRVEC</literal> module</title>

<para>The <literal>STRVEC</literal> module is concerned lists of fixed size
strings.  This illustrates basic conversions and sorting.</para>

<sect2 id="code-strvec">
<title>Code</title>
<programlisting>
program run_strvec

   use TYPES
   use SYSTEM
   use STRVEC
   use TEXTFILE

#  include "macros"

   implicit none

   STRVEC* :: s 

   tonto.initialize
   stdout.create_stdout
   stdout.open
  
   s.create( ["hello  ", "how    ", "are    ", "you    ", "finding", &
              "TONTO  ", "?      ", "hello  ", "?      ", "?      "] )

   stdout.flush
   stdout.text("Here is a vector of strings:")
   stdout.flush
   stdout.put(s,"column")

   stdout.flush
   stdout.text("Here are the same strings sorted in alpabetical order.")
   stdout.text("In fortran, all capitals come before lower cases!")
   stdout.flush
   s.sort
   stdout.put(s,"column")

   stdout.flush
   stdout.text("Here are the same strings in upper case:")
   stdout.flush
   s.to_upper_case
   stdout.put(s,"column")

   stdout.flush
   stdout.text("Now I remove all repetitions:")
   stdout.flush
   s.remove_repetitions
   stdout.put(s,"column")

end 
</programlisting>
</sect2>

<sect2 id="results-strvec">
<title>Results</title>
<programlisting>
Here is a vector of strings:

        1               hello
        2                 how
        3                 are
        4                 you
        5             finding
        6               TONTO
        7                   ?
        8               hello
        9                   ?
       10                   ?

Here are the same strings sorted in alpabetical order.
In fortran, all capitals come before lower cases!

        1                   ?
        2                   ?
        3                   ?
        4               TONTO
        5                 are
        6             finding
        7               hello
        8               hello
        9                 how
       10                 you

Here are the same strings in upper case:

        1                   ?
        2                   ?
        3                   ?
        4               TONTO
        5                 ARE
        6             FINDING
        7               HELLO
        8               HELLO
        9                 HOW
       10                 YOU

Now I remove all repetitions:

        1                   ?
        2               TONTO
        3                 ARE
        4             FINDING
        5               HELLO
        6                 HOW
        7                 YOU
</programlisting>

</sect2>
</sect1>

<!-- *********************************************************************** -->

<sect1 id="module-real">
<title>The <literal>REAL</literal> module</title>

<para>The <literal>REAL</literal> module is concerned with double precision
numbers. In this program we illustrate how functions which take and return a
double precision number may be minimised.</para>

<para>The actual functions to be minimised are provided in a separate module
<literal>TEST</literal>.  Note that the routines are all maked
<literal>[selfless]</literal> which means, unlike every other routine in
&TONTO;, there is no <literal>self</literal> variable automatically declared as
the first variable.</para>

<sect2 id="code-real">
<title>Code</title>
<programlisting>
program run_real

   use TYPES
   use SYSTEM
   use REAL
   use TEXTFILE
   use TEST

#  include "macros"

   implicit none
  
   REAL :: val,x,y
   REAL :: a,b,c,fa,fb,fc,fx
   INT :: i

   tonto.initialize
   stdout.create_stdout
   stdout.open

   stdout.text("10 random numbers:")
   stdout.flush
   do i=1,10
     a.to_random_normal
     stdout.put(a,flush=1)
   end


   stdout.flush
   stdout.text("Find an initial bracket for the function (x-1)^2 + 1")
   stdout.text("which contains its minimum value")
   stdout.flush

   a = 1.8
   b = 1.5
   c = 1.3
   stdout.text("Initially")
   stdout.show("a  =",a)
   stdout.show("b  =",b)
   stdout.show("c  =",c)
   stdout.show("fa =",func(a))
   stdout.show("fb =",func(b))
   stdout.show("fc =",func(c))

   func.find_initial_bracket(a,b,c,fa,fb,fc)

   stdout.flush
   stdout.text("Finally")
   stdout.show("a  =",a)
   stdout.show("b  =",b)
   stdout.show("c  =",c)
   stdout.show("fa =",fa)
   stdout.show("fb =",fb)
   stdout.show("fc =",fc)

   stdout.flush
   stdout.text("Now minimise the function ...")
   stdout.flush

   func.minimise_brent(a,b,c,x,fx,0.00001d0)

   stdout.show("x_min  =",x)
   stdout.show("f_min  =",fx)

   stdout.flush
   stdout.text("Now integrate it from 1->2:")
   stdout.flush

   val = func.integrate_adaptive_trapezoid(1.0d0,2.0d0,TOL(8))
   stdout.show("Answer =",val)

   stdout.flush
   stdout.text("Integrate arcsin using adaptive trapezoid method")
   stdout.text("from 0->1/2")
   stdout.flush

   val = arcsin.integrate_adaptive_trapezoid(0.0d0,0.5d0,TOL(8))
   stdout.show("Answer =",val)

   stdout.flush
   stdout.text("Integrate arcsin using adaptive simpson method")
   stdout.text("from 0->1/2")
   stdout.flush

   val = arcsin.integrate_adaptive_simpson(0.0d0,0.5d0,TOL(8))
   stdout.show("Answer =",val)

end 
</programlisting>

<para>And here is the relevant part of the <literal>TEST</literal>
module:</para>

<programlisting>
module TEST

   use TYPES
   use SYSTEM
   use REALVEC
   use REALMAT

   implicit none

#  include "macros"

   public func
   public arcsin

contains

   func(x) result (res) [selfless]
   !  A test function for minimising
      REAL :: x,res
      res = (x-1)*(x-1) + 1
   end

   arcsin(x) result (res) [selfless]
   ! Return the arcsin for x. Corrects bug for numbers close to 1.
      REAL :: x,res
      if (abs(abs(x)-ONE)&lt;TOL(5)) then
         if (x&lt;0) then; res = -PI/TWO
         else;             res = +PI/TWO
         end
      else
         res = asin(x)
      end
   end

end
</programlisting>
</sect2>

<sect2 id="results-real">
<title>Results</title>
<programlisting>
10 random numbers:

         0.905442547
        -0.350476891
        -0.945527330
        -1.354792694
         0.992321475
        -0.643725104
         0.177373302
        -1.877569698
         0.126510113
         0.281241703

Find an initial bracket for the function (x-1)^2 + 1
which contains its minimum value

Initially
a  =         1.800000000
b  =         1.500000000
c  =         1.300000000
fa =         1.640000000
fb =         1.250000000
fc =         1.090000000

Finally
a  =         0.229179586
b  =         1.014589798
c  =         1.500000000
fa =         1.594164111
fb =         1.000212862
fc =         1.250000000

Now minimise the function ...

x_min  =         1.000000000
f_min  =         1.000000000

Now integrate it from 1->2:

Answer =         1.333333333

Integrate arcsin using adaptive trapezoid method
from 0-&gt;1/2

Answer =         0.127824792

Integrate arcsin using adaptive simpson method
from 0-&gt;1/2

Answer =         0.127824792
</programlisting>
</sect2>
</sect1>

<!-- *********************************************************************** -->

<sect1 id="module-vec">
<title>The <literal>REALVEC</literal> module</title>

<para>The <literal>REALVEC</literal> module is concerned with vectors of double
precision numbers.  This programs illustrates the minimisation of vector
functions using various methods. It is very easy.</para>

<para>As in the case of the <literal>REAL</literal> module, the actual functions
to be minimised are provided in a separate module <literal>TEST</literal>.  Note
that the routines are all made <literal>[selfless]</literal> which means, unlike
every other routine in &TONTO;, there is no <literal>self</literal> variable
automatically declared as the first variable.</para>

<sect2 id="code-vec">
<title>Code</title>
<programlisting>
program run_realvec

   use TYPES
   use SYSTEM
   use REALVEC
   use TEXTFILE
   use TEST

#  include "macros"

   implicit none

   REALVEC(2) :: p
   REALMAT(2,2) :: directions
   REAL :: fret,tol,ftol
   STR :: algorithm

   tonto.initialize

   stdout.create_stdout
   stdout.open

   stdout.flush
   stdout.text("Minimise the function (x-1)^2 + (y-1)^2 + 1 using the")
   stdout.text("Powell method")
   stdout.flush
   stdout.text("This function is defined in the TEST module")
   stdout.flush
  
   tol = TOL(7)
   ftol = TOL(7)
   p = [ 0.1, 0.1 ]
   directions(1,1) = 1
   directions(2,1) = 1
   directions(1,2) = 1
   directions(2,2) =-1

   stdout.flush
   stdout.show("Start point   =",p)
   stdout.flush
   stdout.text("Initial directions (as columns):")
   stdout.put(directions)

   stdout.flush
   stdout.text("Minimise the function ...")

   funk.minimise_powell(p,directions,fret,tol,ftol)

   stdout.flush
   stdout.text("Answer:")
   stdout.show("Minimum point =",p)
   stdout.show("Minimum value =",fret)

   stdout.flush
   stdout.text("Now minimise the same functions using the FR")
   stdout.text("(Fletcher-Reeves) method. This requires the ")
   stdout.text("the derivative of the function as well.")
   stdout.flush

   p = [ 0.1, 0.1 ]
   algorithm = "Fletcher-Reeves"
   funk.minimise_FRPR(dfunk,p,fret,tol,ftol,algorithm)

   stdout.flush
   stdout.text("Answer:")
   stdout.show("Minimum point =",p)
   stdout.show("Minimum value =",fret)

   stdout.flush
   stdout.text("Now minimise the same functions using the BFGS")
   stdout.text("(Broyden-Fletcher-Goldfarb-Shanno) method. This also")
   stdout.text("requires the derivative of the function")
   stdout.flush


   p = [ 0.1, 0.1 ]
   funk.minimise_BFGS(dfunk,p,fret,tol,ftol)

   stdout.flush
   stdout.text("Answer:")
   stdout.show("Minimum point =",p)
   stdout.show("Minimum value =",fret)

end
</programlisting>

<para>And here is the relevant part of the <literal>TEST</literal>
module:</para>

<programlisting>
module TEST

   use TYPES
   use SYSTEM
   use REALVEC
   use REALMAT

   implicit none

#  include "macros"

   public funk
   public dfunk

contains

   funk(p) result (res) [selfless]
   ! A test function for minimising
      REALVEC(2) :: p
      REAL :: res
      REAL :: x,y
      x = p(1); y = p(2)
      res = (x-1)*(x-1) + (y-1)*(y-1) + 1
   end

   dfunk(p) result (res) [selfless]
   ! A test function for minimising
      REALVEC(2) :: p,res
      REAL :: x,y
      x = p(1); y = p(2)
      res(1) = 2*(x-1)
      res(2) = 2*(y-1)
   end

end
</programlisting>
</sect2>

<sect2 id="results-vec">
<title>Results</title>
<programlisting>
Minimise the function (x-1)^2 + (y-1)^2 + 1 using the
Powell method

This function is defined in the TEST module


Start point   =         0.100000001         0.100000001

Initial directions (as columns):
                            1                   2

        1         1.000000000         1.000000000
        2         1.000000000        -1.000000000

Minimise the function ...

Answer:
Minimum point =         0.999999995         0.999999995
Minimum value =         1.000000000

Now minimise the same functions using the FR
(Fletcher-Reeves) method. This requires the
the derivative of the function as well.


Answer:
Minimum point =         1.000000000         1.000000000
Minimum value =         1.000000000

Now minimise the same functions using the BFGS
(Broyden-Fletcher-Goldfarb-Shanno) method. This also
requires the derivative of the function


Answer:
Minimum point =         1.000000000         1.000000000
Minimum value =         1.000000000
</programlisting>
</sect2>
</sect1>

<!-- *********************************************************************** -->

<sect1 id="module-gaussian2">
<title>The <literal>GAUSSIAN2</literal> and <literal>DFTGRID</literal> modules</title>

<para>The <literal>GAUSSIAN2</literal> module is concerned with pairs of shells
of gaussian functions.  This program illustrates the main use of the module---to
calculate integrals betwen pairs of shells. In addition, the
<literal>DFTGRID</literal> module is used to numerically integrate some of the
integrals to check them. A function required for this numerical integration is
provided in the <literal>TEST</literal> module and reproduced below.</para>

<sect2 id="code-gaussian2">
<title>Code</title>
<programlisting>
program run_gaussian2

   use TYPES
   use SYSTEM
   use REALMAT
   use TEXTFILE
   use GAUSSIAN2
   use DFTGRID
   use TEST

#  include "macros"

   implicit none

   GAUSSIAN2 :: g
   REALMAT(10,6) :: S
   DFTGRID*  :: d

   tonto.initialize
   stdout.create_stdout
   stdout.open

   stdout.flush
   stdout.text("Make the overlap integrals between two gaussian functions:")
   stdout.flush
   stdout.text("--an F function at (0,0,0) with exponent 0.3, and")
   stdout.text("--a  D function at (0,0,1) with exponent 0.5")
   stdout.flush

   g.set(l_a=3,pos_a=[0.0d0,0.0d0,0.0d0],ex_a=0.3d0, &
         l_b=2,pos_b=[0.0d0,0.0d0,0.1d0],ex_b=0.5d0)

   g.make_overlap_ints(S)

   stdout.text("Answer:")
   stdout.put(S)

   stdout.flush
   stdout.text("Now make the nuclear attaction integrals for the same functions")
   stdout.text("assuming the nucleus of unit charge is at (0,1,0)")
   stdout.flush

   g.make_nuclear_attraction_ints(S,c=[0.0d0,1.0d0,0.0d0])

   stdout.set_fields(3)

   stdout.text("Answer:")
   stdout.put(S)

   stdout.flush
   stdout.text("Now do the last integration numerically with a default DFT grid")
   stdout.flush

   d.create
   d.set_defaults

   d.make_matrix_elements_of(v010,g,S) 

   stdout.text("Answer:")
   stdout.put(S)

end
</programlisting>

<para>And here is the relevant part of the <literal>TEST</literal>
module:</para>
<programlisting>
module TEST

   use TYPES
   use SYSTEM
   use REALVEC
   use REALMAT

   implicit none

#  include "macros"

   public v010

contains

   v010(grid,pts)  [selfless]
   ! The potential "grid" from a unit charge at (0,1,0)
      REALVEC :: grid
      REALMAT :: pts
      INT :: i
      REAL :: x,y,z
      ENSURE(pts.dim2==3,"incorrect pts array")
      ENSURE(grid.dim==pts.dim1,"incorrect pts array")
      do i = 1,grid.dim
         x = pts(i,1)
         y = pts(i,2)
         z = pts(i,3)
         grid(i) = ONE/sqrt(x*x + (y-1)*(y-1) + z*z)
      end
   end

end
</programlisting>
</sect2>

<sect2 id="results-gaussian2">
<title>Results</title>
<programlisting>
Make the overlap integrals between two gaussian functions:

--an F function at (0,0,0) with exponent 0.3, and
--a  D function at (0,0,1) with exponent 0.5

Answer:
                            1                   2                   3

        1         0.000000000         0.000000000         0.000000000
        2         0.000000000         0.000000000         0.000000000
        3         0.570086401         0.570086401         1.022223439
        4         0.000000000         0.000000000         0.000000000
        5         0.568901274         0.189633730        -0.037500070
        6         0.000000000         0.000000000         0.000000000
        7         0.189633730         0.568901274        -0.037500070
        8         0.000000000         0.000000000         0.000000000
        9         0.000000000         0.000000000         0.000000000
       10         0.000000000         0.000000000         0.000000000

                            4                   5                   6

        1         0.000000000        -0.341340764         0.000000000
        2         0.000000000         0.000000000        -0.341340764
        3         0.000000000         0.000000000         0.000000000
        4         0.000000000         0.000000000        -0.113780238
        5         0.000000000         0.000000000         0.000000000
        6         0.000000000        -0.113780238         0.000000000
        7         0.000000000         0.000000000         0.000000000
        8         0.000000000         0.264776096         0.000000000
        9         0.000000000         0.000000000         0.264776096
       10         0.189633730         0.000000000         0.000000000

Now make the nuclear attaction integrals for the same functions
assuming the nucleus of unit charge is at (0,1,0)

Answer:
                            1                   2                   3

        1         0.000000000         0.000000000         0.000000000
        2         0.636763789         4.019132228         0.646818792
        3         0.241830653         0.258244683         0.325292502
        4         0.542365560         0.636763789         0.182672067
        5         0.241377093         0.085923808        -0.051936955
        6         0.000000000         0.000000000         0.000000000
        7         0.085923808         0.279895783        -0.071817372
        8         0.000000000         0.000000000         0.000000000
        9         0.181576872         0.639360793         0.540965498
       10         0.000000000         0.000000000         0.000000000

                            4                   5                   6

        1         0.542365560        -0.199062812         0.000000000
        2         0.000000000         0.000000000        -0.315145144
        3         0.000000000         0.000000000         0.541667992
        4         0.000000000         0.000000000        -0.079072965
        5         0.000000000         0.000000000         0.179768987
        6         0.636763789        -0.079072965         0.000000000
        7         0.000000000         0.000000000         0.632993155
        8         0.181576872         0.094212783         0.000000000
        9         0.000000000         0.000000000         0.092388672
       10         0.085923808         0.179768987         0.000000000

Now do the last integration numerically with a default DFT grid

Answer:
                            1                   2                   3

        1         0.000000000         0.000000000         0.000000000
        2         0.636767966         4.014766773         0.646766758
        3         0.241830651         0.258244191         0.325292449
        4         0.542365396         0.636767966         0.182672052
        5         0.241377047         0.085924086        -0.051936949
        6         0.000000000         0.000000000         0.000000000
        7         0.085924086         0.279921708        -0.071817050
        8         0.000000000         0.000000000         0.000000000
        9         0.181576877         0.639358039         0.540965447
       10         0.000000000         0.000000000         0.000000000

                            4                   5                   6

        1         0.542365396        -0.199062777         0.000000000
        2         0.000000000         0.000000000        -0.314679742
        3         0.000000000         0.000000000         0.541667922
        4         0.000000000         0.000000000        -0.079073069
        5         0.000000000         0.000000000         0.179768964
        6         0.636767966        -0.079073069         0.000000000
        7         0.000000000         0.000000000         0.632987859
        8         0.181576877         0.094212783         0.000000000
        9         0.000000000         0.000000000         0.092388462
       10         0.085924086         0.179768964         0.000000000
</programlisting>
</sect2>
</sect1>

<!-- *********************************************************************** -->

<sect1 id="module-shell4">
<title>The <literal>SHELL4</literal> module</title>

<para>The <literal>SHELL4</literal> module is concerned with quartets of
(segmented) contracted shells of gaussian functions. Each component of the shell
is assumed normalised, unlike the <literal>GAUSSIAN2</literal> module.  This
illustrates the calculation of electron repulsion integrals (ERI's) using Roland
Lindh's method, and also the basic HONDO Rys method. Other integral types such
as spin-orbit integrals are also available.</para>

<sect2 id="code-shell4">
<title>Code</title>
<programlisting>
program run_shell4

   use TYPES
   use SYSTEM
   use TIME
   use INT
   use REALVEC
   use REALMAT4
   use TEXTFILE
   use SHELL4

#include "macros"

   implicit none

   SHELL4* :: s
   REALMAT4* :: I

   tonto.initialize
   stdout.create_stdout
   stdout.open

   stdout.flush
   stdout.text("Here is a shell quartet:")
   stdout.flush

   s.create 

   s.a.n_cc = 2
   s.b.n_cc = 2
   s.c.n_cc = 2
   s.d.n_cc = 2
   s.a.cc.create(2)
   s.b.cc.create(2)
   s.c.cc.create(2)
   s.d.cc.create(2)
   s.a.cc(1) = ONE
   s.b.cc(1) = ONE
   s.c.cc(1) = ONE
   s.d.cc(1) = ONE
   s.a.cc(2) = TWO
   s.b.cc(2) = TWO
   s.c.cc(2) = TWO
   s.d.cc(2) = TWO
   s.a.ex.create(2)
   s.b.ex.create(2)
   s.c.ex.create(2)
   s.d.ex.create(2)
   s.a.ex(1) = 2d0
   s.b.ex(1) = 1d0
   s.c.ex(1) = 50d0
   s.d.ex(1) = 0.1d0
   s.a.ex(2) = 20d0
   s.b.ex(2) = 10d0
   s.c.ex(2) = 5d0
   s.d.ex(2) = 1d0

   s.a.l = 0
   s.b.l = 2
   s.c.l = 0
   s.d.l = 1
   s.a.n_comp = s.a.l.n_comp
   s.b.n_comp = s.b.l.n_comp
   s.c.n_comp = s.c.l.n_comp
   s.d.n_comp = s.d.l.n_comp

   s.a.pos = [0.0d0, 0.2d0, 0.0d0]
   s.b.pos = [0.3d0,-0.3d0, 0.6d0]
   s.c.pos = [0.8d0, 0.5d0, 0.2d0]
   s.d.pos = [0.0d0, 0.2d0,-0.3d0]

   stdout.set_real_precision(6)
   stdout.set_real_width(11)
   stdout.set_int_width(3)

   s.put

   stdout.flush
   stdout.text("Here are the ERI integrals")
   stdout.flush
   stdout.text("Calculated using Roland Lindh's method:")
   stdout.flush

   I.create(1,6,1,3)

   s.get_eri(I)
   stdout.put(I)

   stdout.flush
   stdout.text("Calculated using the HONDO Rys method:")
   stdout.flush

   s.make_ERI_ints(I)
   stdout.put(I)

   I.destroy

end 
</programlisting>
</sect2>

<sect2 id="results-shell4">
<title>Results</title>
<programlisting>
Here is a shell quartet:

A shell l quantum number =  0
B shell l quantum number =  2
C shell l quantum number =  0
D shell l quantum number =  1
A position               =   0.000000   0.200000   0.000000
B position               =   0.300000  -0.300000   0.600000
C position               =   0.800000   0.500000   0.200000
D position               =   0.000000   0.200000  -0.300000

-------------------------------------------------------------------------------------------
  N       ex_a       cc_a       ex_b       cc_b       ex_c       cc_c       ex_d       cc_d
-------------------------------------------------------------------------------------------
  1   2.000000   1.000000   1.000000   1.000000  50.000000   1.000000   0.100000   1.000000
  2  20.000000   2.000000  10.000000   2.000000   5.000000   2.000000   1.000000   2.000000
-------------------------------------------------------------------------------------------

Here are the ERI integrals

Calculated using Roland Lindh's method:

  1  1  1  1   0.144952
  1  1  1  2   0.051436
  1  1  1  3   0.096599
  1  2  1  1   0.271482
  1  2  1  2   0.110750
  1  2  1  3   0.186951
  1  3  1  1   0.280387
  1  3  1  2   0.098742
  1  3  1  3   0.175365
  1  4  1  1  -0.053682
  1  4  1  2  -0.025814
  1  4  1  3  -0.042450
  1  5  1  1   0.069175
  1  5  1  2   0.030760
  1  5  1  3   0.051905
  1  6  1  1  -0.264489
  1  6  1  2  -0.104083
  1  6  1  3  -0.168855

Calculated using the HONDO Rys method:

  1  1  1  1   0.144952
  1  1  1  2   0.051436
  1  1  1  3   0.096599
  1  2  1  1   0.271482
  1  2  1  2   0.110750
  1  2  1  3   0.186951
  1  3  1  1   0.280387
  1  3  1  2   0.098742
  1  3  1  3   0.175365
  1  4  1  1  -0.053682
  1  4  1  2  -0.025814
  1  4  1  3  -0.042450
  1  5  1  1   0.069175
  1  5  1  2   0.030760
  1  5  1  3   0.051905
  1  6  1  1  -0.264489
  1  6  1  2  -0.104083
  1  6  1  3  -0.168855
</programlisting>
</sect2>
</sect1>
</chapter>

<!-- *********************************************************************** -->
<!-- *********************************************************************** -->

<chapter id="philosophy">
<title>The underlying philosophy of &TONTO;</title>

<para>Solving problems by modelling in computational chemistry is rapidly
becoming mainly an organizational one, of joining the appropriate and different
methodology together in flexible ways. We recognise this and it underlies the
whole structure of &TONTO;.</para>

<para>It is also our view that the great advances in computer software that have
been made over the last decades are due mainly to the free exchange of ideas and
information, including the availability of good free software. </para>

<para>Theoretical chemists, and quantum chemists in particular, are noted for
their strong ethic of <emphasis>standardizing</emphasis> the quality of
theoretical calculations for predicting experimental quantities.  Sadly, it
seems the ethic to standardize and share the code required for computational
chemistry is fast vanishing.  A number of reasons can be posited for this, some
of which are discussed below.  Whatever the reason, it is clear that the lack of
cooperation between researchers in computational chemistry has had, and will
continue to have a deleterious effect on the important role that computation
should be taking in chemistry.</para>

<para>The immediate effect of this is felt by students with fresh ideas, but who
spend endless hours doing what many other have done before them.  This is enough
to put many people off new methods development---which is at the heart of
computational chemistry.</para>

<!-- *********************************************************************** -->

<sect1 id="cooperation">
<title>Cooperation: naivet&eacute; or just good sense?</title>

<para>Some will argue that the idea of cooperation with software in science is
naive.</para>

<para>Let's rebutt common reasons against sharing code in a standard
format:</para>

<itemizedlist>
<listitem><para><emphasis>Sharing code won't work, hardly anyone writes
code</emphasis>.  The bulk of new computer code  is written by students or
post-docs.  People like you, who are reading this manual. A simple calculation
will show that there are a large number of you who are isolated and do not
belong to a <quote>famous</quote> group with in-house codes.  Even more people
would write code if they knew it could be easy.</para></listitem>

<listitem><para><emphasis>My problem is unique, no one else would write anything
like the code that I need for my problem</emphasis>.  It would be hard to
believe, given the number of people out there.  At the very least, you problem
might be broken down into parts which have been coded already.</para></listitem>

<listitem><para><emphasis>Sharing code won't work, no one can maintain a huge
package without being paid</emphasis>.  That is not true; All that is required
is ongoing demand for the packages features, and that comes down to you. If you
need the package for something, then you will service it so it works for you.
There is plenty of evidence that free packages can survive and develop. Linux
and gcc are examples.</para></listitem>

<listitem><para><emphasis>It requires an expert to write computational chemistry
codes</emphasis>.  Again, a fallacy. Only some parts require experts. Anyone can
write a Hartree-Fock program if they have a routine that gives them integrals.
And anyway, the parts that require experts (like, for example, integrals) are
mainly written by students or post-docs who are supervised by
experts.</para></listitem>

<listitem><para><emphasis>What counts is writing papers, not standardized
share-able code</emphasis>.  You are being inconsistent. Papers are a standard
way of sharing knowledge.  When the knowledge is based on new code, that should
be shared too.  In any case, you can write more papers if you save time by using
someone else's code.</para></listitem>

<listitem><para><emphasis>It would be quicker to use an existing package
developed in our group</emphasis>.  Are you sure? It may take you a while to
understand someone else's coding style, and many packages are a hotch-potch
resulting from a number of authors work.  To write code as quickly as possible,
it is makes sense to use something already written and well documented. Let's
face it, you would use Mathematica if it was quick enough, but it isn't. And if
your project changes slightly, you have more options within a large shared
package.</para></listitem>

<listitem><para><emphasis>Someone will scoop my publication if I share my
code</emphasis>.  Wait a while before you share the code. You won't be working
on this topic all your life. In the end, you will get <emphasis>more</emphasis>
citations if you share your code.</para></listitem>

<listitem><para><emphasis>I want to make money</emphasis>.  Unless you belong to
Gaussian, or Wavefunction, it isn't going to happen.  The market is saturated,
and the clients are poor and smart enough to write their own.  In any case, the
number employees in these companies is dwarfed by the number of students and
post-docs around the world who would share their code if they thought they could
get something in return.</para></listitem>

<listitem><para><emphasis>Sharing code is bad, you will never need to write code
from scratch and thus the code will never be independently verified</emphasis>.
Sharing well documented code makes it open to checking without having to
laboriously re-do everything from scratch.  Greater scrutiny by greater numbers
of people make ity more likely that inconsistencies will appear.  Ultintmately,
the responsibility for code correctness rests with the author. All of us have
used programs, even if only hand calculators, without checking the code for
them.</para></listitem>

<listitem><para><emphasis>Sharing code is a waste of time, I can't understand
what others write</emphasis>.  It might be true, which is why its important to
have a simple, consistent coding style, good documentation, good error checking,
and good examples of share-able code.  I believe that &TONTO; is a good example
of this. With these mechanisms in place, it becomes hard to write bad. If your
contributed code is useful for others, it will become debugged and easier to
understand as features are added.</para></listitem>

</itemizedlist>
</sect1>

<!-- *********************************************************************** -->

<sect1 id="final-word">
<title>Final word</title>

<para>I hope that if you are a user and programmer, you will consider developing
your ideas within this framework and that you will share your work.</para>

<para>At the very least, your critical comments will be appreciated for
improving this tool.</para>

</sect1>
</chapter>
</book>
