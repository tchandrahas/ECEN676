!*******************************************************************************
!
! SHELL1QUARTET : Group of 4 SHELL1s, used for two-electron integrals.  This
! module is designed for speed, but still try to keep it readable.
!
! In getting optimal speed, this module makes some assumptions...
! 1.  The bra is on the outer loop, then ket is on the inner loop.
!
!
! Copyright (C) Daniel Grimwood, 2002
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id: shell1quartet.foo,v 1.2.2.4 2003/11/13 05:33:21 reaper Exp $
!*******************************************************************************

module SHELL1QUARTET

  implicit none

  n_cc_cutoff :: INT = 4
  ! The minimum number of contractions of the ab shellpair for which to
  ! precalculate the cd shellpair data.

  ERI_rms_min_l :: INT = 4
  ! The minimum value of l angular momentum for a shellpair to perform the
  ! reduced multiplication scheme.

contains

!*******************************************************************************
!  Create/Destroy routines.
!*******************************************************************************

   create ::: leaky
   ! Create a shell4 object, but no its component shells.
     self :: PTR
     nullify(self)
     allocate(self)
     ADD_MEMORY(SHELL1QUARTET_SIZE)
     .ab_nullify = TRUE
     .cd_nullify = TRUE
     .nullify_ptr_part
   end

   destroy ::: leaky
   ! Destroy a shell4 object.
     self :: PTR
     if (associated(self)) then
       .destroy_ptr_part
       DELETE_MEMORY(SHELL1QUARTET_SIZE)
       deallocate(self)
     end
   end

!   created result(res)
!   ! Returns true if self has been created
!     self :: PTR
!     res :: BIN
!     res = associated(self)
!   end

!   destroyed result(res)
!   ! Returns true if self has *not* been created
!     self :: PTR
!     res :: BIN
!     res = NOT associated(self)
!   end

   nullify_ptr_part ::: leaky
   ! Nullify the pointer parts of self
     .a.nullify_ptr_part
     .b.nullify_ptr_part
     .c.nullify_ptr_part
     .d.nullify_ptr_part
   end

   destroy_ptr_part ::: leaky
   ! Destroy the pointer parts of self
     .destroy_ab
     .destroy_cd
   end

   destroy_ab ::: leaky
   ! Destroy the shella and shellb pointer parts of self
     if (.ab_nullify) then
       nullify(.a)
       nullify(.b)
       nullify(.ab_exponent_sum)
       nullify(.ab_normalising_factors)
       nullify(.ab_hrr_index_larger)
       nullify(.ab_hrr_index_smaller)
       nullify(.ab_form_3dints_x_indices)
       nullify(.ab_form_3dints_y_indices)
       nullify(.ab_form_3dints_z_indices)
       nullify(.ab_form_3dints_yz_rms_indices)
       nullify(.ab_hrr_components)
       nullify(.ab_hrr_comp_to_use)
     else
       .a.destroy_ptr_part
       .b.destroy_ptr_part
       .ab_exponent_sum.destroy
       if (.ab_l_max > 1) then
         .ab_normalising_factors.destroy
         .ab_hrr_index_larger.destroy
         .ab_hrr_index_smaller.destroy
         .ab_hrr_components.destroy
         .ab_hrr_comp_to_use.destroy
       end
       .ab_form_3dints_x_indices.destroy
       .ab_form_3dints_y_indices.destroy
       .ab_form_3dints_z_indices.destroy
       .ab_form_3dints_yz_rms_indices.destroy
     end
     .ab_cc_prefactor.destroy
     .ab_pair_center.destroy
     .ab_center_diff.destroy
   end

   destroy_cd ::: leaky
   ! Destroy the shellc and shelld pointer parts of self
     if (.cd_nullify) then
       nullify(.c)
       nullify(.d)
       nullify(.cd_exponent_sum)
       nullify(.cd_normalising_factors)
       nullify(.cd_hrr_index_larger)
       nullify(.cd_hrr_index_smaller)
       nullify(.cd_form_3dints_x_indices)
       nullify(.cd_form_3dints_y_indices)
       nullify(.cd_form_3dints_z_indices)
       nullify(.cd_form_3dints_yz_rms_indices)
       nullify(.cd_hrr_components)
       nullify(.cd_hrr_comp_to_use)
     else
       .c.destroy_ptr_part
       .d.destroy_ptr_part
       if (.ab_n_gaussian_pairs > n_cc_cutoff) then
         .cd_exponent_sum.destroy
       end
       if (.cd_l_max > 1) then
         .cd_normalising_factors.destroy
         .cd_hrr_index_larger.destroy
         .cd_hrr_index_smaller.destroy
         .cd_hrr_components.destroy
         .cd_hrr_comp_to_use.destroy
       end
       if (.cd_l_sum > 1 OR .ab_l_sum > 1) then
         .cd_form_3dints_x_indices.destroy
         .cd_form_3dints_y_indices.destroy
         .cd_form_3dints_z_indices.destroy
         .cd_form_3dints_yz_rms_indices.destroy
       end
     end
     if (.ab_n_gaussian_pairs > n_cc_cutoff) then
       .cd_cc_prefactor.destroy
       .cd_pair_center.destroy
       .cd_center_diff.destroy
     end
   end

!*******************************************************************************
!  Setting parts of self from other shells and shell1s.
!*******************************************************************************

   set(shell_a,shell_b,shell_c,shell_d,pos_a,pos_b,pos_c,pos_d) ::: leaky
   ! Set the shell4 using shell objects and positions
     shell_a,shell_b,shell_c,shell_d :: SHELL, IN
     pos_a,pos_b,pos_c,pos_d :: REALVEC, IN
     .a.copy(shell_a)
     .b.copy(shell_b)
     .c.copy(shell_c)
     .d.copy(shell_d)
     .pos_a = pos_a
     .pos_b = pos_b
     .pos_c = pos_c
     .pos_d = pos_d
     .precalculate_ab
     .precalculate_cd
   end

   set_ab(shell_a,shell_b,pos_a,pos_b) ::: leaky
   ! Copy the a and b parts of the shell4 using from shell1 objects
     shell_a,shell_b :: SHELL, IN
     pos_a,pos_b :: REALVEC, IN
     .a.copy(shell_a)
     .b.copy(shell_b)
     .pos_a = pos_a
     .pos_b = pos_b
     .precalculate_ab
   end

   set_cd(shell_c,shell_d,pos_c,pos_d) ::: leaky
   ! Copy the c and d parts of the shell4 using from shell1 objects
     shell_c,shell_d :: SHELL, IN
     pos_c,pos_d :: REALVEC, IN
     .c.copy(shell_c)
     .d.copy(shell_d)
     .pos_c = pos_c
     .pos_d = pos_d
     .precalculate_cd
   end

!*******************************************************************************
!  Miscellaneous Routines.
!*******************************************************************************

   unnormalise
   ! Unnormalise each shell in this shell quartet
     .a.unnormalise
     .b.unnormalise
     .c.unnormalise
     .d.unnormalise
   end

!*******************************************************************************
!  Precalculated stuff.
!*******************************************************************************

  precalculate_ab ::: leaky
    anorm,bnorm :: REALVEC*
    AB,At,P :: REALVEC(3)
    b_cc,a,b,ab_sum,ab_inv,r2ab,prefac :: REAL
    ag,bg,i,j,ub :: INT
    .ab_nullify = FALSE
    .ab_n_gaussian_pairs = .a.n_cc*.b.n_cc
    .ab_l_max = max(.a.l,.b.l)
    .ab_l_min = min(.a.l,.b.l)
    .ab_l_sum = .a.l + .b.l
    .ab_exponent_sum.create(.ab_n_gaussian_pairs)
    .ab_cc_prefactor.create(.ab_n_gaussian_pairs)
    .ab_pair_center.create(3,.ab_n_gaussian_pairs)
    .ab_center_diff.create(3,.ab_n_gaussian_pairs)
    AB = .pos_a-.pos_b
    ! Want position of shell1 with higher angular momentum.
    if (.a.l > .b.l) then; At = .pos_a
    else;                  At = .pos_b
    end
    r2ab = dot_product(AB,AB)
    i = 0
    .ab_kappa_max = ZERO
    do bg = 1,.b.n_cc
      b      = .b.ex(bg)
      b_cc   = .b.cc(bg)
      do ag = 1,.a.n_cc
        i = i + 1
        a = .a.ex(ag)
        ab_sum = a + b
        ab_inv = ONE/ab_sum
        P = (b*.pos_b + a*.pos_a) * ab_inv
        .ab_exponent_sum(i)  = ab_sum
        prefac               = b_cc*.a.cc(ag) *ab_inv*sqrt(ab_inv)* &
                                                       exp(-a*b*r2ab*ab_inv)
        .ab_kappa_max = max(.ab_kappa_max,prefac/(sqrt(ab_inv)*ab_inv))
        .ab_cc_prefactor(i)  = prefac
        .ab_pair_center(:,i) = P
        .ab_center_diff(:,i) = P - At
      end
    end

    if (.ab_l_max > 1) then
      .ab_normalising_factors.create(.a.l.n_comp*.b.l.n_comp)
      anorm.create(.a.l.n_comp)
      bnorm.create(.b.l.n_comp)
      anorm.normalising_factors(.a.l)
      bnorm.normalising_factors(.b.l)
      i = 0
      do bg=1,.b.l.n_comp
        do ag=1,.a.l.n_comp
          i = i + 1
          .ab_normalising_factors(i) = anorm(ag)*bnorm(bg)
        end
      end
      bnorm.destroy
      anorm.destroy

      .ab_hrr_index_larger.create(0,.ab_l_sum,0,.ab_l_sum,0,.ab_l_sum)
      .ab_hrr_index_smaller.create(0,.ab_l_sum,0,.ab_l_sum,0,.ab_l_sum)
      .ab_hrr_components.create(3,.ab_l_sum.n_comp_sum)
      .ab_hrr_comp_to_use.create(.ab_l_sum.n_comp_sum)
      i=0;
      i.make_gaussian_xyz_powers(.ab_hrr_components,.ab_l_sum,.ab_hrr_index_smaller,.ab_hrr_comp_to_use)
      .ab_l_max.make_gaussian_xyz_power_index(.ab_hrr_index_larger,.ab_l_sum)
      .ab_l_max.make_gaussian_xyz_indices(.ab_form_3dints_x_indices, &
                .ab_form_3dints_y_indices,.ab_form_3dints_z_indices,.ab_l_sum)
    end
    ub = .ab_l_sum.n_comp_sum - (.ab_l_max-1).n_comp_sum
    .ab_form_3dints_x_indices.create(ub)
    .ab_form_3dints_y_indices.create(ub)
    .ab_form_3dints_z_indices.create(ub)
    .ab_l_max.make_gaussian_xyz_indices(.ab_form_3dints_x_indices, &
              .ab_form_3dints_y_indices,.ab_form_3dints_z_indices,.ab_l_sum)
    .ab_form_3dints_yz_rms_indices.create(ub)
    do i=1,ub
      j = .ab_form_3dints_z_indices(i)
      .ab_form_3dints_yz_rms_indices(i) = -.ab_l_sum - 2 + j*(2*.ab_l_sum+5-j)/2 + &
                                  .ab_form_3dints_y_indices(i)
    end
  end

  precalculate_cd ::: leaky
    cnorm,dnorm :: REALVEC*
    CD,Ct,Q :: REALVEC(3)
    d_cc,c,d,cd_sum,cd_inv,r2cd,prefac :: REAL
    cg,dg,i,j,ub :: INT
    .cd_nullify = FALSE
    .cd_n_gaussian_pairs = .c.n_cc*.d.n_cc
    .cd_l_max = max(.c.l,.d.l)
    .cd_l_min = min(.c.l,.d.l)
    .cd_l_sum = .c.l + .d.l
    .cd_exponent_sum.create(.cd_n_gaussian_pairs)
    .cd_cc_prefactor.create(.cd_n_gaussian_pairs)
    .cd_pair_center.create(3,.cd_n_gaussian_pairs)
    .cd_center_diff.create(3,.cd_n_gaussian_pairs)
    CD = .pos_c-.pos_d
    ! Want position of shell1 with higher angular momentum.
    if (.c.l > .d.l) then; Ct = .pos_c
    else;                  Ct = .pos_d
    end
    r2cd = dot_product(CD,CD)
    i = 0
    .cd_kappa_max = ZERO
    do dg = 1,.d.n_cc
      d      = .d.ex(dg)
      d_cc   = .d.cc(dg)
      do cg = 1,.c.n_cc
        i = i + 1
        c = .c.ex(cg)
        cd_sum = c + d
        cd_inv = ONE/cd_sum
        Q = (d*.pos_d + c*.pos_c) * cd_inv
        .cd_exponent_sum(i)  = cd_sum
        prefac               = d_cc*.c.cc(cg) *cd_inv*sqrt(cd_inv)* &
                                                  exp(-c*d*r2cd*cd_inv)
        .cd_cc_prefactor(i)  = prefac
        .cd_kappa_max = max(.cd_kappa_max,prefac/(sqrt(cd_inv)*cd_inv))
        .cd_pair_center(:,i) = Q
        .cd_center_diff(:,i) = Q - Ct
      end
    end

    if (.cd_l_max > 1) then
      .cd_normalising_factors.create(.c.l.n_comp*.d.l.n_comp)
      cnorm.create(.c.l.n_comp)
      dnorm.create(.d.l.n_comp)
      cnorm.normalising_factors(.c.l)
      dnorm.normalising_factors(.d.l)
      i = 0
      do dg=1,.d.l.n_comp
        do cg=1,.c.l.n_comp
          i = i + 1
          .cd_normalising_factors(i) = cnorm(cg)*dnorm(dg)
        end
      end
      dnorm.destroy
      cnorm.destroy

      .cd_hrr_index_larger.create(0,.cd_l_sum,0,.cd_l_sum,0,.cd_l_sum)
      .cd_hrr_index_smaller.create(0,.cd_l_sum,0,.cd_l_sum,0,.cd_l_sum)
      .cd_hrr_components.create(3,.cd_l_sum.n_comp_sum)
      .cd_hrr_comp_to_use.create(.cd_l_sum.n_comp_sum)
      i=0;
      i.make_gaussian_xyz_powers(.cd_hrr_components,.cd_l_sum,.cd_hrr_index_smaller,.cd_hrr_comp_to_use)
      .cd_l_max.make_gaussian_xyz_power_index(.cd_hrr_index_larger,.cd_l_sum)
    end
    if (.cd_l_sum > 1 OR .ab_l_sum > 1) then
      ub = .cd_l_sum.n_comp_sum - (.cd_l_max-1).n_comp_sum
      .cd_form_3dints_x_indices.create(ub)
      .cd_form_3dints_y_indices.create(ub)
      .cd_form_3dints_z_indices.create(ub)
      .cd_l_max.make_gaussian_xyz_indices(.cd_form_3dints_x_indices, &
                .cd_form_3dints_y_indices,.cd_form_3dints_z_indices,.cd_l_sum)
      .cd_form_3dints_yz_rms_indices.create(ub)
      do i=1,ub
        j = .cd_form_3dints_z_indices(i)
        .cd_form_3dints_yz_rms_indices(i) = -.cd_l_sum - 2 + j*(2*.cd_l_sum+5-j)/2 + &
                                    .cd_form_3dints_y_indices(i)
      end
    end
  end

  set_ab(shellpr,pos_a,pos_b) ::: leaky
  ! Copy the a and b parts of the shell4 using from shell1 objects
    shellpr :: SHELLPAIR, IN, target
    pos_a,pos_b :: REALVEC, IN
    AB,At,P,b_pos_b :: REALVEC(3)
    r2ab,a,b,ab_inv,prefac :: REAL
    i,bg,ag :: INT

    .ab_nullify = TRUE
    .a => shellpr.a
    .b => shellpr.b
    .ab_exponent_sum        => shellpr.exponent_sum

    .ab_l_max = shellpr.l_max
    if (.ab_l_max > 1) then
      .ab_normalising_factors   => shellpr.normalising_factors
      .ab_hrr_index_larger      => shellpr.hrr_index_larger
      .ab_hrr_index_smaller     => shellpr.hrr_index_smaller
      .ab_hrr_components        => shellpr.hrr_components
      .ab_hrr_comp_to_use       => shellpr.hrr_comp_to_use
    end
    .ab_form_3dints_x_indices => shellpr.form_3dints_x_indices
    .ab_form_3dints_y_indices => shellpr.form_3dints_y_indices
    .ab_form_3dints_z_indices => shellpr.form_3dints_z_indices
    .ab_form_3dints_yz_rms_indices => shellpr.form_3dints_yz_rms_indices

    .pos_a = pos_a
    .pos_b = pos_b
    .ab_n_gaussian_pairs = shellpr.n_gaussian_pairs
    .ab_l_min = shellpr.l_min
    .ab_l_sum = shellpr.l_sum
    .ab_cc_prefactor.create(.ab_n_gaussian_pairs)
    .ab_pair_center.create(3,.ab_n_gaussian_pairs)
    .ab_center_diff.create(3,.ab_n_gaussian_pairs)
     AB = pos_a-pos_b
     ! Want position of shell1 with higher angular momentum.
     if (.a.l > .b.l) then; At = pos_a
     else;                  At = pos_b
     end
     r2ab = dot_product(AB,AB)
     .r2ab = r2ab
     i = 0
     .ab_kappa_max = ZERO
     do bg = 1,.b.n_cc
       b       = .b.ex(bg)
       b_pos_b = b*pos_b
       do ag = 1,.a.n_cc
         i = i + 1
         a = .a.ex(ag)
         ab_inv = ONE/.ab_exponent_sum(i)
         P = (b_pos_b + a*pos_a) * ab_inv
         prefac = shellpr.cc_prefactor(i)*exp(-a*b*r2ab*ab_inv)
         .ab_cc_prefactor(i)  = prefac
         .ab_kappa_max = max(.ab_kappa_max,prefac/(sqrt(ab_inv)*ab_inv))
         .ab_pair_center(:,i) = P
         .ab_center_diff(:,i) = P - At
       end
     end
  end

  set_cd(shellpr,pos_c,pos_d) ::: leaky
  ! Copy the c and d parts of the shell4 using from shell1 objects
    shellpr :: SHELLPAIR, IN, target
    pos_c,pos_d :: REALVEC, IN
    CD,Ct,Q,d_pos_d :: REALVEC(3)
    r2cd,c,d,d_r2cd,cd_inv,prefac :: REAL
    i,dg,cg :: INT

    .cd_nullify = TRUE
    .cd_l_max = shellpr.l_max
    .pos_c = pos_c
    .pos_d = pos_d
    .cd_n_gaussian_pairs = shellpr.n_gaussian_pairs
    .cd_l_min = shellpr.l_min
    .cd_l_sum = shellpr.l_sum
    CD = pos_c-pos_d
    r2cd = dot_product(CD,CD)
    .r2cd = r2cd


    .c => shellpr.a
    .d => shellpr.b
    if (.ab_n_gaussian_pairs > n_cc_cutoff) then
      .cd_exponent_sum        => shellpr.exponent_sum
    end
    if (.cd_l_max > 1) then
      .cd_normalising_factors   => shellpr.normalising_factors
      .cd_hrr_index_larger      => shellpr.hrr_index_larger
      .cd_hrr_index_smaller     => shellpr.hrr_index_smaller
      .cd_hrr_components        => shellpr.hrr_components
      .cd_hrr_comp_to_use       => shellpr.hrr_comp_to_use
    end
    if (.cd_l_sum > 1 OR .ab_l_sum > 1) then
      .cd_form_3dints_x_indices => shellpr.form_3dints_x_indices
      .cd_form_3dints_y_indices => shellpr.form_3dints_y_indices
      .cd_form_3dints_z_indices => shellpr.form_3dints_z_indices
      .cd_form_3dints_yz_rms_indices => shellpr.form_3dints_yz_rms_indices
    end

    if (.ab_n_gaussian_pairs > n_cc_cutoff) then
      .cd_cc_prefactor.create(.cd_n_gaussian_pairs)
      .cd_pair_center.create(3,.cd_n_gaussian_pairs)
      .cd_center_diff.create(3,.cd_n_gaussian_pairs)
      ! Want position of shell1 with higher angular momentum.
      if (.c.l > .d.l) then; Ct = pos_c
      else;                  Ct = pos_d
      end
      i = 0
      .cd_kappa_max = ZERO
      do dg = 1,.d.n_cc
        d       = .d.ex(dg)
        d_pos_d = d*pos_d
        d_r2cd  = d*r2cd
        do cg = 1,.c.n_cc
          i       = i + 1
          c       = .c.ex(cg)
          cd_inv  = ONE/.cd_exponent_sum(i)
          Q       = (d_pos_d + c*pos_c) * cd_inv
          prefac  = shellpr.cc_prefactor(i)*exp(-c*d_r2cd*cd_inv)
          .cd_cc_prefactor(i)  = prefac
          .cd_pair_center(:,i) = Q
          .cd_center_diff(:,i) = Q - Ct
        end
      end
    end
  end

!*******************************************************************************
!  ERI cutoffs
!*******************************************************************************

  cd_kappa_max result (res) ::: pure
  ! Return the largest kappa_cd used in the Lindh integrals.
    self :: IN
    res :: REAL
    CD :: REALVEC(3)
    d,d_cc,c,cd_inv,prefac,r2_cd :: REAL
    dg,cg :: INT
    CD = .pos_d - .pos_c
    r2_cd = dot_product(CD,CD)
    res = ZERO
    do dg = 1,.d.n_cc
      d      = .d.ex(dg)
      d_cc   = .d.cc(dg)
      do cg = 1,.c.n_cc
        c = .c.ex(cg)
        cd_inv = ONE/(c+d)
        prefac = d_cc*.c.cc(cg) * cd_inv * sqrt(cd_inv) * exp(-c*d*r2_cd*cd_inv)
        res = max(res,prefac/(sqrt(cd_inv)*cd_inv))
      end
    end
  end

   skip_ERI result (res) ::: pure
   ! Whether the ERI block will be less than a cutoff value.
     self :: IN
     res :: BIN
     res = (.ab_kappa_max*.cd_kappa_max < SHELL4_ERI_CUTOFF)
   end

   skip_ERI(cutoff) result (res) ::: pure
   ! Whether the ERI block will be less than a cutoff value.
     self :: IN
     cutoff :: REAL, IN
     res :: BIN
     res = (.ab_kappa_max*.cd_kappa_max < cutoff)
   end

!*******************************************************************************
!                   Roland Lindh-style integrals
!
! Electron repulsion integrals from Lindh, Ryu and Liu,
! J. Chem. Phys 95(8) 1991, 5889-5897.
!
! See also:
! Obara and Saika, J. Chem. Phys. 84(7), 1986, 3963-3974.
! Head-Gordon and Pople, J. Chem. Phys. 89(9), 1988, 5777-5786.
!
!*******************************************************************************

  get_ERI(abcd)
  ! The main routine to produce the electron repulsion integral block (ab|cd).
  ! Use this routine only!
  ! The rest of the routines are now specialised, eg make_pppp will ONLY accept
  ! a pppp shell4.
    self :: IN
    abcd :: REALMAT4, OUT
    opt,maxl :: INT

    maxl = max(.ab_l_max,.cd_l_max)
    select case (maxl)
      case (0)                                              ! max is s function
        .make_ssss(abcd)
      case (1)                                              ! max is p function
        if (.ab_l_sum==0) opt = 1
        if (.ab_l_sum==1) opt = 4
        if (.ab_l_sum==2) opt = 7
        if (.cd_l_sum==1) opt = opt + 1
        if (.cd_l_sum==2) opt = opt + 2
        select case (opt)
          case (9); .make_pppp(abcd)
          case (8); .make_ppps(abcd)
          case (7); .make_ppss(abcd)
          case (6); .make_pspp(abcd)
          case (5); .make_psps(abcd)
          case (4); .make_psss(abcd)
          case (3); .make_sspp(abcd)
          case (2); .make_ssps(abcd)
          case (1); .make_ssss(abcd)
        end
      case (2)                                              ! max is d function
        if (.ab_l_min==0 AND .cd_l_min==0) then
          if (.ab_l_max==2 AND .cd_l_max==2) then
            .make_dsds(abcd)
          else if (.ab_l_max==2 AND .cd_l_max==1) then
            .make_dsps(abcd)
          else if (.ab_l_max==1 AND .cd_l_max==2) then
            .make_psds(abcd)
          else
            .make_abcd(abcd)
          end
        else
          .make_abcd(abcd)
        end
      case default                                          ! general
        if (.ab_l_sum == 0) then;      .make_sscd(abcd)
        else if (.cd_l_sum == 0) then; .make_abss(abcd)
        else;                    .make_abcd(abcd)
        end
    end
  end

  make_abcd(abcd) ::: private
  ! Makes the (ab|cd) integrals, summed over the primitives
  ! (uses the transfer equation to make (ab|cd) from (es|fs))
    self :: IN
    abcd :: REALMAT4, OUT
    escd :: REALMAT3*
    esfs :: REALMAT*
    eub,fub :: INT
    nullify(esfs)
    nullify(escd)
    eub = .ab_l_sum.n_comp_sum - (.ab_l_max-1).n_comp_sum
    fub = .cd_l_sum.n_comp_sum - (.cd_l_max-1).n_comp_sum
    esfs.create(eub,fub)
    if (.cd_l_sum==1) then
      if (.ab_n_gaussian_pairs > n_cc_cutoff) then
        .make_esps(esfs)
      else
        .make_esps_low_ncc(esfs)
      end
    else if (.ab_l_sum==1) then
      if (.ab_n_gaussian_pairs > n_cc_cutoff) then
        .make_psfs(esfs)
      else
        .make_psfs_low_ncc(esfs)
      end
    else
      if (.ab_n_gaussian_pairs > n_cc_cutoff) then
        .make_esfs(esfs)
      else
        .make_esfs_low_ncc(esfs)
      end
    end
    escd.create(eub, .c.n_comp, .d.n_comp)
    .transfer_cd(esfs,escd)
    .transfer_ab(escd,abcd)
    escd.destroy
    esfs.destroy
    .to_normalise(abcd)
  end

  make_ascd(escd) ::: private
  ! Makes the (as|cd) or (sb|cd) integrals, summed over the primitives.
    self :: IN
    escd :: REALMAT3, OUT
    esfs :: REALMAT*
    eub,fub :: INT
    nullify(esfs)
    eub = .ab_l_sum.n_comp
    fub = .cd_l_sum.n_comp_sum - (.cd_l_max-1).n_comp_sum
    esfs.create(eub,fub)
    if (.cd_l_sum==1) then
      if (.ab_n_gaussian_pairs > n_cc_cutoff) then
        .make_esps(esfs)
      else
        .make_esps_low_ncc(esfs)
      end
    else
      if (.ab_n_gaussian_pairs > n_cc_cutoff) then
        .make_esfs(esfs)
      else
        .make_esfs_low_ncc(esfs)
      end
    end
    .transfer_cd(esfs,escd)
    esfs.destroy
    .to_normalise_ecd(escd)
  end

  make_abcs(abfs) ::: private
  ! Makes the (ab|cs) or (ab|sd) integrals, summed over the primitives.
    self :: IN
    abfs :: REALMAT3, OUT
    esfs :: REALMAT*
    eub,fub :: INT
    nullify(esfs)
    eub = .ab_l_sum.n_comp_sum - (.ab_l_max-1).n_comp_sum
    fub = .cd_l_sum.n_comp
    esfs.create(eub,fub)
    if (.cd_l_sum==1) then
      if (.ab_n_gaussian_pairs > n_cc_cutoff) then
        .make_esps(esfs)
      else
        .make_esps_low_ncc(esfs)
      end
    else
      if (.ab_n_gaussian_pairs > n_cc_cutoff) then
        .make_esfs(esfs)
      else
        .make_esfs_low_ncc(esfs)
      end
    end
    .transfer_ab(esfs,abfs)
    esfs.destroy
    .to_normalise_abf(abfs)
  end

  make_ascs(ac) ::: private
  ! Makes the (as|cs) or (as|sd) or (sb|cs) or (sb|sd) integrals, summed over
  ! the primitives.
    self :: IN
    ac :: REALMAT, OUT
    j :: INT
    if (.cd_l_sum==1) then
      if (.ab_n_gaussian_pairs > n_cc_cutoff) then
        .make_esps(ac)
      else
        .make_esps_low_ncc(ac)
      end
    else if (.ab_l_sum==1) then
      if (.ab_n_gaussian_pairs > n_cc_cutoff) then
        .make_psfs(ac)
      else
        .make_psfs_low_ncc(ac)
      end
    else
      if (.ab_n_gaussian_pairs > n_cc_cutoff) then
        .make_esfs(ac)
      else
        .make_esfs_low_ncc(ac)
      end
    end
    if (.ab_l_sum > 1) then
      if (.cd_l_sum > 1) then
        do j=1,size(ac,2)
          ac(:,j) = ac(:,j) * .ab_normalising_factors(:) * .cd_normalising_factors(j)
        end
      else
        do j=1,size(ac,2)
          ac(:,j) = ac(:,j) * .ab_normalising_factors(:)
        end
      end
    else if (.cd_l_sum > 1) then
      do j=1,size(ac,2)
        ac(:,j) = ac(:,j) * .cd_normalising_factors(j)
      end
    end
  end

  make_esfs(esfs) ::: private
  ! Makes the initial (es|fs) integrals, summed over the primitives
    self :: IN
    esfs :: REALMAT, OUT
    Ixa,Iya,Iza :: REALMAT3*
    rys1 :: RYS*
    Ix,Iy,Iz :: REALMAT*
    Ix1,Iy1,Iz1,Ixf,Iyf,Izf :: REALVEC*
    zeta,eta,xx,normab,zinv,rho,einv,rho_zinv,rho_einv :: REAL
    QPx,QPy,QPz,PAx,PAy,PAz,Qx,Qy,Qz,QCx,QCy,QCz,Px,Py,Pz :: REAL
    ce,cf,bb,ce1,wt :: REAL
    Ix12,Iy12,Iz12,Ix21,Iy21,Iz21,Ix22,Iy22,Iz22 :: REAL
    Ix1f1,Iy1f1,Iz1f1,Ix1f,Iy1f,Iz1f,Ix1fp1,Iy1fp1,Iz1fp1 :: REAL
    Ix2f1,Iy2f1,Iz2f1,Ix2f,Iy2f,Iz2f,Ix2fp1,Iy2fp1,Iz2fp1 :: REAL
    Ixe11,Iye11,Ize11,Ixe1,Iye1,Ize1,Ixep11,Iyep11,Izep11 :: REAL
    Ixef,Iyef,Izef,Ixef1,Iyef1,Izef1 :: REAL
    t2,t2_rz,t2_re,half_zinv,half_einv,f1_bb,f1_cf :: REAL
    ag,bg,cg,dg,nroots,eub,fub,dim1,dim2 :: INT
    e,f,e1,fp1,ep1,n,i,j,k,n_sum :: INT

    eub = .ab_l_sum.n_comp_sum - (.ab_l_max-1).n_comp_sum
    fub = .cd_l_sum.n_comp_sum - (.cd_l_max-1).n_comp_sum
    dim1 = .ab_l_sum + 1
    dim2 = .cd_l_sum + 1
    nroots = (dim1+dim2)/2

    ! number of elements to sum over
    n_sum = nroots * .ab_n_gaussian_pairs * .cd_n_gaussian_pairs
    Ixa.create(n_sum,dim1,dim2)
    Iya.create(n_sum,dim1,dim2)
    Iza.create(n_sum,dim1,dim2)

    rys1.create(nroots)

    i = 0
    k = 0
    do bg = 1, .b.n_cc
      do ag = 1, .a.n_cc
        k = k + 1
        zeta = .ab_exponent_sum(k)
        zinv = ONE/zeta
        half_zinv = HALF * zinv
        normab = .ab_cc_prefactor(k) * TWOPI5ON2
        Px = .ab_pair_center(1,k)
        Py = .ab_pair_center(2,k)
        Pz = .ab_pair_center(3,k)
        PAx = .ab_center_diff(1,k)
        PAy = .ab_center_diff(2,k)
        PAz = .ab_center_diff(3,k)
        j = 0
        do dg = 1, .d.n_cc
          do cg = 1, .c.n_cc
            j = j + 1
            eta  = .cd_exponent_sum(j)
            einv = ONE/eta
            Qx = .cd_pair_center(1,j)
            Qy = .cd_pair_center(2,j)
            Qz = .cd_pair_center(3,j)
            QCx = .cd_center_diff(1,j)
            QCy = .cd_center_diff(2,j)
            QCz = .cd_center_diff(3,j)
            rho  = zeta * eta / (zeta + eta)
            rho_zinv = rho * zinv
            rho_einv = rho * einv
            half_einv = HALF * einv
            QPx  = Qx - Px;   QPy  = Qy - Py;   QPz  = Qz - Pz
            xx   = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
            rys1.get_weights(xx)
            xx = (normab * .cd_cc_prefactor(j) * sqrt(rho))
            rys1.w(:) = rys1.w(:) * (normab * .cd_cc_prefactor(j) * sqrt(rho))

            ! Now make the 2 dimensional integrals.
            do n=1,nroots
              i = i + 1
              Ix => Ixa(i,:,:)
              Iy => Iya(i,:,:)
              Iz => Iza(i,:,:)
              t2    = rys1.r(n)
              wt    = rys1.w(n)
              t2_rz = t2 * rho_zinv
              t2_re = t2 * rho_einv
              bb    = t2_rz * half_einv
              Ix12 = QCx - t2_re * QPx
              Iy12 = QCy - t2_re * QPy
              Iz12 = QCz - t2_re * QPz
              Ix21 = PAx + t2_rz * QPx
              Iy21 = PAy + t2_rz * QPy
              Iz21 = PAz + t2_rz * QPz
              Ix22 = Ix12 * Ix21 + bb
              Iy22 = Iy12 * Iy21 + bb
              Iz22 = Iz12 * Iz21 + bb
              Ix(1,1) = ONE;  Iy(1,1) = ONE;  Iz(1,1) = ONE*wt
              Ix(2,1) = Ix21; Iy(2,1) = Iy21; Iz(2,1) = Iz21*wt
              Ix(1,2) = Ix12; Iy(1,2) = Iy12; Iz(1,2) = Iz12*wt
              Ix(2,2) = Ix22; Iy(2,2) = Iy22; Iz(2,2) = Iz22*wt
              if (.cd_l_sum>1) then
                cf    = (ONE - t2_re) * half_einv
                Ix1f  = Ix12; Iy1f  = Iy12; Iz1f  = Iz12
                Ix1f1 = ONE;  Iy1f1 = ONE;  Iz1f1 = ONE
                Ix2f  = Ix22; Iy2f  = Iy22; Iz2f  = Iz22
                Ix2f1 = Ix21; Iy2f1 = Iy21; Iz2f1 = Iz21
                f1_cf = ZERO
                do fp1 = 3,.cd_l_sum+1
                  f1_cf = f1_cf + cf
                  Ix1fp1 = Ix12 * Ix1f + f1_cf * Ix1f1
                  Iy1fp1 = Iy12 * Iy1f + f1_cf * Iy1f1
                  Iz1fp1 = Iz12 * Iz1f + f1_cf * Iz1f1
                  Ix2fp1 = Ix12 * Ix2f + f1_cf * Ix2f1 + bb * Ix1f
                  Iy2fp1 = Iy12 * Iy2f + f1_cf * Iy2f1 + bb * Iy1f
                  Iz2fp1 = Iz12 * Iz2f + f1_cf * Iz2f1 + bb * Iz1f
                  Ix(1,fp1) = Ix1fp1; Iy(1,fp1) = Iy1fp1; Iz(1,fp1) = Iz1fp1*wt
                  Ix(2,fp1) = Ix2fp1; Iy(2,fp1) = Iy2fp1; Iz(2,fp1) = Iz2fp1*wt
                  Ix1f1 = Ix1f;   Iy1f1 = Iy1f;   Iz1f1 = Iz1f
                  Ix1f  = Ix1fp1; Iy1f  = Iy1fp1; Iz1f  = Iz1fp1
                  Ix2f1 = Ix2f;   Iy2f1 = Iy2f;   Iz2f1 = Iz2f
                  Ix2f  = Ix2fp1; Iy2f  = Iy2fp1; Iz2f  = Iz2fp1
                end
              end
              if (.ab_l_sum>1) then
                Ixe1  = Ix21; Iye1  = Iy21; Ize1  = Iz21
                Ixe11 = ONE;   Iye11 = ONE;   Ize11 = ONE
                ce    = (ONE - t2_rz) * half_zinv
                ce1 = ZERO
                do ep1 = 3, .ab_l_sum+1
                  ce1 = ce1 + ce
                  Ixep11 = Ix21 * Ixe1 + ce1 * Ixe11
                  Iyep11 = Iy21 * Iye1 + ce1 * Iye11
                  Izep11 = Iz21 * Ize1 + ce1 * Ize11
                  Ix(ep1,1) = Ixep11; Iy(ep1,1) = Iyep11; Iz(ep1,1) = Izep11*wt
                  Ixe11 = Ixe1;   Iye11 = Iye1;   Ize11 = Ize1
                  Ixe1  = Ixep11; Iye1  = Iyep11; Ize1  = Izep11
                end
              end
              if (.ab_l_sum>1 AND .cd_l_sum>1) then
                Ix1 => Ix(:,1)
                Iy1 => Iy(:,1)
                Iz1 => Iz(:,1)
                ce1 = ZERO
                do e = 2, .ab_l_sum
                  e1  = e - 1
                  ep1 = e + 1
                  ce1 = ce1 + ce
                  Ixef1 = Ix1(e); Iyef1 = Iy1(e); Izef1 = Iz1(e)
                  f1_bb = ZERO
                  do f=2, .cd_l_sum+1
                    Ixf => Ix(:,f);  Iyf => Iy(:,f);  Izf => Iz(:,f)
                    f1_bb = f1_bb + bb
                    Ixef  = Ixf(e); Iyef  = Iyf(e); Izef  = Izf(e)
                    Ixf(ep1) = Ix21*Ixef + ce1*Ixf(e1) + f1_bb*Ixef1
                    Iyf(ep1) = Iy21*Iyef + ce1*Iyf(e1) + f1_bb*Iyef1
                    Izf(ep1) = Iz21*Izef + ce1*Izf(e1) + f1_bb*Izef1
                    Ixef1 = Ixef;   Iyef1 = Iyef;   Izef1 = Izef
                  end
                end
              end
            end
          end
        end
      end
    end

    rys1.destroy

    .form_esfs(Ixa,Iya,Iza,esfs,eub,fub,n_sum)

    Iza.destroy
    Iya.destroy
    Ixa.destroy
  end

  make_esfs_low_ncc(esfs) ::: private
  ! Makes the initial (es|fs) integrals, summed over the primitives
    self :: IN
    esfs :: REALMAT, OUT
    Ixa,Iya,Iza :: REALMAT3*
    rys1 :: RYS*
    Ix,Iy,Iz :: REALMAT*
    Ix1,Iy1,Iz1,Ixf,Iyf,Izf :: REALVEC*
    zeta,eta,xx,normab,zinv,rho,einv,rho_zinv,rho_einv :: REAL
    QPx,QPy,QPz,PAx,PAy,PAz,Qx,Qy,Qz,QCx,QCy,QCz,Px,Py,Pz :: REAL
    ce,cf,bb,ce1,wt :: REAL
    Ix12,Iy12,Iz12,Ix21,Iy21,Iz21,Ix22,Iy22,Iz22 :: REAL
    Ix1f1,Iy1f1,Iz1f1,Ix1f,Iy1f,Iz1f,Ix1fp1,Iy1fp1,Iz1fp1 :: REAL
    Ix2f1,Iy2f1,Iz2f1,Ix2f,Iy2f,Iz2f,Ix2fp1,Iy2fp1,Iz2fp1 :: REAL
    Ixe11,Iye11,Ize11,Ixe1,Iye1,Ize1,Ixep11,Iyep11,Izep11 :: REAL
    Ixef,Iyef,Izef,Ixef1,Iyef1,Izef1 :: REAL
    Dx,Dy,Dz,Cx,Cy,Cz,Ctx,Cty,Ctz :: REAL
    t2,t2_rz,t2_re,half_zinv,half_einv :: REAL
    d,d_cc,d_r2cd,c,f1_cf,f1_bb :: REAL
    ag,bg,cg,dg,nroots,eub,fub,dim1,dim2 :: INT
    e,f,e1,ep1,fp1,n,i,k,n_sum :: INT

    eub = .ab_l_sum.n_comp_sum - (.ab_l_max-1).n_comp_sum
    fub = .cd_l_sum.n_comp_sum - (.cd_l_max-1).n_comp_sum
    dim1 = .ab_l_sum + 1
    dim2 = .cd_l_sum + 1
    nroots = (dim1+dim2)/2

    ! number of elements to sum over
    n_sum = nroots * .ab_n_gaussian_pairs * .cd_n_gaussian_pairs
    Ixa.create(n_sum,dim1,dim2)
    Iya.create(n_sum,dim1,dim2)
    Iza.create(n_sum,dim1,dim2)

    rys1.create(nroots)

    Cx = .pos_c(1);  Dx = .pos_d(1)
    Cy = .pos_c(2);  Dy = .pos_d(2)
    Cz = .pos_c(3);  Dz = .pos_d(3)
    if (.c.l > .d.l) then
      Ctx = Cx;  Cty = Cy;  Ctz = Cz
    else
      Ctx = Dx;  Cty = Dy;  Ctz = Dz
    end
    i = 0
    k = 0
    do bg = 1, .b.n_cc
      do ag = 1, .a.n_cc
        k = k + 1
        zeta = .ab_exponent_sum(k)
        zinv = ONE/zeta
        half_zinv = HALF * zinv
        normab = .ab_cc_prefactor(k) * TWOPI5ON2
        Px = .ab_pair_center(1,k)
        Py = .ab_pair_center(2,k)
        Pz = .ab_pair_center(3,k)
        PAx = .ab_center_diff(1,k)
        PAy = .ab_center_diff(2,k)
        PAz = .ab_center_diff(3,k)
        do dg = 1, .d.n_cc
          d      = .d.ex(dg)
          d_cc   = .d.cc(dg)
          d_r2cd = d * .r2cd
          do cg = 1, .c.n_cc
            c    = .c.ex(cg)
            eta  = c + d
            einv = ONE/eta
            Qx = (d*Dx + c*Cx) * einv
            Qy = (d*Dy + c*Cy) * einv
            Qz = (d*Dz + c*Cz) * einv
            QCx = Qx - Ctx
            QCy = Qy - Cty
            QCz = Qz - Ctz
            rho  = zeta * eta / (zeta + eta)
            rho_zinv = rho * zinv
            rho_einv = rho * einv
            half_einv = HALF * einv
            QPx  = Qx - Px;   QPy  = Qy - Py;   QPz  = Qz - Pz
            xx   = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
            rys1.get_weights(xx)
            rys1.w(:) = rys1.w(:) * (normab * d_cc * .c.cc(cg) * &
                           einv * sqrt(rho_einv) * exp(-c*d_r2cd*einv))

            ! Now make the 2 dimensional integrals.
            do n=1,nroots
              i = i + 1
              Ix => Ixa(i,:,:)
              Iy => Iya(i,:,:)
              Iz => Iza(i,:,:)
              t2    = rys1.r(n)
              wt    = rys1.w(n)
              t2_rz = t2 * rho_zinv
              t2_re = t2 * rho_einv
              bb    = t2_rz * half_einv
              Ix12 = QCx - t2_re * QPx
              Iy12 = QCy - t2_re * QPy
              Iz12 = QCz - t2_re * QPz
              Ix21 = PAx + t2_rz * QPx
              Iy21 = PAy + t2_rz * QPy
              Iz21 = PAz + t2_rz * QPz
              Ix22 = Ix12 * Ix21 + bb
              Iy22 = Iy12 * Iy21 + bb
              Iz22 = Iz12 * Iz21 + bb
              Ix(1,1) = ONE;  Iy(1,1) = ONE;  Iz(1,1) = ONE*wt
              Ix(2,1) = Ix21; Iy(2,1) = Iy21; Iz(2,1) = Iz21*wt
              Ix(1,2) = Ix12; Iy(1,2) = Iy12; Iz(1,2) = Iz12*wt
              Ix(2,2) = Ix22; Iy(2,2) = Iy22; Iz(2,2) = Iz22*wt
              if (.cd_l_sum>1) then
                cf    = (ONE - t2_re) * half_einv
                Ix1f  = Ix12; Iy1f  = Iy12; Iz1f  = Iz12
                Ix1f1 = ONE;  Iy1f1 = ONE;  Iz1f1 = ONE
                Ix2f  = Ix22; Iy2f  = Iy22; Iz2f  = Iz22
                Ix2f1 = Ix21; Iy2f1 = Iy21; Iz2f1 = Iz21
                f1_cf = ZERO
                do fp1 = 3,.cd_l_sum+1
                  f1_cf = f1_cf + cf
                  Ix1fp1 = Ix12 * Ix1f + f1_cf * Ix1f1
                  Iy1fp1 = Iy12 * Iy1f + f1_cf * Iy1f1
                  Iz1fp1 = Iz12 * Iz1f + f1_cf * Iz1f1
                  Ix2fp1 = Ix12 * Ix2f + f1_cf * Ix2f1 + bb * Ix1f
                  Iy2fp1 = Iy12 * Iy2f + f1_cf * Iy2f1 + bb * Iy1f
                  Iz2fp1 = Iz12 * Iz2f + f1_cf * Iz2f1 + bb * Iz1f
                  Ix(1,fp1) = Ix1fp1; Iy(1,fp1) = Iy1fp1; Iz(1,fp1) = Iz1fp1*wt
                  Ix(2,fp1) = Ix2fp1; Iy(2,fp1) = Iy2fp1; Iz(2,fp1) = Iz2fp1*wt
                  Ix1f1 = Ix1f;   Iy1f1 = Iy1f;   Iz1f1 = Iz1f
                  Ix1f  = Ix1fp1; Iy1f  = Iy1fp1; Iz1f  = Iz1fp1
                  Ix2f1 = Ix2f;   Iy2f1 = Iy2f;   Iz2f1 = Iz2f
                  Ix2f  = Ix2fp1; Iy2f  = Iy2fp1; Iz2f  = Iz2fp1
                end
              end
              if (.ab_l_sum>1) then
                Ixe1  = Ix21; Iye1  = Iy21; Ize1  = Iz21
                Ixe11 = ONE;   Iye11 = ONE;   Ize11 = ONE
                ce    = (ONE - t2_rz) * half_zinv
                ce1 = ZERO
                do ep1 = 3, .ab_l_sum+1
                  ce1 = ce1 + ce
                  Ixep11 = Ix21 * Ixe1 + ce1 * Ixe11
                  Iyep11 = Iy21 * Iye1 + ce1 * Iye11
                  Izep11 = Iz21 * Ize1 + ce1 * Ize11
                  Ix(ep1,1) = Ixep11; Iy(ep1,1) = Iyep11; Iz(ep1,1) = Izep11*wt
                  Ixe11 = Ixe1;   Iye11 = Iye1;   Ize11 = Ize1
                  Ixe1  = Ixep11; Iye1  = Iyep11; Ize1  = Izep11
                end
              end
              if (.ab_l_sum>1 AND .cd_l_sum>1) then
                Ix1 => Ix(:,1)
                Iy1 => Iy(:,1)
                Iz1 => Iz(:,1)
                ce1 = ZERO
                do e = 2, .ab_l_sum
                  e1  = e - 1
                  ep1 = e + 1
                  ce1 = ce1 + ce
                  Ixef1 = Ix1(e); Iyef1 = Iy1(e); Izef1 = Iz1(e)
                  f1_bb = ZERO
                  do f=2, .cd_l_sum+1
                    Ixf => Ix(:,f);  Iyf => Iy(:,f);  Izf => Iz(:,f)
                    f1_bb = f1_bb + bb
                    Ixef  = Ixf(e); Iyef  = Iyf(e); Izef  = Izf(e)
                    Ixf(ep1) = Ix21*Ixef + ce1*Ixf(e1) + f1_bb*Ixef1
                    Iyf(ep1) = Iy21*Iyef + ce1*Iyf(e1) + f1_bb*Iyef1
                    Izf(ep1) = Iz21*Izef + ce1*Izf(e1) + f1_bb*Izef1
                    Ixef1 = Ixef;   Iyef1 = Iyef;   Izef1 = Izef
                  end
                end
              end
            end
          end
        end
      end
    end

    rys1.destroy

    .form_esfs(Ixa,Iya,Iza,esfs,eub,fub,n_sum)

    Iza.destroy
    Iya.destroy
    Ixa.destroy
  end

  make_esps(esps) ::: private
  ! Makes the initial (es|ps) integrals, summed over the primitives
    self :: IN
    esps :: REALMAT, OUT
    Ixa,Iya,Iza :: REALMAT3*
    rys1 :: RYS*
    Ix,Iy,Iz :: REALMAT*
    zeta,eta,xx,normab,zinv,rho,einv,rho_zinv,rho_einv :: REAL
    QPx,QPy,QPz,PAx,PAy,PAz,Qx,Qy,Qz,QCx,QCy,QCz,Px,Py,Pz :: REAL
    ce,bb,ce1,wt :: REAL
    Ix21,Iy21,Iz21 :: REAL
    Ixe11,Iye11,Ize11,Ixe1,Iye1,Ize1,Ixep11,Iyep11,Izep11 :: REAL
    t2,t2_rz,t2_re,half_zinv :: REAL
    Ixe12,Iye12,Ize12,Ixe2,Iye2,Ize2,Ixep12,Iyep12,Izep12 :: REAL
    ag,bg,cg,dg,nroots,eub,fub,dim1,dim2 :: INT
    ep1,n,i,j,k,n_sum :: INT

    eub = .ab_l_sum.n_comp_sum - (.ab_l_max-1).n_comp_sum
    fub = 3
    dim1 = .ab_l_sum + 1
    dim2 = 2
    nroots = (dim1+2)/2

    ! number of elements to sum over
    n_sum = nroots * .ab_n_gaussian_pairs * .cd_n_gaussian_pairs
    Ixa.create(n_sum,dim1,dim2)
    Iya.create(n_sum,dim1,dim2)
    Iza.create(n_sum,dim1,dim2)

    rys1.create(nroots)

    i = 0
    k = 0
    do bg = 1, .b.n_cc
      do ag = 1, .a.n_cc
        k = k + 1
        zeta = .ab_exponent_sum(k)
        zinv = ONE/zeta
        half_zinv = HALF * zinv
        normab = .ab_cc_prefactor(k) * TWOPI5ON2
        Px = .ab_pair_center(1,k)
        Py = .ab_pair_center(2,k)
        Pz = .ab_pair_center(3,k)
        PAx = .ab_center_diff(1,k)
        PAy = .ab_center_diff(2,k)
        PAz = .ab_center_diff(3,k)
        j = 0
        do dg = 1, .d.n_cc
          do cg = 1, .c.n_cc
            j = j + 1
            eta  = .cd_exponent_sum(j)
            einv = ONE/eta
            Qx = .cd_pair_center(1,j)
            Qy = .cd_pair_center(2,j)
            Qz = .cd_pair_center(3,j)
            QCx = .cd_center_diff(1,j)
            QCy = .cd_center_diff(2,j)
            QCz = .cd_center_diff(3,j)
            rho  = zeta * eta / (zeta + eta)
            rho_zinv = rho * zinv
            rho_einv = rho * einv
            QPx  = Qx - Px;   QPy  = Qy - Py;   QPz  = Qz - Pz
            xx   = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
            rys1.get_weights(xx)
            rys1.w(:) = rys1.w(:) * normab * .cd_cc_prefactor(j) * sqrt(rho)

            ! Now make the 2 dimensional integrals.
            do n=1,nroots
              i = i + 1
              Ix => Ixa(i,:,:)
              Iy => Iya(i,:,:)
              Iz => Iza(i,:,:)
              wt=rys1.w(n)
              t2    = rys1.r(n)
              t2_rz = t2 * rho_zinv
              t2_re = t2 * rho_einv
              bb    = t2_re * half_zinv
              ce    = (ONE - t2_rz) * half_zinv
              Ixe12 = QCx - t2_re * QPx
              Iye12 = QCy - t2_re * QPy
              Ize12 = QCz - t2_re * QPz
              Ix21 = PAx + t2_rz * QPx
              Iy21 = PAy + t2_rz * QPy
              Iz21 = PAz + t2_rz * QPz
              Ixe2 = Ixe12 * Ix21 + bb
              Iye2 = Iye12 * Iy21 + bb
              Ize2 = Ize12 * Iz21 + bb
              Ix(1,1) = ONE;   Iy(1,1) = ONE;   Iz(1,1) = wt
              Ix(1,2) = Ixe12; Iy(1,2) = Iye12; Iz(1,2) = Ize12*wt
              Ix(2,1) = Ix21;  Iy(2,1) = Iy21;  Iz(2,1) = Iz21*wt
              Ix(2,2) = Ixe2;  Iy(2,2) = Iye2;  Iz(2,2) = Ize2*wt
              if (.ab_l_sum>1) then
                Ixep11 = Ix21*Ix21 + ce;                  Ix(3,1) = Ixep11
                Iyep11 = Iy21*Iy21 + ce;                  Iy(3,1) = Iyep11
                Izep11 = Iz21*Iz21 + ce;                  Iz(3,1) = Izep11*wt
                Ixep12 = Ix21*Ixe2 + ce*Ixe12 + bb*Ix21;  Ix(3,2) = Ixep12
                Iyep12 = Iy21*Iye2 + ce*Iye12 + bb*Iy21;  Iy(3,2) = Iyep12
                Izep12 = Iz21*Ize2 + ce*Ize12 + bb*Iz21;  Iz(3,2) = Izep12*wt
                if (.ab_l_sum>2) then
                  Ixe11 = Ix21;   Iye11 = Iy21;   Ize11 = Iz21
                  Ixe12 = Ixe2;   Iye12 = Iye2;   Ize12 = Ize2
                  Ixe1 = Ixep11;  Iye1 = Iyep11;  Ize1 = Izep11
                  Ixe2 = Ixep12;  Iye2 = Iyep12;  Ize2 = Izep12
                  ce1 = ce
                  do ep1 = 4, .ab_l_sum+1
                    ce1 = ce1 + ce
                    Ixep11 = Ix21*Ixe1 + ce1*Ixe11;            Ix(ep1,1) = Ixep11
                    Iyep11 = Iy21*Iye1 + ce1*Iye11;            Iy(ep1,1) = Iyep11
                    Izep11 = Iz21*Ize1 + ce1*Ize11;            Iz(ep1,1) = Izep11*wt
                    Ixep12 = Ix21*Ixe2 + ce1*Ixe12 + bb*Ixe1;  Ix(ep1,2) = Ixep12
                    Iyep12 = Iy21*Iye2 + ce1*Iye12 + bb*Iye1;  Iy(ep1,2) = Iyep12
                    Izep12 = Iz21*Ize2 + ce1*Ize12 + bb*Ize1;  Iz(ep1,2) = Izep12*wt
                    Ixe11 = Ixe1;   Iye11 = Iye1;   Ize11 = Ize1
                    Ixe12 = Ixe2;   Iye12 = Iye2;   Ize12 = Ize2
                    Ixe1 = Ixep11;  Iye1 = Iyep11;  Ize1 = Izep11
                    Ixe2 = Ixep12;  Iye2 = Iyep12;  Ize2 = Izep12
                  end
                end
              end
            end
          end
        end
      end
    end

    rys1.destroy

    if (.ab_l_min < ERI_rms_min_l) then
      .form_esps_no_rm(Ixa,Iya,Iza,esps,eub)
    else
      .form_esps_rm(Ixa,Iya,Iza,esps,eub,n_sum)
    end

    Iza.destroy
    Iya.destroy
    Ixa.destroy
  end

  make_esps_low_ncc(esps) ::: private
  ! Makes the initial (es|ps) integrals, summed over the primitives
    self :: IN
    esps :: REALMAT, OUT
    Ixa,Iya,Iza :: REALMAT3*
    rys1 :: RYS*
    Ix,Iy,Iz :: REALMAT*
    zeta,eta,xx,normab,zinv,rho,einv,rho_zinv,rho_einv :: REAL
    QPx,QPy,QPz,PAx,PAy,PAz,Qx,Qy,Qz,QCx,QCy,QCz,Px,Py,Pz :: REAL
    ce,bb,ce1,wt :: REAL
    Ix21,Iy21,Iz21 :: REAL
    Dx,Dy,Dz,Cx,Cy,Cz,Ctx,Cty,Ctz :: REAL
    d,d_cc,d_r2cd,c :: REAL
    Ixe11,Iye11,Ize11,Ixe1,Iye1,Ize1,Ixep11,Iyep11,Izep11 :: REAL
    t2,t2_rz,t2_re,half_zinv :: REAL
    Ixe12,Iye12,Ize12,Ixe2,Iye2,Ize2,Ixep12,Iyep12,Izep12 :: REAL
    ag,bg,cg,dg,nroots,eub,fub,dim1,dim2 :: INT
    ep1,n,i,k,n_sum :: INT

    eub = .ab_l_sum.n_comp_sum - (.ab_l_max-1).n_comp_sum
    fub = 3
    dim1 = .ab_l_sum + 1
    dim2 = 2
    nroots = (dim1+2)/2

    ! number of elements to sum over
    n_sum = nroots * .ab_n_gaussian_pairs * .cd_n_gaussian_pairs
    Ixa.create(n_sum,dim1,dim2)
    Iya.create(n_sum,dim1,dim2)
    Iza.create(n_sum,dim1,dim2)

    rys1.create(nroots)

    Cx = .pos_c(1);  Dx = .pos_d(1)
    Cy = .pos_c(2);  Dy = .pos_d(2)
    Cz = .pos_c(3);  Dz = .pos_d(3)
    if (.c.l > .d.l) then
      Ctx = Cx;  Cty = Cy;  Ctz = Cz
    else
      Ctx = Dx;  Cty = Dy;  Ctz = Dz
    end
    i = 0
    k = 0
    do bg = 1, .b.n_cc
      do ag = 1, .a.n_cc
        k = k + 1
        zeta = .ab_exponent_sum(k)
        zinv = ONE/zeta
        half_zinv = HALF * zinv
        normab = .ab_cc_prefactor(k) * TWOPI5ON2
        Px = .ab_pair_center(1,k)
        Py = .ab_pair_center(2,k)
        Pz = .ab_pair_center(3,k)
        PAx = .ab_center_diff(1,k)
        PAy = .ab_center_diff(2,k)
        PAz = .ab_center_diff(3,k)
        do dg = 1, .d.n_cc
          d      = .d.ex(dg)
          d_cc   = .d.cc(dg)
          d_r2cd = d * .r2cd
          do cg = 1, .c.n_cc
            c    = .c.ex(cg)
            eta  = c + d
            einv = ONE/eta
            Qx = (d*Dx + c*Cx) * einv
            Qy = (d*Dy + c*Cy) * einv
            Qz = (d*Dz + c*Cz) * einv
            QCx = Qx - Ctx
            QCy = Qy - Cty
            QCz = Qz - Ctz
            rho  = zeta * eta / (zeta + eta)
            rho_zinv = rho * zinv
            rho_einv = rho * einv
            QPx  = Qx - Px;   QPy  = Qy - Py;   QPz  = Qz - Pz
            xx   = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
            rys1.get_weights(xx)
            rys1.w(:) = rys1.w(:) * (normab * d_cc * .c.cc(cg) * &
                           einv * sqrt(rho_einv) * exp(-c*d_r2cd*einv))

            ! Now make the 2 dimensional integrals.
            do n=1,nroots
              i = i + 1
              Ix => Ixa(i,:,:)
              Iy => Iya(i,:,:)
              Iz => Iza(i,:,:)
              wt=rys1.w(n)
              t2    = rys1.r(n)
              t2_rz = t2 * rho_zinv
              t2_re = t2 * rho_einv
              bb    = t2_re * half_zinv
              ce    = (ONE - t2_rz) * half_zinv
              Ixe12 = QCx - t2_re * QPx
              Iye12 = QCy - t2_re * QPy
              Ize12 = QCz - t2_re * QPz
              Ix21 = PAx + t2_rz * QPx
              Iy21 = PAy + t2_rz * QPy
              Iz21 = PAz + t2_rz * QPz
              Ixe2 = Ixe12 * Ix21 + bb
              Iye2 = Iye12 * Iy21 + bb
              Ize2 = Ize12 * Iz21 + bb
              Ix(1,1) = ONE;   Iy(1,1) = ONE;   Iz(1,1) = wt
              Ix(1,2) = Ixe12; Iy(1,2) = Iye12; Iz(1,2) = Ize12*wt
              Ix(2,1) = Ix21;  Iy(2,1) = Iy21;  Iz(2,1) = Iz21*wt
              Ix(2,2) = Ixe2;  Iy(2,2) = Iye2;  Iz(2,2) = Ize2*wt
              if (.ab_l_sum>1) then
                Ixep11 = Ix21*Ix21 + ce;                  Ix(3,1) = Ixep11
                Iyep11 = Iy21*Iy21 + ce;                  Iy(3,1) = Iyep11
                Izep11 = Iz21*Iz21 + ce;                  Iz(3,1) = Izep11*wt
                Ixep12 = Ix21*Ixe2 + ce*Ixe12 + bb*Ix21;  Ix(3,2) = Ixep12
                Iyep12 = Iy21*Iye2 + ce*Iye12 + bb*Iy21;  Iy(3,2) = Iyep12
                Izep12 = Iz21*Ize2 + ce*Ize12 + bb*Iz21;  Iz(3,2) = Izep12*wt
                if (.ab_l_sum>2) then
                  Ixe11 = Ix21;   Iye11 = Iy21;   Ize11 = Iz21
                  Ixe12 = Ixe2;   Iye12 = Iye2;   Ize12 = Ize2
                  Ixe1 = Ixep11;  Iye1 = Iyep11;  Ize1 = Izep11
                  Ixe2 = Ixep12;  Iye2 = Iyep12;  Ize2 = Izep12
                  ce1 = ce
                  do ep1 = 4, .ab_l_sum+1
                    ce1 = ce1 + ce
                    Ixep11 = Ix21*Ixe1 + ce1*Ixe11;            Ix(ep1,1) = Ixep11
                    Iyep11 = Iy21*Iye1 + ce1*Iye11;            Iy(ep1,1) = Iyep11
                    Izep11 = Iz21*Ize1 + ce1*Ize11;            Iz(ep1,1) = Izep11*wt
                    Ixep12 = Ix21*Ixe2 + ce1*Ixe12 + bb*Ixe1;  Ix(ep1,2) = Ixep12
                    Iyep12 = Iy21*Iye2 + ce1*Iye12 + bb*Iye1;  Iy(ep1,2) = Iyep12
                    Izep12 = Iz21*Ize2 + ce1*Ize12 + bb*Ize1;  Iz(ep1,2) = Izep12*wt
                    Ixe11 = Ixe1;   Iye11 = Iye1;   Ize11 = Ize1
                    Ixe12 = Ixe2;   Iye12 = Iye2;   Ize12 = Ize2
                    Ixe1 = Ixep11;  Iye1 = Iyep11;  Ize1 = Izep11
                    Ixe2 = Ixep12;  Iye2 = Iyep12;  Ize2 = Izep12
                  end
                end
              end
            end
          end
        end
      end
    end

    rys1.destroy

    if (.ab_l_min < ERI_rms_min_l) then
      .form_esps_no_rm(Ixa,Iya,Iza,esps,eub)
    else
      .form_esps_rm(Ixa,Iya,Iza,esps,eub,n_sum)
    end

    Iza.destroy
    Iya.destroy
    Ixa.destroy
  end

  make_psfs(psfs) ::: private
  ! Makes the initial (ps|fs) integrals, summed over the primitives
    self :: IN
    psfs :: REALMAT, OUT
    Ixa,Iya,Iza :: REALMAT3*
    rys1 :: RYS*
    Ix,Iy,Iz :: REALMAT*
    zeta,eta,xx,normab,zinv,rho,einv,rho_zinv,rho_einv :: REAL
    QPx,QPy,QPz,PAx,PAy,PAz,Qx,Qy,Qz,QCx,QCy,QCz,Px,Py,Pz :: REAL
    cf,bb,wt :: REAL
    Ix12,Iy12,Iz12,Ix21,Iy21,Iz21,Ix22,Iy22,Iz22 :: REAL
    Ix1f1,Iy1f1,Iz1f1,Ix1f,Iy1f,Iz1f,Ix1fp1,Iy1fp1,Iz1fp1 :: REAL
    Ix2f1,Iy2f1,Iz2f1,Ix2f,Iy2f,Iz2f,Ix2fp1,Iy2fp1,Iz2fp1 :: REAL
    t2,t2_rz,t2_re,half_einv,cf1 :: REAL
    ag,bg,cg,dg,nroots,eub,fub,dim1,dim2 :: INT
    fp1,n,i,j,k,n_sum :: INT

    eub = 3
    fub = .cd_l_sum.n_comp_sum - (.cd_l_max-1).n_comp_sum
    dim1 = 2
    dim2 = .cd_l_sum + 1
    nroots = (dim1+dim2)/2

    ! number of elements to sum over
    n_sum = nroots * .ab_n_gaussian_pairs * .cd_n_gaussian_pairs
    Ixa.create(n_sum,dim1,dim2)
    Iya.create(n_sum,dim1,dim2)
    Iza.create(n_sum,dim1,dim2)

    rys1.create(nroots)

    i = 0
    k = 0
    do bg = 1, .b.n_cc
      do ag = 1, .a.n_cc
        k = k + 1
        zeta = .ab_exponent_sum(k)
        zinv = ONE/zeta
        normab = .ab_cc_prefactor(k) * TWOPI5ON2
        Px = .ab_pair_center(1,k)
        Py = .ab_pair_center(2,k)
        Pz = .ab_pair_center(3,k)
        PAx = .ab_center_diff(1,k)
        PAy = .ab_center_diff(2,k)
        PAz = .ab_center_diff(3,k)
        j = 0
        do dg = 1, .d.n_cc
          do cg = 1, .c.n_cc
            j = j + 1
            eta  = .cd_exponent_sum(j)
            einv = ONE/eta
            Qx = .cd_pair_center(1,j)
            Qy = .cd_pair_center(2,j)
            Qz = .cd_pair_center(3,j)
            QCx = .cd_center_diff(1,j)
            QCy = .cd_center_diff(2,j)
            QCz = .cd_center_diff(3,j)
            rho  = zeta * eta / (zeta + eta)
            rho_zinv = rho * zinv
            rho_einv = rho * einv
            half_einv = HALF * einv
            QPx  = Qx - Px;   QPy  = Qy - Py;   QPz  = Qz - Pz
            xx   = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
            rys1.get_weights(xx)
            rys1.w(:) = rys1.w(:) * normab * .cd_cc_prefactor(j) * sqrt(rho)

            ! Now make the 2 dimensional integrals.
            do n=1,nroots
              i = i + 1
              Ix => Ixa(i,:,:)
              Iy => Iya(i,:,:)
              Iz => Iza(i,:,:)
              t2    = rys1.r(n)
              wt = rys1.w(n)
              t2_rz = t2 * rho_zinv
              t2_re = t2 * rho_einv
              bb    = t2_rz * half_einv
              cf    = (ONE - t2_re) * half_einv
              Ix12 = QCx - t2_re * QPx
              Iy12 = QCy - t2_re * QPy
              Iz12 = QCz - t2_re * QPz
              Ix21 = PAx + t2_rz * QPx
              Iy21 = PAy + t2_rz * QPy
              Iz21 = PAz + t2_rz * QPz
              Ix22 = Ix12 * Ix21 + bb
              Iy22 = Iy12 * Iy21 + bb
              Iz22 = Iz12 * Iz21 + bb
              Ix(1,1) = ONE;  Iy(1,1) = ONE;  Iz(1,1) = wt
              Ix(2,1) = Ix21; Iy(2,1) = Iy21; Iz(2,1) = Iz21 * wt
              Ix(1,2) = Ix12; Iy(1,2) = Iy12; Iz(1,2) = Iz12 * wt
              Ix(2,2) = Ix22; Iy(2,2) = Iy22; Iz(2,2) = Iz22 * wt
              if (.cd_l_sum>1) then
                Ix1f  = Ix12; Iy1f  = Iy12; Iz1f  = Iz12
                Ix1f1 = ONE;  Iy1f1 = ONE;  Iz1f1 = ONE
                Ix2f  = Ix22; Iy2f  = Iy22; Iz2f  = Iz22
                Ix2f1 = Ix21; Iy2f1 = Iy21; Iz2f1 = Iz21
                cf1 = ZERO
                do fp1 = 3,.cd_l_sum+1
                  cf1 = cf1 + cf
                  Ix1fp1 = Ix12*Ix1f + cf1*Ix1f1;            Ix(1,fp1) = Ix1fp1
                  Iy1fp1 = Iy12*Iy1f + cf1*Iy1f1;            Iy(1,fp1) = Iy1fp1
                  Iz1fp1 = Iz12*Iz1f + cf1*Iz1f1;            Iz(1,fp1) = Iz1fp1*wt
                  Ix2fp1 = Ix12*Ix2f + cf1*Ix2f1 + bb*Ix1f;  Ix(2,fp1) = Ix2fp1
                  Iy2fp1 = Iy12*Iy2f + cf1*Iy2f1 + bb*Iy1f;  Iy(2,fp1) = Iy2fp1
                  Iz2fp1 = Iz12*Iz2f + cf1*Iz2f1 + bb*Iz1f;  Iz(2,fp1) = Iz2fp1*wt
                  Ix1f1 = Ix1f;   Iy1f1 = Iy1f;   Iz1f1 = Iz1f
                  Ix1f  = Ix1fp1; Iy1f  = Iy1fp1; Iz1f  = Iz1fp1
                  Ix2f1 = Ix2f;   Iy2f1 = Iy2f;   Iz2f1 = Iz2f
                  Ix2f  = Ix2fp1; Iy2f  = Iy2fp1; Iz2f  = Iz2fp1
                end
              end
            end
          end
        end
      end
    end

    rys1.destroy

    if (.cd_l_min < ERI_rms_min_l) then
      .form_psfs_no_rm(Ixa,Iya,Iza,psfs,fub)
    else
      .form_psfs_rm(Ixa,Iya,Iza,psfs,fub,n_sum)
    end

    Iza.destroy
    Iya.destroy
    Ixa.destroy
  end

  make_psfs_low_ncc(psfs) ::: private
  ! Makes the initial (ps|fs) integrals, summed over the primitives
    self :: IN
    psfs :: REALMAT, OUT
    Ixa,Iya,Iza :: REALMAT3*
    rys1 :: RYS*
    Ix,Iy,Iz :: REALMAT*
    zeta,eta,xx,normab,zinv,rho,einv,rho_zinv,rho_einv :: REAL
    QPx,QPy,QPz,PAx,PAy,PAz,Qx,Qy,Qz,QCx,QCy,QCz,Px,Py,Pz :: REAL
    cf,bb,wt :: REAL
    Ix12,Iy12,Iz12,Ix21,Iy21,Iz21,Ix22,Iy22,Iz22 :: REAL
    Ix1f1,Iy1f1,Iz1f1,Ix1f,Iy1f,Iz1f,Ix1fp1,Iy1fp1,Iz1fp1 :: REAL
    Ix2f1,Iy2f1,Iz2f1,Ix2f,Iy2f,Iz2f,Ix2fp1,Iy2fp1,Iz2fp1 :: REAL
    Dx,Dy,Dz,Cx,Cy,Cz,Ctx,Cty,Ctz :: REAL
    d,d_cc,d_r2cd,c :: REAL
    t2,t2_rz,t2_re,half_einv,cf1 :: REAL
    ag,bg,cg,dg,nroots,eub,fub,dim1,dim2 :: INT
    fp1,n,i,k,n_sum :: INT

    eub = 3
    fub = .cd_l_sum.n_comp_sum - (.cd_l_max-1).n_comp_sum
    dim1 = 2
    dim2 = .cd_l_sum + 1
    nroots = (dim1+dim2)/2

    ! number of elements to sum over
    n_sum = nroots * .ab_n_gaussian_pairs * .cd_n_gaussian_pairs
    Ixa.create(n_sum,dim1,dim2)
    Iya.create(n_sum,dim1,dim2)
    Iza.create(n_sum,dim1,dim2)

    rys1.create(nroots)

    Cx = .pos_c(1);  Dx = .pos_d(1)
    Cy = .pos_c(2);  Dy = .pos_d(2)
    Cz = .pos_c(3);  Dz = .pos_d(3)
    if (.c.l > .d.l) then
      Ctx = Cx;  Cty = Cy;  Ctz = Cz
    else
      Ctx = Dx;  Cty = Dy;  Ctz = Dz
    end

    i = 0
    k = 0
    do bg = 1, .b.n_cc
      do ag = 1, .a.n_cc
        k = k + 1
        zeta = .ab_exponent_sum(k)
        zinv = ONE/zeta
        normab = .ab_cc_prefactor(k) * TWOPI5ON2
        Px = .ab_pair_center(1,k)
        Py = .ab_pair_center(2,k)
        Pz = .ab_pair_center(3,k)
        PAx = .ab_center_diff(1,k)
        PAy = .ab_center_diff(2,k)
        PAz = .ab_center_diff(3,k)
        do dg = 1, .d.n_cc
          d      = .d.ex(dg)
          d_cc   = .d.cc(dg)
          d_r2cd = d * .r2cd
          do cg = 1, .c.n_cc
            c    = .c.ex(cg)
            eta  = c + d
            einv = ONE/eta
            Qx = (d*Dx + c*Cx) * einv
            Qy = (d*Dy + c*Cy) * einv
            Qz = (d*Dz + c*Cz) * einv
            QCx = Qx - Ctx
            QCy = Qy - Cty
            QCz = Qz - Ctz
            rho  = zeta * eta / (zeta + eta)
            rho_zinv = rho * zinv
            rho_einv = rho * einv
            half_einv = HALF * einv
            QPx  = Qx - Px;   QPy  = Qy - Py;   QPz  = Qz - Pz
            xx   = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
            rys1.get_weights(xx)
            rys1.w(:) = rys1.w(:) * (normab * d_cc * .c.cc(cg) * &
                           einv * sqrt(rho_einv) * exp(-c*d_r2cd*einv))

            ! Now make the 2 dimensional integrals.
            do n=1,nroots
              i = i + 1
              Ix => Ixa(i,:,:)
              Iy => Iya(i,:,:)
              Iz => Iza(i,:,:)
              t2    = rys1.r(n)
              wt = rys1.w(n)
              t2_rz = t2 * rho_zinv
              t2_re = t2 * rho_einv
              bb    = t2_rz * half_einv
              cf    = (ONE - t2_re) * half_einv
              Ix12 = QCx - t2_re * QPx
              Iy12 = QCy - t2_re * QPy
              Iz12 = QCz - t2_re * QPz
              Ix21 = PAx + t2_rz * QPx
              Iy21 = PAy + t2_rz * QPy
              Iz21 = PAz + t2_rz * QPz
              Ix22 = Ix12 * Ix21 + bb
              Iy22 = Iy12 * Iy21 + bb
              Iz22 = Iz12 * Iz21 + bb
              Ix(1,1) = ONE;  Iy(1,1) = ONE;  Iz(1,1) = wt
              Ix(2,1) = Ix21; Iy(2,1) = Iy21; Iz(2,1) = Iz21 * wt
              Ix(1,2) = Ix12; Iy(1,2) = Iy12; Iz(1,2) = Iz12 * wt
              Ix(2,2) = Ix22; Iy(2,2) = Iy22; Iz(2,2) = Iz22 * wt
              if (.cd_l_sum>1) then
                Ix1f  = Ix12; Iy1f  = Iy12; Iz1f  = Iz12
                Ix1f1 = ONE;  Iy1f1 = ONE;  Iz1f1 = ONE
                Ix2f  = Ix22; Iy2f  = Iy22; Iz2f  = Iz22
                Ix2f1 = Ix21; Iy2f1 = Iy21; Iz2f1 = Iz21
                cf1 = ZERO
                do fp1 = 3,.cd_l_sum+1
                  cf1 = cf1 + cf
                  Ix1fp1 = Ix12*Ix1f + cf1*Ix1f1;            Ix(1,fp1) = Ix1fp1
                  Iy1fp1 = Iy12*Iy1f + cf1*Iy1f1;            Iy(1,fp1) = Iy1fp1
                  Iz1fp1 = Iz12*Iz1f + cf1*Iz1f1;            Iz(1,fp1) = Iz1fp1*wt
                  Ix2fp1 = Ix12*Ix2f + cf1*Ix2f1 + bb*Ix1f;  Ix(2,fp1) = Ix2fp1
                  Iy2fp1 = Iy12*Iy2f + cf1*Iy2f1 + bb*Iy1f;  Iy(2,fp1) = Iy2fp1
                  Iz2fp1 = Iz12*Iz2f + cf1*Iz2f1 + bb*Iz1f;  Iz(2,fp1) = Iz2fp1*wt
                  Ix1f1 = Ix1f;   Iy1f1 = Iy1f;   Iz1f1 = Iz1f
                  Ix1f  = Ix1fp1; Iy1f  = Iy1fp1; Iz1f  = Iz1fp1
                  Ix2f1 = Ix2f;   Iy2f1 = Iy2f;   Iz2f1 = Iz2f
                  Ix2f  = Ix2fp1; Iy2f  = Iy2fp1; Iz2f  = Iz2fp1
                end
              end
            end
          end
        end
      end
    end

    rys1.destroy

    if (.cd_l_min < ERI_rms_min_l) then
      .form_psfs_no_rm(Ixa,Iya,Iza,psfs,fub)
    else
      .form_psfs_rm(Ixa,Iya,Iza,psfs,fub,n_sum)
    end

    Iza.destroy
    Iya.destroy
    Ixa.destroy
  end

  form_esfs(Ix,Iy,Iz,esfs,eub,fub,n_sum) ::: private
  ! Forms (es|fs) from the two dimensional integrals, summed over primitives.
  ! This is the main routine, all the others are specialised and may break if
  ! given the wrong shell4.
    self :: IN
    Ix,Iy,Iz :: REALMAT3, IN
    esfs :: REALMAT, OUT
    eub,fub,n_sum :: INT, IN
    if (.ab_l_sum==1) then !sp
      if (.cd_l_min < ERI_rms_min_l) then !s or p or d
        .form_psfs_no_rm(Ix,Iy,Iz,esfs,fub)
      else
        .form_psfs_rm(Ix,Iy,Iz,esfs,fub,n_sum)
      end
    else if (.cd_l_sum==1) then !sp
      if (.ab_l_min < ERI_rms_min_l) then !s or p or d
        .form_esps_no_rm(Ix,Iy,Iz,esfs,eub)
      else
        .form_esps_rm(Ix,Iy,Iz,esfs,eub,n_sum)
      end
    else if (.ab_l_min < ERI_rms_min_l AND .cd_l_min < ERI_rms_min_l) then !s or p or d
      .form_esfs_no_rm(Ix,Iy,Iz,esfs,eub,fub)
    else
      .form_esfs_rm(Ix,Iy,Iz,esfs,eub,fub,n_sum)
    end
  end

  form_esfs_rm(Ix,Iy,Iz,esfs,eub,fub,n_sum) ::: private
  ! Forms (es|fs) from the two dimensional integrals, summed over primitives.
  ! This version uses the reduced multiplication scheme.
    self :: IN
    Ix,Iy,Iz :: REALMAT3, IN
    esfs :: REALMAT, OUT
    eub,fub,n_sum :: INT, IN
    e_x,f_x,ii_e_ivec,ii_f_ivec :: INTVEC*
    Ief :: REALMAT3*
    e,f,zf,yf,xf,ze,ye,iie,iif :: INT
    dime,dimf,dime1,dimf1 :: INT

    dime  = .ab_l_sum+1
    dime1 = .ab_l_sum+2
    dimf  = .cd_l_sum+1
    dimf1 = .cd_l_sum+2

    e_x => .ab_form_3dints_x_indices
    f_x => .cd_form_3dints_x_indices
    ii_e_ivec => .ab_form_3dints_yz_rms_indices
    ii_f_ivec => .cd_form_3dints_yz_rms_indices

    Ief.create(n_sum,dime*dime1/2,dimf*dimf1/2)

    ! Apply reduced multiplication scheme to Iy and Iz, store in triangle.
    iif = 0
    do zf=1,dimf
      do yf=1,dimf1-zf
        iif = iif + 1
        iie = 0
        do ze=1,dime
          do ye=1,dime1-ze
            iie = iie + 1
            Ief(:,iie,iif) = Iy(:,ye,yf) * Iz(:,ze,zf)
          end
        end
      end
    end
    ! Now add in the Ix 2d integrals and sum over contractions and roots
    do f=1,fub
      xf = f_x(f)
      iif = ii_f_ivec(f)
      do e=1,eub
        esfs(e,f) = sum(Ix(:,e_x(e),xf) * Ief(:,ii_e_ivec(e),iif))
      end
    end
    Ief.destroy
  end

  form_esfs_no_rm(Ix,Iy,Iz,esfs,eub,fub) ::: private
  ! Forms (es|fs) from the two dimensional integrals, summed over primitives.
  ! This version does not use the reduced multiplication scheme.
    self :: IN
    Ix,Iy,Iz :: REALMAT3, IN
    esfs :: REALMAT, OUT
    eub,fub :: INT, IN
    e_x,e_y,e_z,f_x,f_y,f_z :: INTVEC*
    e,f,zf,yf,xf :: INT

    e_x => .ab_form_3dints_x_indices
    e_y => .ab_form_3dints_y_indices
    e_z => .ab_form_3dints_z_indices
    f_x => .cd_form_3dints_x_indices
    f_y => .cd_form_3dints_y_indices
    f_z => .cd_form_3dints_z_indices

    do f=1,fub
      xf = f_x(f);  yf = f_y(f);  zf = f_z(f)
      do e=1,eub
        esfs(e,f) = sum(Ix(:,e_x(e),xf) * Iy(:,e_y(e),yf) * Iz(:,e_z(e),zf))
      end
    end
  end

  form_esps_no_rm(Ix,Iy,Iz,esfs,eub) ::: private
  ! Forms (es|ps) from the two dimensional integrals, summed over primitives.
  ! This version does not use the reduced multiplication scheme.
    self :: IN
    Ix,Iy,Iz :: REALMAT3, target
    esfs :: REALMAT, OUT
    eub :: INT, IN
    e_x,e_y,e_z :: INTVEC*
    Ix1,Iy1,Iz1 :: REALVEC*
    e,ze,ye,xe :: INT
    e_x => .ab_form_3dints_x_indices
    e_y => .ab_form_3dints_y_indices
    e_z => .ab_form_3dints_z_indices
    do e=1,eub
      xe = e_x(e);    ye = e_y(e);    ze = e_z(e)
      Ix1 => Ix(:,xe,1)
      Iy1 => Iy(:,ye,1)
      Iz1 => Iz(:,ze,1)
      esfs(e,1) = sum(Ix(:,xe,2)*Iy1*Iz1)
      esfs(e,2) = sum(Ix1*Iy(:,ye,2)*Iz1)
      esfs(e,3) = sum(Ix1*Iy1*Iz(:,ze,2))
    end
  end

  form_esps_rm(Ix,Iy,Iz,esfs,eub,n_sum) ::: private
  ! Forms (es|ps) from the two dimensional integrals, summed over primitives.
  ! This version does uses the reduced multiplication scheme.
    self :: IN
    Ix,Iy,Iz :: REALMAT3, target
    esfs :: REALMAT, OUT
    eub,n_sum :: INT, IN
    e_x,ii_e_ivec :: INTVEC*
    Ix1,Iy1,Iz1 :: REALVEC*
    Ief :: REALMAT3*
    e,ze,ye,xe,iie,dime,dime1 :: INT

    dime  = .ab_l_sum+1
    dime1 = .ab_l_sum+2

    e_x => .ab_form_3dints_x_indices
    ii_e_ivec => .ab_form_3dints_yz_rms_indices

    Ief.create(n_sum,dime*dime1/2,3)
    ! Apply reduced multiplication scheme to Iy and Iz, store in triangle.
    iie = 0
    do ze=1,dime
      do ye=1,dime1-ze
        iie = iie + 1
        Iy1 => Iy(:,ye,1)
        Iz1 => Iz(:,ze,1)
        Ief(:,iie,1) = Iy1 * Iz1
        Ief(:,iie,2) = Iy(:,ye,2) * Iz1
        Ief(:,iie,3) = Iy1 * Iz(:,ze,2)
      end
    end
    ! Now add in the Ix 2d integrals and sum over contractions and roots
    do e=1,eub
      iie = ii_e_ivec(e)
      xe = e_x(e)
      Ix1 => Ix(:,xe,1)
      esfs(e,1) = sum(Ix(:,xe,2) * Ief(:,iie,1))
      esfs(e,2) = sum(Ix1 * Ief(:,iie,2))
      esfs(e,3) = sum(Ix1 * Ief(:,iie,3))
    end
    Ief.destroy
  end

  form_psfs_rm(Ix,Iy,Iz,esfs,fub,n_sum) ::: private
  ! Forms (ps|fs) from the two dimensional integrals, summed over primitives.
  ! This version does uses the reduced multiplication scheme.
    self :: IN
    Ix,Iy,Iz :: REALMAT3, target
    esfs :: REALMAT, OUT
    fub,n_sum :: INT, IN
    f_x,ii_f_ivec :: INTVEC*
    Ief :: REALMAT3*
    Ix1,Iy1,Iz1 :: REALVEC*
    f,zf,yf,xf,iif,dimf,dimf1 :: INT

    dimf  = .cd_l_sum+1
    dimf1 = .cd_l_sum+2

    f_x => .cd_form_3dints_x_indices
    ii_f_ivec => .cd_form_3dints_yz_rms_indices

    Ief.create(n_sum,3,dimf*dimf1/2)
    ! Apply reduced multiplication scheme to Iy and Iz, store in triangle.
    iif = 0
    do zf=1,dimf
      do yf=1,dimf1-zf
        iif = iif + 1
        Iy1 => Iy(:,1,yf)
        Iz1 => Iz(:,1,zf)
        Ief(:,1,iif) = Iy1 * Iz1
        Ief(:,2,iif) = Iy(:,2,yf) * Iz1
        Ief(:,3,iif) = Iy1 * Iz(:,2,zf)
      end
    end
    ! Now add in the Ix 2d integrals and sum over contractions and roots
    do f=1,fub
      xf = f_x(f)
      iif = ii_f_ivec(f)
      Ix1 => Ix(:,1,xf)
      esfs(1,f) = sum(Ix(:,2,xf) * Ief(:,1,iif))
      esfs(2,f) = sum(Ix1 * Ief(:,2,iif))
      esfs(3,f) = sum(Ix1 * Ief(:,3,iif))
    end
    Ief.destroy
  end

  form_psfs_no_rm(Ix,Iy,Iz,esfs,fub) ::: private
  ! Forms (ps|fs) from the two dimensional integrals, summed over primitives.
  ! This version does not use the reduced multiplication scheme.
    self :: IN
    Ix,Iy,Iz :: REALMAT3, target
    esfs :: REALMAT, OUT
    fub :: INT, IN
    f_x,f_y,f_z :: INTVEC*
    Ix1,Iy1,Iz1 :: REALVEC*
    f,zf,yf,xf :: INT

    f_x => .cd_form_3dints_x_indices
    f_y => .cd_form_3dints_y_indices
    f_z => .cd_form_3dints_z_indices

    do f=1,fub
      xf = f_x(f);    yf = f_y(f);    zf = f_z(f)
      Ix1 => Ix(:,1,xf)
      Iy1 => Iy(:,1,yf)
      Iz1 => Iz(:,1,zf)
      esfs(1,f) = sum(Ix(:,2,xf)*Iy1*Iz1)
      esfs(2,f) = sum(Ix1*Iy(:,2,yf)*Iz1)
      esfs(3,f) = sum(Ix1*Iy1*Iz(:,2,zf))
    end
  end

  make_dsds(abcd) ::: private
  ! Makes the (ds|ds) integrals, summed over primitives.
    self :: IN
    abcd :: REALMAT4, OUT
    dsds :: REALMAT(3,3)
    if (.ab_n_gaussian_pairs > n_cc_cutoff) then
      .make_dsds(dsds)
    else
      .make_dsds_low_ncc(dsds)
    end
    if (.a.l == 2) then
      if (.c.l == 2) then
        abcd(:,1,:,1) = dsds ! dsds
      else
        abcd(:,1,1,:) = dsds ! dssd
      end
    else
      if (.c.l == 2) then
        abcd(1,:,:,1) = dsds ! sdds
      else
        abcd(1,:,1,:) = dsds ! sdsd
      end
    end
  end

  make_dsds(dsds) ::: private
  ! Makes the initial (es|fs) integrals, summed over the primitives
    self :: IN
    dsds :: REALMAT, OUT
    rys1 :: RYS*
    zeta,eta,xx,normab,zinv,rho,einv,rho_zinv,rho_einv :: REAL
    QPx,QPy,QPz,PAx,PAy,PAz,Qx,Qy,Qz,QCx,QCy,QCz,Px,Py,Pz :: REAL
    ce,cf,bb,bb2,wt :: REAL
    Ix12,Iy12,Iz12,Ix21,Iy21,Iz21,Ix22,Iy22,Iz22 :: REAL
    Ix13,Iy13,Iz13,Ix31,Iy31,Iz31,Ix33,Iy33,Iz33 :: REAL
    Ix23,Iy23,Iz23,Ix32,Iy32,Iz32 :: REAL
    dsds11,dsds12,dsds13,dsds14,dsds15,dsds16 :: REAL
    dsds21,dsds22,dsds23,dsds24,dsds25,dsds26 :: REAL
    dsds31,dsds32,dsds33,dsds34,dsds35,dsds36 :: REAL
    dsds41,dsds42,dsds43,dsds44,dsds45,dsds46 :: REAL
    dsds51,dsds52,dsds53,dsds54,dsds55,dsds56 :: REAL
    dsds61,dsds62,dsds63,dsds64,dsds65,dsds66 :: REAL
    norm1,norm2,norm3,norm4,norm5,norm6 :: REAL
    norm1_norm2,norm1_norm3,norm1_norm4 :: REAL
    norm1_norm5,norm1_norm6,norm2_norm3 :: REAL
    norm2_norm4,norm2_norm5,norm2_norm6 :: REAL
    norm3_norm4,norm3_norm5,norm3_norm6 :: REAL
    norm4_norm5,norm4_norm6,norm5_norm6 :: REAL
    t2,t2_rz,t2_re,half_zinv,half_einv :: REAL
    ag,bg,cg,dg,n,j,k :: INT

    rys1.create(3)

    dsds11 = ZERO; dsds12 = ZERO; dsds13 = ZERO
    dsds14 = ZERO; dsds15 = ZERO; dsds16 = ZERO
    dsds21 = ZERO; dsds22 = ZERO; dsds23 = ZERO
    dsds24 = ZERO; dsds25 = ZERO; dsds26 = ZERO
    dsds31 = ZERO; dsds32 = ZERO; dsds33 = ZERO
    dsds34 = ZERO; dsds35 = ZERO; dsds36 = ZERO
    dsds41 = ZERO; dsds42 = ZERO; dsds43 = ZERO
    dsds44 = ZERO; dsds45 = ZERO; dsds46 = ZERO
    dsds51 = ZERO; dsds52 = ZERO; dsds53 = ZERO
    dsds54 = ZERO; dsds55 = ZERO; dsds56 = ZERO
    dsds61 = ZERO; dsds62 = ZERO; dsds63 = ZERO
    dsds64 = ZERO; dsds65 = ZERO; dsds66 = ZERO

    k = 0
    do bg = 1, .b.n_cc
      do ag = 1, .a.n_cc
        k = k + 1
        zeta = .ab_exponent_sum(k)
        zinv = ONE/zeta
        half_zinv = HALF * zinv
        normab = .ab_cc_prefactor(k) * TWOPI5ON2
        Px = .ab_pair_center(1,k)
        Py = .ab_pair_center(2,k)
        Pz = .ab_pair_center(3,k)
        PAx = .ab_center_diff(1,k)
        PAy = .ab_center_diff(2,k)
        PAz = .ab_center_diff(3,k)
        j = 0
        do dg = 1, .d.n_cc
          do cg = 1, .c.n_cc
            j = j + 1
            eta  = .cd_exponent_sum(j)
            einv = ONE/eta
            Qx = .cd_pair_center(1,j)
            Qy = .cd_pair_center(2,j)
            Qz = .cd_pair_center(3,j)
            QCx = .cd_center_diff(1,j)
            QCy = .cd_center_diff(2,j)
            QCz = .cd_center_diff(3,j)
            rho  = zeta * eta / (zeta + eta)
            rho_zinv = rho * zinv
            rho_einv = rho * einv
            half_einv = HALF * einv
            QPx  = Qx - Px;   QPy  = Qy - Py;   QPz  = Qz - Pz
            xx   = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
            rys1.get_weights(xx)
            rys1.w(:) = rys1.w(:) * (normab * .cd_cc_prefactor(j) * sqrt(rho))

            ! Now make the 2 dimensional integrals.
            do n=1,3
              t2    = rys1.r(n)
              wt    = rys1.w(n)
              t2_rz = t2 * rho_zinv
              t2_re = t2 * rho_einv
              bb    = t2_rz * half_einv
              bb2   = bb+bb
              ce    = (ONE - t2_rz) * half_zinv
              cf    = (ONE - t2_re) * half_einv
              Ix12 = QCx - t2_re * QPx
              Iy12 = QCy - t2_re * QPy
              Iz12 = QCz - t2_re * QPz
              Ix21 = PAx + t2_rz * QPx
              Iy21 = PAy + t2_rz * QPy
              Iz21 = PAz + t2_rz * QPz
              Ix22 = Ix12 * Ix21 + bb
              Iy22 = Iy12 * Iy21 + bb
              Iz22 = Iz12 * Iz21 + bb
              Ix13 = Ix12 * Ix12 + cf
              Iy13 = Iy12 * Iy12 + cf
              Iz13 = Iz12 * Iz12 + cf
              Ix31 = Ix21 * Ix21 + ce
              Iy31 = Iy21 * Iy21 + ce
              Iz31 = Iz21 * Iz21 + ce
              Ix23 = Ix12 * (Ix22 + bb) + cf * Ix21
              Iy23 = Iy12 * (Iy22 + bb) + cf * Iy21
              Iz23 = Iz12 * (Iz22 + bb) + cf * Iz21
              Ix32 = Ix21 * (Ix22 + bb) + ce * Ix12
              Iy32 = Iy21 * (Iy22 + bb) + ce * Iy12
              Iz32 = Iz21 * (Iz22 + bb) + ce * Iz12
              Ix33 = Ix21 * Ix23 + ce * Ix13 + bb2 * Ix22
              Iy33 = Iy21 * Iy23 + ce * Iy13 + bb2 * Iy22
              Iz33 = Iz21 * Iz23 + ce * Iz13 + bb2 * Iz22

              Iz12 = Iz12 * wt
              Iz21 = Iz21 * wt
              Iz22 = Iz22 * wt
              Iz13 = Iz13 * wt
              Iz31 = Iz31 * wt
              Iz23 = Iz23 * wt
              Iz32 = Iz32 * wt
              Iz33 = Iz33 * wt

              dsds33 = dsds33 +               Iz33
              dsds36 = dsds36 +        Iy12 * Iz32
              dsds32 = dsds32 +        Iy13 * Iz31
              dsds63 = dsds63 +        Iy21 * Iz23
              dsds66 = dsds66 +        Iy22 * Iz22
              dsds62 = dsds62 +        Iy23 * Iz21
              dsds23 = dsds23 +        Iy31 * Iz13
              dsds26 = dsds26 +        Iy32 * Iz12
              dsds22 = dsds22 +        Iy33 * wt
              dsds35 = dsds35 + Ix12 *        Iz32
              dsds34 = dsds34 + Ix12 * Iy12 * Iz31
              dsds65 = dsds65 + Ix12 * Iy21 * Iz22
              dsds64 = dsds64 + Ix12 * Iy22 * Iz21
              dsds25 = dsds25 + Ix12 * Iy31 * Iz12
              dsds24 = dsds24 + Ix12 * Iy32 * wt
              dsds31 = dsds31 + Ix13 *        Iz31
              dsds61 = dsds61 + Ix13 * Iy21 * Iz21
              dsds21 = dsds21 + Ix13 * Iy31 * wt
              dsds53 = dsds53 + Ix21 *        Iz23
              dsds56 = dsds56 + Ix21 * Iy12 * Iz22
              dsds52 = dsds52 + Ix21 * Iy13 * Iz21
              dsds43 = dsds43 + Ix21 * Iy21 * Iz13
              dsds46 = dsds46 + Ix21 * Iy22 * Iz12
              dsds42 = dsds42 + Ix21 * Iy23 * wt
              dsds55 = dsds55 + Ix22 *        Iz22
              dsds54 = dsds54 + Ix22 * Iy12 * Iz21
              dsds45 = dsds45 + Ix22 * Iy21 * Iz12
              dsds44 = dsds44 + Ix22 * Iy22 * wt
              dsds51 = dsds51 + Ix23 *        Iz21
              dsds41 = dsds41 + Ix23 * Iy21 * wt
              dsds13 = dsds13 + Ix31 *        Iz13
              dsds16 = dsds16 + Ix31 * Iy12 * Iz12
              dsds12 = dsds12 + Ix31 * Iy13 * wt
              dsds15 = dsds15 + Ix32 *        Iz12
              dsds14 = dsds14 + Ix32 * Iy12 * wt
              dsds11 = dsds11 + Ix33 *        wt
            end
          end
        end
      end
    end

    rys1.destroy
    norm1 = .cd_normalising_factors(1)
    norm2 = .cd_normalising_factors(2)
    norm3 = .cd_normalising_factors(3)
    norm4 = .cd_normalising_factors(4)
    norm5 = .cd_normalising_factors(5)
    norm6 = .cd_normalising_factors(6)
    norm1_norm2 = norm1 * norm2
    norm1_norm3 = norm1 * norm3
    norm1_norm4 = norm1 * norm4
    norm1_norm5 = norm1 * norm5
    norm1_norm6 = norm1 * norm6
    norm2_norm3 = norm2 * norm3
    norm2_norm4 = norm2 * norm4
    norm2_norm5 = norm2 * norm5
    norm2_norm6 = norm2 * norm6
    norm3_norm4 = norm3 * norm4
    norm3_norm5 = norm3 * norm5
    norm3_norm6 = norm3 * norm6
    norm4_norm5 = norm4 * norm5
    norm4_norm6 = norm4 * norm6
    norm5_norm6 = norm5 * norm6
    dsds(1,1) = dsds11 * norm1 * norm1
    dsds(1,2) = dsds12 * norm1_norm2
    dsds(1,3) = dsds13 * norm1_norm3
    dsds(1,4) = dsds14 * norm1_norm4
    dsds(1,5) = dsds15 * norm1_norm5
    dsds(1,6) = dsds16 * norm1_norm6
    dsds(2,1) = dsds21 * norm1_norm2
    dsds(2,2) = dsds22 * norm2 * norm2
    dsds(2,3) = dsds23 * norm2_norm3
    dsds(2,4) = dsds24 * norm2_norm4
    dsds(2,5) = dsds25 * norm2_norm5
    dsds(2,6) = dsds26 * norm2_norm6
    dsds(3,1) = dsds31 * norm1_norm3
    dsds(3,2) = dsds32 * norm2_norm3
    dsds(3,3) = dsds33 * norm3 *  norm3
    dsds(3,4) = dsds34 * norm3_norm4
    dsds(3,5) = dsds35 * norm3_norm5
    dsds(3,6) = dsds36 * norm3_norm6
    dsds(4,1) = dsds41 * norm1_norm4
    dsds(4,2) = dsds42 * norm2_norm4
    dsds(4,3) = dsds43 * norm3_norm4
    dsds(4,4) = dsds44 * norm4 * norm4
    dsds(4,5) = dsds45 * norm4_norm5
    dsds(4,6) = dsds46 * norm4_norm6
    dsds(5,1) = dsds51 * norm1_norm5
    dsds(5,2) = dsds52 * norm2_norm5
    dsds(5,3) = dsds53 * norm3_norm5
    dsds(5,4) = dsds54 * norm4_norm5
    dsds(5,5) = dsds55 * norm5 * norm5
    dsds(5,6) = dsds56 * norm5_norm6
    dsds(6,1) = dsds61 * norm1_norm6
    dsds(6,2) = dsds62 * norm2_norm6
    dsds(6,3) = dsds63 * norm3_norm6
    dsds(6,4) = dsds64 * norm4_norm6
    dsds(6,5) = dsds65 * norm5_norm6
    dsds(6,6) = dsds66 * norm6 * norm6
  end

  make_dsds_low_ncc(dsds) ::: private
  ! Makes the initial (es|fs) integrals, summed over the primitives
    self :: IN
    dsds :: REALMAT, OUT
    rys1 :: RYS*
    zeta,eta,xx,normab,zinv,rho,einv,rho_zinv,rho_einv :: REAL
    QPx,QPy,QPz,PAx,PAy,PAz,Qx,Qy,Qz,QCx,QCy,QCz,Px,Py,Pz :: REAL
    ce,cf,bb,bb2,wt :: REAL
    Ix12,Iy12,Iz12,Ix21,Iy21,Iz21,Ix22,Iy22,Iz22 :: REAL
    Ix13,Iy13,Iz13,Ix31,Iy31,Iz31,Ix33,Iy33,Iz33 :: REAL
    Ix23,Iy23,Iz23,Ix32,Iy32,Iz32 :: REAL
    dsds11,dsds12,dsds13,dsds14,dsds15,dsds16 :: REAL
    dsds21,dsds22,dsds23,dsds24,dsds25,dsds26 :: REAL
    dsds31,dsds32,dsds33,dsds34,dsds35,dsds36 :: REAL
    dsds41,dsds42,dsds43,dsds44,dsds45,dsds46 :: REAL
    dsds51,dsds52,dsds53,dsds54,dsds55,dsds56 :: REAL
    dsds61,dsds62,dsds63,dsds64,dsds65,dsds66 :: REAL
    norm1,norm2,norm3,norm4,norm5,norm6 :: REAL
    norm1_norm2,norm1_norm3,norm1_norm4 :: REAL
    norm1_norm5,norm1_norm6,norm2_norm3 :: REAL
    norm2_norm4,norm2_norm5,norm2_norm6 :: REAL
    norm3_norm4,norm3_norm5,norm3_norm6 :: REAL
    norm4_norm5,norm4_norm6,norm5_norm6 :: REAL
    Dx,Dy,Dz,Cx,Cy,Cz,Ctx,Cty,Ctz :: REAL
    d,d_cc,d_r2cd,c :: REAL
    t2,t2_rz,t2_re,half_zinv,half_einv :: REAL
    ag,bg,cg,dg,n,k :: INT

    rys1.create(3)

    dsds11 = ZERO; dsds12 = ZERO; dsds13 = ZERO
    dsds14 = ZERO; dsds15 = ZERO; dsds16 = ZERO
    dsds21 = ZERO; dsds22 = ZERO; dsds23 = ZERO
    dsds24 = ZERO; dsds25 = ZERO; dsds26 = ZERO
    dsds31 = ZERO; dsds32 = ZERO; dsds33 = ZERO
    dsds34 = ZERO; dsds35 = ZERO; dsds36 = ZERO
    dsds41 = ZERO; dsds42 = ZERO; dsds43 = ZERO
    dsds44 = ZERO; dsds45 = ZERO; dsds46 = ZERO
    dsds51 = ZERO; dsds52 = ZERO; dsds53 = ZERO
    dsds54 = ZERO; dsds55 = ZERO; dsds56 = ZERO
    dsds61 = ZERO; dsds62 = ZERO; dsds63 = ZERO
    dsds64 = ZERO; dsds65 = ZERO; dsds66 = ZERO

    Cx = .pos_c(1);  Dx = .pos_d(1)
    Cy = .pos_c(2);  Dy = .pos_d(2)
    Cz = .pos_c(3);  Dz = .pos_d(3)
    if (.c.l > .d.l) then
      Ctx = Cx;  Cty = Cy;  Ctz = Cz
    else
      Ctx = Dx;  Cty = Dy;  Ctz = Dz
    end
    k = 0
    do bg = 1, .b.n_cc
      do ag = 1, .a.n_cc
        k = k + 1
        zeta = .ab_exponent_sum(k)
        zinv = ONE/zeta
        half_zinv = HALF * zinv
        normab = .ab_cc_prefactor(k) * TWOPI5ON2
        Px = .ab_pair_center(1,k)
        Py = .ab_pair_center(2,k)
        Pz = .ab_pair_center(3,k)
        PAx = .ab_center_diff(1,k)
        PAy = .ab_center_diff(2,k)
        PAz = .ab_center_diff(3,k)
        do dg = 1, .d.n_cc
          d      = .d.ex(dg)
          d_cc   = .d.cc(dg)
          d_r2cd = d * .r2cd
          do cg = 1, .c.n_cc
            c    = .c.ex(cg)
            eta  = c + d
            einv = ONE/eta
            Qx = (d*Dx + c*Cx) * einv
            Qy = (d*Dy + c*Cy) * einv
            Qz = (d*Dz + c*Cz) * einv
            QCx = Qx - Ctx
            QCy = Qy - Cty
            QCz = Qz - Ctz
            rho  = zeta * eta / (zeta + eta)
            rho_zinv = rho * zinv
            rho_einv = rho * einv
            half_einv = HALF * einv
            QPx  = Qx - Px;   QPy  = Qy - Py;   QPz  = Qz - Pz
            xx   = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
            rys1.get_weights(xx)
            rys1.w(:) = rys1.w(:) * (normab * d_cc * .c.cc(cg) * &
                           einv * sqrt(rho_einv) * exp(-c*d_r2cd*einv))

            ! Now make the 2 dimensional integrals.
            do n=1,3
              t2    = rys1.r(n)
              wt    = rys1.w(n)
              t2_rz = t2 * rho_zinv
              t2_re = t2 * rho_einv
              bb    = t2_rz * half_einv
              bb2   = bb+bb
              ce    = (ONE - t2_rz) * half_zinv
              cf    = (ONE - t2_re) * half_einv
              Ix12 = QCx - t2_re * QPx
              Iy12 = QCy - t2_re * QPy
              Iz12 = QCz - t2_re * QPz
              Ix21 = PAx + t2_rz * QPx
              Iy21 = PAy + t2_rz * QPy
              Iz21 = PAz + t2_rz * QPz
              Ix22 = Ix12 * Ix21 + bb
              Iy22 = Iy12 * Iy21 + bb
              Iz22 = Iz12 * Iz21 + bb
              Ix13 = Ix12 * Ix12 + cf
              Iy13 = Iy12 * Iy12 + cf
              Iz13 = Iz12 * Iz12 + cf
              Ix31 = Ix21 * Ix21 + ce
              Iy31 = Iy21 * Iy21 + ce
              Iz31 = Iz21 * Iz21 + ce
              Ix23 = Ix12 * (Ix22 + bb) + cf * Ix21
              Iy23 = Iy12 * (Iy22 + bb) + cf * Iy21
              Iz23 = Iz12 * (Iz22 + bb) + cf * Iz21
              Ix32 = Ix21 * (Ix22 + bb) + ce * Ix12
              Iy32 = Iy21 * (Iy22 + bb) + ce * Iy12
              Iz32 = Iz21 * (Iz22 + bb) + ce * Iz12
              Ix33 = Ix21 * Ix23 + ce * Ix13 + bb2 * Ix22
              Iy33 = Iy21 * Iy23 + ce * Iy13 + bb2 * Iy22
              Iz33 = Iz21 * Iz23 + ce * Iz13 + bb2 * Iz22

              Iz12 = Iz12 * wt
              Iz21 = Iz21 * wt
              Iz22 = Iz22 * wt
              Iz13 = Iz13 * wt
              Iz31 = Iz31 * wt
              Iz23 = Iz23 * wt
              Iz32 = Iz32 * wt
              Iz33 = Iz33 * wt

              dsds33 = dsds33 +               Iz33
              dsds36 = dsds36 +        Iy12 * Iz32
              dsds32 = dsds32 +        Iy13 * Iz31
              dsds63 = dsds63 +        Iy21 * Iz23
              dsds66 = dsds66 +        Iy22 * Iz22
              dsds62 = dsds62 +        Iy23 * Iz21
              dsds23 = dsds23 +        Iy31 * Iz13
              dsds26 = dsds26 +        Iy32 * Iz12
              dsds22 = dsds22 +        Iy33 * wt
              dsds35 = dsds35 + Ix12 *        Iz32
              dsds34 = dsds34 + Ix12 * Iy12 * Iz31
              dsds65 = dsds65 + Ix12 * Iy21 * Iz22
              dsds64 = dsds64 + Ix12 * Iy22 * Iz21
              dsds25 = dsds25 + Ix12 * Iy31 * Iz12
              dsds24 = dsds24 + Ix12 * Iy32 * wt
              dsds31 = dsds31 + Ix13 *        Iz31
              dsds61 = dsds61 + Ix13 * Iy21 * Iz21
              dsds21 = dsds21 + Ix13 * Iy31 * wt
              dsds53 = dsds53 + Ix21 *        Iz23
              dsds56 = dsds56 + Ix21 * Iy12 * Iz22
              dsds52 = dsds52 + Ix21 * Iy13 * Iz21
              dsds43 = dsds43 + Ix21 * Iy21 * Iz13
              dsds46 = dsds46 + Ix21 * Iy22 * Iz12
              dsds42 = dsds42 + Ix21 * Iy23 * wt
              dsds55 = dsds55 + Ix22 *        Iz22
              dsds54 = dsds54 + Ix22 * Iy12 * Iz21
              dsds45 = dsds45 + Ix22 * Iy21 * Iz12
              dsds44 = dsds44 + Ix22 * Iy22 * wt
              dsds51 = dsds51 + Ix23 *        Iz21
              dsds41 = dsds41 + Ix23 * Iy21 * wt
              dsds13 = dsds13 + Ix31 *        Iz13
              dsds16 = dsds16 + Ix31 * Iy12 * Iz12
              dsds12 = dsds12 + Ix31 * Iy13 * wt
              dsds15 = dsds15 + Ix32 *        Iz12
              dsds14 = dsds14 + Ix32 * Iy12 * wt
              dsds11 = dsds11 + Ix33 *        wt
            end
          end
        end
      end
    end

    rys1.destroy
    norm1 = .cd_normalising_factors(1)
    norm2 = .cd_normalising_factors(2)
    norm3 = .cd_normalising_factors(3)
    norm4 = .cd_normalising_factors(4)
    norm5 = .cd_normalising_factors(5)
    norm6 = .cd_normalising_factors(6)
    norm1_norm2 = norm1 * norm2
    norm1_norm3 = norm1 * norm3
    norm1_norm4 = norm1 * norm4
    norm1_norm5 = norm1 * norm5
    norm1_norm6 = norm1 * norm6
    norm2_norm3 = norm2 * norm3
    norm2_norm4 = norm2 * norm4
    norm2_norm5 = norm2 * norm5
    norm2_norm6 = norm2 * norm6
    norm3_norm4 = norm3 * norm4
    norm3_norm5 = norm3 * norm5
    norm3_norm6 = norm3 * norm6
    norm4_norm5 = norm4 * norm5
    norm4_norm6 = norm4 * norm6
    norm5_norm6 = norm5 * norm6
    dsds(1,1) = dsds11 * norm1 * norm1
    dsds(1,2) = dsds12 * norm1_norm2
    dsds(1,3) = dsds13 * norm1_norm3
    dsds(1,4) = dsds14 * norm1_norm4
    dsds(1,5) = dsds15 * norm1_norm5
    dsds(1,6) = dsds16 * norm1_norm6
    dsds(2,1) = dsds21 * norm1_norm2
    dsds(2,2) = dsds22 * norm2 * norm2
    dsds(2,3) = dsds23 * norm2_norm3
    dsds(2,4) = dsds24 * norm2_norm4
    dsds(2,5) = dsds25 * norm2_norm5
    dsds(2,6) = dsds26 * norm2_norm6
    dsds(3,1) = dsds31 * norm1_norm3
    dsds(3,2) = dsds32 * norm2_norm3
    dsds(3,3) = dsds33 * norm3 *  norm3
    dsds(3,4) = dsds34 * norm3_norm4
    dsds(3,5) = dsds35 * norm3_norm5
    dsds(3,6) = dsds36 * norm3_norm6
    dsds(4,1) = dsds41 * norm1_norm4
    dsds(4,2) = dsds42 * norm2_norm4
    dsds(4,3) = dsds43 * norm3_norm4
    dsds(4,4) = dsds44 * norm4 * norm4
    dsds(4,5) = dsds45 * norm4_norm5
    dsds(4,6) = dsds46 * norm4_norm6
    dsds(5,1) = dsds51 * norm1_norm5
    dsds(5,2) = dsds52 * norm2_norm5
    dsds(5,3) = dsds53 * norm3_norm5
    dsds(5,4) = dsds54 * norm4_norm5
    dsds(5,5) = dsds55 * norm5 * norm5
    dsds(5,6) = dsds56 * norm5_norm6
    dsds(6,1) = dsds61 * norm1_norm6
    dsds(6,2) = dsds62 * norm2_norm6
    dsds(6,3) = dsds63 * norm3_norm6
    dsds(6,4) = dsds64 * norm4_norm6
    dsds(6,5) = dsds65 * norm5_norm6
    dsds(6,6) = dsds66 * norm6 * norm6
  end

  make_psds(abcd) ::: private
  ! Makes the (ds|ds) integrals, summed over primitives.
    self :: IN
    abcd :: REALMAT4, OUT
    psds :: REALMAT(3,3)
    if (.ab_n_gaussian_pairs > n_cc_cutoff) then
      .make_psds(psds)
    else
      .make_psds_low_ncc(psds)
    end
    if (.a.l == 1) then
      if (.c.l == 2) then
        abcd(:,1,:,1) = psds ! psds
      else
        abcd(:,1,1,:) = psds ! pssd
      end
    else
      if (.c.l == 2) then
        abcd(1,:,:,1) = psds ! spds
      else
        abcd(1,:,1,:) = psds ! spsd
      end
    end
  end

  make_psds(psds) ::: private
  ! Makes the initial (ps|fs) integrals, summed over the primitives
    self :: IN
    psds :: REALMAT, OUT
    rys1 :: RYS*
    zeta,eta,xx,normab,zinv,rho,einv,rho_zinv,rho_einv :: REAL
    QPx,QPy,QPz,PAx,PAy,PAz,Qx,Qy,Qz,QCx,QCy,QCz,Px,Py,Pz :: REAL
    cf,bb,wt :: REAL
    Ix12,Iy12,Iz12,Ix21,Iy21,Iz21,Ix22,Iy22,Iz22 :: REAL
    Ix13,Iy13,Iz13,Ix23,Iy23,Iz23 :: REAL
    psds11,psds12,psds13,psds14,psds15,psds16 :: REAL
    psds21,psds22,psds23,psds24,psds25,psds26 :: REAL
    psds31,psds32,psds33,psds34,psds35,psds36 :: REAL
    t2,t2_rz,t2_re,half_einv :: REAL
    norm1,norm2,norm3,norm4,norm5,norm6 :: REAL
    ag,bg,cg,dg,n,j,k :: INT

    rys1.create(2)
    psds11 = ZERO; psds12 = ZERO; psds13 = ZERO
    psds14 = ZERO; psds15 = ZERO; psds16 = ZERO
    psds21 = ZERO; psds22 = ZERO; psds23 = ZERO
    psds24 = ZERO; psds25 = ZERO; psds26 = ZERO
    psds31 = ZERO; psds32 = ZERO; psds33 = ZERO
    psds34 = ZERO; psds35 = ZERO; psds36 = ZERO

    k = 0
    do bg = 1, .b.n_cc
      do ag = 1, .a.n_cc
        k = k + 1
        zeta = .ab_exponent_sum(k)
        zinv = ONE/zeta
        normab = .ab_cc_prefactor(k) * TWOPI5ON2
        Px = .ab_pair_center(1,k)
        Py = .ab_pair_center(2,k)
        Pz = .ab_pair_center(3,k)
        PAx = .ab_center_diff(1,k)
        PAy = .ab_center_diff(2,k)
        PAz = .ab_center_diff(3,k)
        j = 0
        do dg = 1, .d.n_cc
          do cg = 1, .c.n_cc
            j = j + 1
            eta  = .cd_exponent_sum(j)
            einv = ONE/eta
            Qx = .cd_pair_center(1,j)
            Qy = .cd_pair_center(2,j)
            Qz = .cd_pair_center(3,j)
            QCx = .cd_center_diff(1,j)
            QCy = .cd_center_diff(2,j)
            QCz = .cd_center_diff(3,j)
            rho  = zeta * eta / (zeta + eta)
            rho_zinv = rho * zinv
            rho_einv = rho * einv
            half_einv = HALF * einv
            QPx  = Qx - Px;   QPy  = Qy - Py;   QPz  = Qz - Pz
            xx   = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
            rys1.get_weights(xx)
            rys1.w(:) = rys1.w(:) * normab * .cd_cc_prefactor(j) * sqrt(rho)

            ! Now make the 2 dimensional integrals.
            do n=1,2
              t2    = rys1.r(n)
              wt = rys1.w(n)
              t2_rz = t2 * rho_zinv
              t2_re = t2 * rho_einv
              bb    = t2_rz * half_einv
              cf    = (ONE - t2_re) * half_einv
              Ix12 = QCx - t2_re * QPx
              Iy12 = QCy - t2_re * QPy
              Iz12 = QCz - t2_re * QPz
              Ix21 = PAx + t2_rz * QPx
              Iy21 = PAy + t2_rz * QPy
              Iz21 = PAz + t2_rz * QPz
              Ix22 = Ix12 * Ix21 + bb
              Iy22 = Iy12 * Iy21 + bb
              Iz22 = Iz12 * Iz21 + bb
              Ix13 = Ix12*Ix12 + cf
              Iy13 = Iy12*Iy12 + cf
              Iz13 = (Iz12*Iz12 + cf)*wt
              Iz12 = Iz12 * wt
              Iz21 = Iz21 * wt
              Ix23 = Ix12*(Ix22 + bb) + cf*Ix21
              Iy23 = Iy12*(Iy22 + bb) + cf*Iy21
              Iz23 = Iz12*(Iz22 + bb) + cf*Iz21
              Iz22 = Iz22 * wt

              psds11 = psds11 + Ix23 *        wt
              psds12 = psds12 + Ix21 * Iy13 * wt
              psds13 = psds13 + Ix21 *        Iz13
              psds14 = psds14 + Ix22 * Iy12 * wt
              psds15 = psds15 + Ix22 *        Iz12
              psds16 = psds16 + Ix21 * Iy12 * Iz12
              psds21 = psds21 + Ix13 * Iy21 * wt
              psds22 = psds22 +        Iy23 * wt
              psds23 = psds23 +        Iy21 * Iz13
              psds24 = psds24 + Ix12 * Iy22 * wt
              psds25 = psds25 + Ix12 * Iy21 * Iz12
              psds26 = psds26 +        Iy22 * Iz12
              psds31 = psds31 + Ix13 *        Iz21
              psds32 = psds32 +        Iy13 * Iz21
              psds33 = psds33 +               Iz23
              psds34 = psds34 + Ix12 * Iy12 * Iz21
              psds35 = psds35 + Ix12 *        Iz22
              psds36 = psds36 +        Iy12 * Iz22
            end
          end
        end
      end
    end
    rys1.destroy
    norm1 = .cd_normalising_factors(1)
    norm2 = .cd_normalising_factors(2)
    norm3 = .cd_normalising_factors(3)
    norm4 = .cd_normalising_factors(4)
    norm5 = .cd_normalising_factors(5)
    norm6 = .cd_normalising_factors(6)
    psds(1,1) = psds11 * norm1
    psds(1,2) = psds12 * norm2
    psds(1,3) = psds13 * norm3
    psds(1,4) = psds14 * norm4
    psds(1,5) = psds15 * norm5
    psds(1,6) = psds16 * norm6
    psds(2,1) = psds21 * norm1
    psds(2,2) = psds22 * norm2
    psds(2,3) = psds23 * norm3
    psds(2,4) = psds24 * norm4
    psds(2,5) = psds25 * norm5
    psds(2,6) = psds26 * norm6
    psds(3,1) = psds31 * norm1
    psds(3,2) = psds32 * norm2
    psds(3,3) = psds33 * norm3
    psds(3,4) = psds34 * norm4
    psds(3,5) = psds35 * norm5
    psds(3,6) = psds36 * norm6
  end

  make_psds_low_ncc(psds) ::: private
  ! Makes the initial (ps|fs) integrals, summed over the primitives
    self :: IN
    psds :: REALMAT, OUT
    rys1 :: RYS*
    zeta,eta,xx,normab,zinv,rho,einv,rho_zinv,rho_einv :: REAL
    QPx,QPy,QPz,PAx,PAy,PAz,Qx,Qy,Qz,QCx,QCy,QCz,Px,Py,Pz :: REAL
    cf,bb,wt :: REAL
    Ix12,Iy12,Iz12,Ix21,Iy21,Iz21,Ix22,Iy22,Iz22 :: REAL
    Ix13,Iy13,Iz13,Ix23,Iy23,Iz23 :: REAL
    psds11,psds12,psds13,psds14,psds15,psds16 :: REAL
    psds21,psds22,psds23,psds24,psds25,psds26 :: REAL
    psds31,psds32,psds33,psds34,psds35,psds36 :: REAL
    Dx,Dy,Dz,Cx,Cy,Cz,Ctx,Cty,Ctz :: REAL
    d,d_cc,d_r2cd,c :: REAL
    t2,t2_rz,t2_re,half_zinv,half_einv :: REAL
    norm1,norm2,norm3,norm4,norm5,norm6 :: REAL
    ag,bg,cg,dg,n,k :: INT

    rys1.create(2)
    psds11 = ZERO; psds12 = ZERO; psds13 = ZERO
    psds14 = ZERO; psds15 = ZERO; psds16 = ZERO
    psds21 = ZERO; psds22 = ZERO; psds23 = ZERO
    psds24 = ZERO; psds25 = ZERO; psds26 = ZERO
    psds31 = ZERO; psds32 = ZERO; psds33 = ZERO
    psds34 = ZERO; psds35 = ZERO; psds36 = ZERO

    Cx = .pos_c(1);  Dx = .pos_d(1)
    Cy = .pos_c(2);  Dy = .pos_d(2)
    Cz = .pos_c(3);  Dz = .pos_d(3)
    if (.c.l > .d.l) then
      Ctx = Cx;  Cty = Cy;  Ctz = Cz
    else
      Ctx = Dx;  Cty = Dy;  Ctz = Dz
    end
    k = 0
    do bg = 1, .b.n_cc
      do ag = 1, .a.n_cc
        k = k + 1
        zeta = .ab_exponent_sum(k)
        zinv = ONE/zeta
        half_zinv = HALF * zinv
        normab = .ab_cc_prefactor(k) * TWOPI5ON2
        Px = .ab_pair_center(1,k)
        Py = .ab_pair_center(2,k)
        Pz = .ab_pair_center(3,k)
        PAx = .ab_center_diff(1,k)
        PAy = .ab_center_diff(2,k)
        PAz = .ab_center_diff(3,k)
        do dg = 1, .d.n_cc
          d      = .d.ex(dg)
          d_cc   = .d.cc(dg)
          d_r2cd = d * .r2cd
          do cg = 1, .c.n_cc
            c    = .c.ex(cg)
            eta  = c + d
            einv = ONE/eta
            Qx = (d*Dx + c*Cx) * einv
            Qy = (d*Dy + c*Cy) * einv
            Qz = (d*Dz + c*Cz) * einv
            QCx = Qx - Ctx
            QCy = Qy - Cty
            QCz = Qz - Ctz
            rho  = zeta * eta / (zeta + eta)
            rho_zinv = rho * zinv
            rho_einv = rho * einv
            half_einv = HALF * einv
            QPx  = Qx - Px;   QPy  = Qy - Py;   QPz  = Qz - Pz
            xx   = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
            rys1.get_weights(xx)
            rys1.w(:) = rys1.w(:) * (normab * d_cc * .c.cc(cg) * &
                           einv * sqrt(rho_einv) * exp(-c*d_r2cd*einv))

            ! Now make the 2 dimensional integrals.
            do n=1,2
              t2    = rys1.r(n)
              wt = rys1.w(n)
              t2_rz = t2 * rho_zinv
              t2_re = t2 * rho_einv
              bb    = t2_rz * half_einv
              cf    = (ONE - t2_re) * half_einv
              Ix12 = QCx - t2_re * QPx
              Iy12 = QCy - t2_re * QPy
              Iz12 = QCz - t2_re * QPz
              Ix21 = PAx + t2_rz * QPx
              Iy21 = PAy + t2_rz * QPy
              Iz21 = PAz + t2_rz * QPz
              Ix22 = Ix12 * Ix21 + bb
              Iy22 = Iy12 * Iy21 + bb
              Iz22 = Iz12 * Iz21 + bb
              Ix13 = Ix12*Ix12 + cf
              Iy13 = Iy12*Iy12 + cf
              Iz13 = (Iz12*Iz12 + cf)*wt
              Iz12 = Iz12 * wt
              Iz21 = Iz21 * wt
              Ix23 = Ix12*(Ix22 + bb) + cf*Ix21
              Iy23 = Iy12*(Iy22 + bb) + cf*Iy21
              Iz23 = Iz12*(Iz22 + bb) + cf*Iz21
              Iz22 = Iz22 * wt

              psds11 = psds11 + Ix23 *        wt
              psds12 = psds12 + Ix21 * Iy13 * wt
              psds13 = psds13 + Ix21 *        Iz13
              psds14 = psds14 + Ix22 * Iy12 * wt
              psds15 = psds15 + Ix22 *        Iz12
              psds16 = psds16 + Ix21 * Iy12 * Iz12
              psds21 = psds21 + Ix13 * Iy21 * wt
              psds22 = psds22 +        Iy23 * wt
              psds23 = psds23 +        Iy21 * Iz13
              psds24 = psds24 + Ix12 * Iy22 * wt
              psds25 = psds25 + Ix12 * Iy21 * Iz12
              psds26 = psds26 +        Iy22 * Iz12
              psds31 = psds31 + Ix13 *        Iz21
              psds32 = psds32 +        Iy13 * Iz21
              psds33 = psds33 +               Iz23
              psds34 = psds34 + Ix12 * Iy12 * Iz21
              psds35 = psds35 + Ix12 *        Iz22
              psds36 = psds36 +        Iy12 * Iz22
            end
          end
        end
      end
    end
    rys1.destroy
    norm1 = .cd_normalising_factors(1)
    norm2 = .cd_normalising_factors(2)
    norm3 = .cd_normalising_factors(3)
    norm4 = .cd_normalising_factors(4)
    norm5 = .cd_normalising_factors(5)
    norm6 = .cd_normalising_factors(6)
    psds(1,1) = psds11 * norm1
    psds(1,2) = psds12 * norm2
    psds(1,3) = psds13 * norm3
    psds(1,4) = psds14 * norm4
    psds(1,5) = psds15 * norm5
    psds(1,6) = psds16 * norm6
    psds(2,1) = psds21 * norm1
    psds(2,2) = psds22 * norm2
    psds(2,3) = psds23 * norm3
    psds(2,4) = psds24 * norm4
    psds(2,5) = psds25 * norm5
    psds(2,6) = psds26 * norm6
    psds(3,1) = psds31 * norm1
    psds(3,2) = psds32 * norm2
    psds(3,3) = psds33 * norm3
    psds(3,4) = psds34 * norm4
    psds(3,5) = psds35 * norm5
    psds(3,6) = psds36 * norm6
  end

  make_dsps(abcd) ::: private
  ! Makes the (ds|ps) integrals, summed over primitives.
    self :: IN
    abcd :: REALMAT4, OUT
    dsps :: REALMAT(3,3)
    if (.ab_n_gaussian_pairs > n_cc_cutoff) then
      .make_dsps(dsps)
    else
      .make_dsps_low_ncc(dsps)
    end
    if (.a.l == 2) then
      if (.c.l == 1) then
        abcd(:,1,:,1) = dsps ! dsps
      else
        abcd(:,1,1,:) = dsps ! dssp
      end
    else
      if (.c.l == 1) then
        abcd(1,:,:,1) = dsps ! sdps
      else
        abcd(1,:,1,:) = dsps ! sdsp
      end
    end
  end

  make_dsps(dsps) ::: private
  ! Makes the initial (es|ps) integrals, summed over the primitives
    self :: IN
    dsps :: REALMAT, OUT
    rys1 :: RYS*
    zeta,eta,xx,normab,zinv,rho,einv,rho_zinv,rho_einv :: REAL
    QPx,QPy,QPz,PAx,PAy,PAz,Qx,Qy,Qz,QCx,QCy,QCz,Px,Py,Pz :: REAL
    ce,bb,wt,t2,t2_rz,t2_re,half_zinv :: REAL
    Ix12,Iy12,Iz12,Ix21,Iy21,Iz21,Ix22,Iy22,Iz22 :: REAL
    Ix31,Iy31,Iz31,Ix32,Iy32,Iz32 :: REAL
    dsps11,dsps21,dsps31,dsps41,dsps51,dsps61 :: REAL
    dsps12,dsps22,dsps32,dsps42,dsps52,dsps62 :: REAL
    dsps13,dsps23,dsps33,dsps43,dsps53,dsps63 :: REAL
    norm1,norm2,norm3,norm4,norm5,norm6 :: REAL
    ag,bg,cg,dg,n,j,k :: INT

    rys1.create(2)

    dsps11 = ZERO; dsps21 = ZERO; dsps31 = ZERO
    dsps41 = ZERO; dsps51 = ZERO; dsps61 = ZERO
    dsps12 = ZERO; dsps22 = ZERO; dsps32 = ZERO
    dsps42 = ZERO; dsps52 = ZERO; dsps62 = ZERO
    dsps13 = ZERO; dsps23 = ZERO; dsps33 = ZERO
    dsps43 = ZERO; dsps53 = ZERO; dsps63 = ZERO

    k = 0
    do bg = 1, .b.n_cc
      do ag = 1, .a.n_cc
        k = k + 1
        zeta = .ab_exponent_sum(k)
        zinv = ONE/zeta
        half_zinv = HALF * zinv
        normab = .ab_cc_prefactor(k) * TWOPI5ON2
        Px = .ab_pair_center(1,k)
        Py = .ab_pair_center(2,k)
        Pz = .ab_pair_center(3,k)
        PAx = .ab_center_diff(1,k)
        PAy = .ab_center_diff(2,k)
        PAz = .ab_center_diff(3,k)
        j = 0
        do dg = 1, .d.n_cc
          do cg = 1, .c.n_cc
            j = j + 1
            eta  = .cd_exponent_sum(j)
            einv = ONE/eta
            Qx = .cd_pair_center(1,j)
            Qy = .cd_pair_center(2,j)
            Qz = .cd_pair_center(3,j)
            QCx = .cd_center_diff(1,j)
            QCy = .cd_center_diff(2,j)
            QCz = .cd_center_diff(3,j)
            rho  = zeta * eta / (zeta + eta)
            rho_zinv = rho * zinv
            rho_einv = rho * einv
            QPx  = Qx - Px;   QPy  = Qy - Py;   QPz  = Qz - Pz
            xx   = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
            rys1.get_weights(xx)
            rys1.w(:) = rys1.w(:) * normab * .cd_cc_prefactor(j) * sqrt(rho)

            ! Now make the 2 dimensional integrals.
            do n=1,2
              wt=rys1.w(n)
              t2    = rys1.r(n)
              t2_rz = t2 * rho_zinv
              t2_re = t2 * rho_einv
              bb    = t2_re * half_zinv
              ce    = (ONE - t2_rz) * half_zinv
              Ix12 = QCx - t2_re * QPx
              Iy12 = QCy - t2_re * QPy
              Iz12 = QCz - t2_re * QPz
              Ix21 = PAx + t2_rz * QPx
              Iy21 = PAy + t2_rz * QPy
              Iz21 = PAz + t2_rz * QPz
              Ix22 = Ix12 * Ix21 + bb
              Iy22 = Iy12 * Iy21 + bb
              Iz22 = Iz12 * Iz21 + bb
              Ix31 = Ix21 * Ix21 + ce
              Iy31 = Iy21 * Iy21 + ce
              Iz31 = (Iz21 * Iz21 + ce)*wt
              Iz21 = Iz21 * wt
              Iz12 = Iz12 * wt
              Ix32 = Ix21 * (Ix22 + bb) + ce * Ix12
              Iy32 = Iy21 * (Iy22 + bb) + ce * Iy12
              Iz32 = Iz21 * (Iz22 + bb) + ce * Iz12 ! this includes wt
              Iz22 = Iz22 * wt

              dsps11 = dsps11 + Ix32 *        wt
              dsps21 = dsps21 + Ix12 * Iy31 * wt
              dsps31 = dsps31 + Ix12 *        Iz31
              dsps41 = dsps41 + Ix22 * Iy21 * wt
              dsps51 = dsps51 + Ix22 *        Iz21
              dsps61 = dsps61 + Ix12 * Iy21 * Iz21
              dsps12 = dsps12 + Ix31 * Iy12 * wt
              dsps22 = dsps22 +        Iy32 * wt
              dsps32 = dsps32 +        Iy12 * Iz31
              dsps42 = dsps42 + Ix21 * Iy22 * wt
              dsps52 = dsps52 + Ix21 * Iy12 * Iz21
              dsps62 = dsps62 +        Iy22 * Iz21
              dsps13 = dsps13 + Ix31 *        Iz12
              dsps23 = dsps23 +        Iy31 * Iz12
              dsps33 = dsps33 +               Iz32
              dsps43 = dsps43 + Ix21 * Iy21 * Iz12
              dsps53 = dsps53 + Ix21 *        Iz22
              dsps63 = dsps63 +        Iy21 * Iz22
            end
          end
        end
      end
    end
    rys1.destroy

    norm1 = .ab_normalising_factors(1)
    norm2 = .ab_normalising_factors(2)
    norm3 = .ab_normalising_factors(3)
    norm4 = .ab_normalising_factors(4)
    norm5 = .ab_normalising_factors(5)
    norm6 = .ab_normalising_factors(6)
    dsps(1,1) = dsps11 * norm1
    dsps(2,1) = dsps21 * norm2
    dsps(3,1) = dsps31 * norm3
    dsps(4,1) = dsps41 * norm4
    dsps(5,1) = dsps51 * norm5
    dsps(6,1) = dsps61 * norm6
    dsps(1,2) = dsps12 * norm1
    dsps(2,2) = dsps22 * norm2
    dsps(3,2) = dsps32 * norm3
    dsps(4,2) = dsps42 * norm4
    dsps(5,2) = dsps52 * norm5
    dsps(6,2) = dsps62 * norm6
    dsps(1,3) = dsps13 * norm1
    dsps(2,3) = dsps23 * norm2
    dsps(3,3) = dsps33 * norm3
    dsps(4,3) = dsps43 * norm4
    dsps(5,3) = dsps53 * norm5
    dsps(6,3) = dsps63 * norm6
  end

  make_dsps_low_ncc(dsps) ::: private
  ! Makes the initial (es|ps) integrals, summed over the primitives
    self :: IN
    dsps :: REALMAT, OUT
    rys1 :: RYS*
    zeta,eta,xx,normab,zinv,rho,einv,rho_zinv,rho_einv :: REAL
    QPx,QPy,QPz,PAx,PAy,PAz,Qx,Qy,Qz,QCx,QCy,QCz,Px,Py,Pz :: REAL
    ce,bb,wt,t2,t2_rz,t2_re,half_zinv :: REAL
    Ix12,Iy12,Iz12,Ix21,Iy21,Iz21,Ix22,Iy22,Iz22 :: REAL
    Ix31,Iy31,Iz31,Ix32,Iy32,Iz32 :: REAL
    dsps11,dsps21,dsps31,dsps41,dsps51,dsps61 :: REAL
    dsps12,dsps22,dsps32,dsps42,dsps52,dsps62 :: REAL
    dsps13,dsps23,dsps33,dsps43,dsps53,dsps63 :: REAL
    norm1,norm2,norm3,norm4,norm5,norm6 :: REAL
    Dx,Dy,Dz,Cx,Cy,Cz,Ctx,Cty,Ctz :: REAL
    d,d_cc,d_r2cd,c :: REAL
    ag,bg,cg,dg,n,k :: INT

    rys1.create(2)

    dsps11 = ZERO; dsps21 = ZERO; dsps31 = ZERO
    dsps41 = ZERO; dsps51 = ZERO; dsps61 = ZERO
    dsps12 = ZERO; dsps22 = ZERO; dsps32 = ZERO
    dsps42 = ZERO; dsps52 = ZERO; dsps62 = ZERO
    dsps13 = ZERO; dsps23 = ZERO; dsps33 = ZERO
    dsps43 = ZERO; dsps53 = ZERO; dsps63 = ZERO

    Cx = .pos_c(1);  Dx = .pos_d(1)
    Cy = .pos_c(2);  Dy = .pos_d(2)
    Cz = .pos_c(3);  Dz = .pos_d(3)
    if (.c.l > .d.l) then
      Ctx = Cx;  Cty = Cy;  Ctz = Cz
    else
      Ctx = Dx;  Cty = Dy;  Ctz = Dz
    end
    k = 0
    do bg = 1, .b.n_cc
      do ag = 1, .a.n_cc
        k = k + 1
        zeta = .ab_exponent_sum(k)
        zinv = ONE/zeta
        half_zinv = HALF * zinv
        normab = .ab_cc_prefactor(k) * TWOPI5ON2
        Px = .ab_pair_center(1,k)
        Py = .ab_pair_center(2,k)
        Pz = .ab_pair_center(3,k)
        PAx = .ab_center_diff(1,k)
        PAy = .ab_center_diff(2,k)
        PAz = .ab_center_diff(3,k)
        do dg = 1, .d.n_cc
          d      = .d.ex(dg)
          d_cc   = .d.cc(dg)
          d_r2cd = d * .r2cd
          do cg = 1, .c.n_cc
            c    = .c.ex(cg)
            eta  = c + d
            einv = ONE/eta
            Qx = (d*Dx + c*Cx) * einv
            Qy = (d*Dy + c*Cy) * einv
            Qz = (d*Dz + c*Cz) * einv
            QCx = Qx - Ctx
            QCy = Qy - Cty
            QCz = Qz - Ctz
            rho  = zeta * eta / (zeta + eta)
            rho_zinv = rho * zinv
            rho_einv = rho * einv
            QPx  = Qx - Px;   QPy  = Qy - Py;   QPz  = Qz - Pz
            xx   = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
            rys1.get_weights(xx)
            rys1.w(:) = rys1.w(:) * (normab * d_cc * .c.cc(cg) * &
                           einv * sqrt(rho_einv) * exp(-c*d_r2cd*einv))

            ! Now make the 2 dimensional integrals.
            do n=1,2
              wt=rys1.w(n)
              t2    = rys1.r(n)
              t2_rz = t2 * rho_zinv
              t2_re = t2 * rho_einv
              bb    = t2_re * half_zinv
              ce    = (ONE - t2_rz) * half_zinv
              Ix12 = QCx - t2_re * QPx
              Iy12 = QCy - t2_re * QPy
              Iz12 = QCz - t2_re * QPz
              Ix21 = PAx + t2_rz * QPx
              Iy21 = PAy + t2_rz * QPy
              Iz21 = PAz + t2_rz * QPz
              Ix22 = Ix12 * Ix21 + bb
              Iy22 = Iy12 * Iy21 + bb
              Iz22 = Iz12 * Iz21 + bb
              Ix31 = Ix21 * Ix21 + ce
              Iy31 = Iy21 * Iy21 + ce
              Iz31 = (Iz21 * Iz21 + ce)*wt
              Iz21 = Iz21 * wt
              Iz12 = Iz12 * wt
              Ix32 = Ix21 * (Ix22 + bb) + ce * Ix12
              Iy32 = Iy21 * (Iy22 + bb) + ce * Iy12
              Iz32 = Iz21 * (Iz22 + bb) + ce * Iz12 ! this includes wt
              Iz22 = Iz22 * wt

              dsps11 = dsps11 + Ix32 *        wt
              dsps21 = dsps21 + Ix12 * Iy31 * wt
              dsps31 = dsps31 + Ix12 *        Iz31
              dsps41 = dsps41 + Ix22 * Iy21 * wt
              dsps51 = dsps51 + Ix22 *        Iz21
              dsps61 = dsps61 + Ix12 * Iy21 * Iz21
              dsps12 = dsps12 + Ix31 * Iy12 * wt
              dsps22 = dsps22 +        Iy32 * wt
              dsps32 = dsps32 +        Iy12 * Iz31
              dsps42 = dsps42 + Ix21 * Iy22 * wt
              dsps52 = dsps52 + Ix21 * Iy12 * Iz21
              dsps62 = dsps62 +        Iy22 * Iz21
              dsps13 = dsps13 + Ix31 *        Iz12
              dsps23 = dsps23 +        Iy31 * Iz12
              dsps33 = dsps33 +               Iz32
              dsps43 = dsps43 + Ix21 * Iy21 * Iz12
              dsps53 = dsps53 + Ix21 *        Iz22
              dsps63 = dsps63 +        Iy21 * Iz22
            end
          end
        end
      end
    end
    rys1.destroy

    norm1 = .ab_normalising_factors(1)
    norm2 = .ab_normalising_factors(2)
    norm3 = .ab_normalising_factors(3)
    norm4 = .ab_normalising_factors(4)
    norm5 = .ab_normalising_factors(5)
    norm6 = .ab_normalising_factors(6)
    dsps(1,1) = dsps11 * norm1
    dsps(2,1) = dsps21 * norm2
    dsps(3,1) = dsps31 * norm3
    dsps(4,1) = dsps41 * norm4
    dsps(5,1) = dsps51 * norm5
    dsps(6,1) = dsps61 * norm6
    dsps(1,2) = dsps12 * norm1
    dsps(2,2) = dsps22 * norm2
    dsps(3,2) = dsps32 * norm3
    dsps(4,2) = dsps42 * norm4
    dsps(5,2) = dsps52 * norm5
    dsps(6,2) = dsps62 * norm6
    dsps(1,3) = dsps13 * norm1
    dsps(2,3) = dsps23 * norm2
    dsps(3,3) = dsps33 * norm3
    dsps(4,3) = dsps43 * norm4
    dsps(5,3) = dsps53 * norm5
    dsps(6,3) = dsps63 * norm6
  end

  make_dsss(dsss) ::: private
  ! Makes the initial (es|ps) integrals, summed over the primitives
    self :: IN
    dsss :: REALVEC, OUT
    rys1 :: RYS*
    zeta,eta,xx,normab,zinv,rho,rho_zinv :: REAL
    QPx,QPy,QPz,PAx,PAy,PAz,Qx,Qy,Qz,Px,Py,Pz :: REAL
    ce,wt,t2,t2_rz,half_zinv :: REAL
    Ix2,Iy2,Iz2 :: REAL
    dsss1,dsss2,dsss3,dsss4,dsss5,dsss6 :: REAL
    ag,bg,cg,dg,n,j,k :: INT

    rys1.create(2)

    dsss1 = ZERO; dsss2 = ZERO; dsss3 = ZERO
    dsss4 = ZERO; dsss5 = ZERO; dsss6 = ZERO

    k = 0
    do bg = 1, .b.n_cc
      do ag = 1, .a.n_cc
        k = k + 1
        zeta = .ab_exponent_sum(k)
        zinv = ONE/zeta
        half_zinv = HALF * zinv
        normab = .ab_cc_prefactor(k) * TWOPI5ON2
        Px = .ab_pair_center(1,k)
        Py = .ab_pair_center(2,k)
        Pz = .ab_pair_center(3,k)
        PAx = .ab_center_diff(1,k)
        PAy = .ab_center_diff(2,k)
        PAz = .ab_center_diff(3,k)
        j = 0
        do dg = 1, .d.n_cc
          do cg = 1, .c.n_cc
            j = j + 1
            eta  = .cd_exponent_sum(j)
            Qx = .cd_pair_center(1,j)
            Qy = .cd_pair_center(2,j)
            Qz = .cd_pair_center(3,j)
            rho  = zeta * eta / (zeta + eta)
            rho_zinv = rho * zinv
            QPx  = Qx - Px;   QPy  = Qy - Py;   QPz  = Qz - Pz
            xx   = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
            rys1.get_weights(xx)
            rys1.w(:) = rys1.w(:) * normab * .cd_cc_prefactor(j) * sqrt(rho)
            do n=1,2
              wt=rys1.w(n)
              t2    = rys1.r(n)
              t2_rz = t2 * rho_zinv
              ce    = (ONE - t2_rz) * half_zinv
              Ix2   = PAx + t2_rz * QPx
              Iy2   = PAy + t2_rz * QPy
              Iz2   = PAz + t2_rz * QPz
              dsss1 = dsss1 + (Ix2 * Ix2 + ce)*wt
              dsss2 = dsss2 + (Iy2 * Iy2 + ce)*wt
              dsss3 = dsss3 + (Iz2 * Iz2 + ce)*wt
              Iz2   = Iz2 * wt
              dsss4 = dsss4 + Ix2 * Iy2 * wt
              dsss5 = dsss5 + Ix2 * Iz2
              dsss6 = dsss6 + Iy2 * Iz2
            end
          end
        end
      end
    end
    rys1.destroy
    dsss(1) = dsss1 * .ab_normalising_factors(1)
    dsss(2) = dsss2 * .ab_normalising_factors(2)
    dsss(3) = dsss3 * .ab_normalising_factors(3)
    dsss(4) = dsss4 * .ab_normalising_factors(4)
    dsss(5) = dsss5 * .ab_normalising_factors(5)
    dsss(6) = dsss6 * .ab_normalising_factors(6)
  end

  make_dsss_low_ncc(dsss) ::: private
  ! Makes the initial (es|ps) integrals, summed over the primitives
    self :: IN
    dsss :: REALVEC, OUT
    rys1 :: RYS*
    zeta,eta,xx,normab,zinv,rho,einv,rho_zinv,rho_einv :: REAL
    QPx,QPy,QPz,PAx,PAy,PAz,Qx,Qy,Qz,Px,Py,Pz :: REAL
    ce,wt,t2,t2_rz,half_zinv :: REAL
    Ix2,Iy2,Iz2 :: REAL
    Dx,Dy,Dz,Cx,Cy,Cz :: REAL
    d,d_cc,d_r2cd,c :: REAL
    dsss1,dsss2,dsss3,dsss4,dsss5,dsss6 :: REAL
    ag,bg,cg,dg,n,k :: INT

    rys1.create(2)

    dsss1 = ZERO; dsss2 = ZERO; dsss3 = ZERO
    dsss4 = ZERO; dsss5 = ZERO; dsss6 = ZERO
    Cx = .pos_c(1);  Dx = .pos_d(1)
    Cy = .pos_c(2);  Dy = .pos_d(2)
    Cz = .pos_c(3);  Dz = .pos_d(3)

    k = 0
    do bg = 1, .b.n_cc
      do ag = 1, .a.n_cc
        k = k + 1
        zeta = .ab_exponent_sum(k)
        zinv = ONE/zeta
        half_zinv = HALF * zinv
        normab = .ab_cc_prefactor(k) * TWOPI5ON2
        Px = .ab_pair_center(1,k)
        Py = .ab_pair_center(2,k)
        Pz = .ab_pair_center(3,k)
        PAx = .ab_center_diff(1,k)
        PAy = .ab_center_diff(2,k)
        PAz = .ab_center_diff(3,k)
        do dg = 1, .d.n_cc
          d      = .d.ex(dg)
          d_cc   = .d.cc(dg)
          d_r2cd = d * .r2cd
          do cg = 1, .c.n_cc
            c    = .c.ex(cg)
            eta  = c + d
            einv = ONE/eta
            Qx = (d*Dx + c*Cx) * einv
            Qy = (d*Dy + c*Cy) * einv
            Qz = (d*Dz + c*Cz) * einv
            rho  = zeta * eta / (zeta + eta)
            rho_zinv = rho * zinv
            rho_einv = rho * einv
            QPx  = Qx - Px;   QPy  = Qy - Py;   QPz  = Qz - Pz
            xx   = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
            rys1.get_weights(xx)
            rys1.w(:) = rys1.w(:) * (normab * d_cc * .c.cc(cg) * &
                           einv * sqrt(rho_einv) * exp(-c*d_r2cd*einv))
            do n=1,2
              wt=rys1.w(n)
              t2    = rys1.r(n)
              t2_rz = t2 * rho_zinv
              ce    = (ONE - t2_rz) * half_zinv
              Ix2   = PAx + t2_rz * QPx
              Iy2   = PAy + t2_rz * QPy
              Iz2   = PAz + t2_rz * QPz
              dsss1 = dsss1 + (Ix2 * Ix2 + ce)*wt
              dsss2 = dsss2 + (Iy2 * Iy2 + ce)*wt
              dsss3 = dsss3 + (Iz2 * Iz2 + ce)*wt
              Iz2   = Iz2 * wt
              dsss4 = dsss4 + Ix2 * Iy2 * wt
              dsss5 = dsss5 + Ix2 * Iz2
              dsss6 = dsss6 + Iy2 * Iz2
            end
          end
        end
      end
    end
    rys1.destroy
    dsss(1) = dsss1 * .ab_normalising_factors(1)
    dsss(2) = dsss2 * .ab_normalising_factors(2)
    dsss(3) = dsss3 * .ab_normalising_factors(3)
    dsss(4) = dsss4 * .ab_normalising_factors(4)
    dsss(5) = dsss5 * .ab_normalising_factors(5)
    dsss(6) = dsss6 * .ab_normalising_factors(6)
  end

  make_ssds(ssds) ::: private
  ! Makes the initial (ps|fs) integrals, summed over the primitives
    self :: IN
    ssds :: REALVEC, OUT
    rys1 :: RYS*
    zeta,eta,xx,normab,zinv,rho,einv,rho_einv :: REAL
    QPx,QPy,QPz,Qx,Qy,Qz,QCx,QCy,QCz,Px,Py,Pz :: REAL
    cf,wt :: REAL
    Ix2,Iy2,Iz2 :: REAL
    ssds1,ssds2,ssds3,ssds4,ssds5,ssds6 :: REAL
    t2,t2_re,half_einv :: REAL
    ag,bg,cg,dg,n,j,k :: INT

    rys1.create(2)
    ssds1 = ZERO; ssds2 = ZERO; ssds3 = ZERO
    ssds4 = ZERO; ssds5 = ZERO; ssds6 = ZERO

    k = 0
    do bg = 1, .b.n_cc
      do ag = 1, .a.n_cc
        k = k + 1
        zeta = .ab_exponent_sum(k)
        zinv = ONE/zeta
        normab = .ab_cc_prefactor(k) * TWOPI5ON2
        Px = .ab_pair_center(1,k)
        Py = .ab_pair_center(2,k)
        Pz = .ab_pair_center(3,k)
        j = 0
        do dg = 1, .d.n_cc
          do cg = 1, .c.n_cc
            j = j + 1
            eta  = .cd_exponent_sum(j)
            einv = ONE/eta
            Qx = .cd_pair_center(1,j)
            Qy = .cd_pair_center(2,j)
            Qz = .cd_pair_center(3,j)
            QCx = .cd_center_diff(1,j)
            QCy = .cd_center_diff(2,j)
            QCz = .cd_center_diff(3,j)
            rho  = zeta * eta / (zeta + eta)
            rho_einv = rho * einv
            half_einv = HALF * einv
            QPx  = Qx - Px;   QPy  = Qy - Py;   QPz  = Qz - Pz
            xx   = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
            rys1.get_weights(xx)
            rys1.w(:) = rys1.w(:) * normab * .cd_cc_prefactor(j) * sqrt(rho)

            ! Now make the 2 dimensional integrals.
            do n=1,2
              t2    = rys1.r(n)
              wt = rys1.w(n)
              t2_re = t2 * rho_einv
              cf    = (ONE - t2_re) * half_einv
              Ix2   = QCx - t2_re * QPx
              Iy2   = QCy - t2_re * QPy
              Iz2   = QCz - t2_re * QPz
              ssds1 = ssds1 + (Ix2*Ix2 + cf)*wt
              ssds2 = ssds2 + (Iy2*Iy2 + cf)*wt
              ssds3 = ssds3 + (Iz2*Iz2 + cf)*wt
              Iz2   = Iz2 * wt
              ssds4 = ssds4 + Ix2 * Iy2 * wt
              ssds5 = ssds5 + Ix2 * Iz2
              ssds6 = ssds6 + Iy2 * Iz2
            end
          end
        end
      end
    end
    rys1.destroy
    ssds(1) = ssds1 * .cd_normalising_factors(1)
    ssds(2) = ssds2 * .cd_normalising_factors(2)
    ssds(3) = ssds3 * .cd_normalising_factors(3)
    ssds(4) = ssds4 * .cd_normalising_factors(4)
    ssds(5) = ssds5 * .cd_normalising_factors(5)
    ssds(6) = ssds6 * .cd_normalising_factors(6)
  end

  make_ssds_low_ncc(ssds) ::: private
  ! Makes the initial (ps|fs) integrals, summed over the primitives
    self :: IN
    ssds :: REALVEC, OUT
    rys1 :: RYS*
    zeta,eta,xx,normab,zinv,rho,einv,rho_einv :: REAL
    QPx,QPy,QPz,Qx,Qy,Qz,QCx,QCy,QCz,Px,Py,Pz :: REAL
    cf,wt :: REAL
    Ix2,Iy2,Iz2 :: REAL
    Dx,Dy,Dz,Cx,Cy,Cz,Ctx,Cty,Ctz :: REAL
    d,d_cc,d_r2cd,c :: REAL
    ssds1,ssds2,ssds3,ssds4,ssds5,ssds6 :: REAL
    t2,t2_re,half_einv :: REAL
    ag,bg,cg,dg,n,k :: INT

    rys1.create(2)
    ssds1 = ZERO; ssds2 = ZERO; ssds3 = ZERO
    ssds4 = ZERO; ssds5 = ZERO; ssds6 = ZERO
    Cx = .pos_c(1);  Dx = .pos_d(1)
    Cy = .pos_c(2);  Dy = .pos_d(2)
    Cz = .pos_c(3);  Dz = .pos_d(3)
    if (.c.l > .d.l) then
      Ctx = Cx;  Cty = Cy;  Ctz = Cz
    else
      Ctx = Dx;  Cty = Dy;  Ctz = Dz
    end

    k = 0
    do bg = 1, .b.n_cc
      do ag = 1, .a.n_cc
        k = k + 1
        zeta = .ab_exponent_sum(k)
        zinv = ONE/zeta
        normab = .ab_cc_prefactor(k) * TWOPI5ON2
        Px = .ab_pair_center(1,k)
        Py = .ab_pair_center(2,k)
        Pz = .ab_pair_center(3,k)
        do dg = 1, .d.n_cc
          d      = .d.ex(dg)
          d_cc   = .d.cc(dg)
          d_r2cd = d * .r2cd
          do cg = 1, .c.n_cc
            c    = .c.ex(cg)
            eta  = c + d
            einv = ONE/eta
            Qx = (d*Dx + c*Cx) * einv
            Qy = (d*Dy + c*Cy) * einv
            Qz = (d*Dz + c*Cz) * einv
            QCx = Qx - Ctx
            QCy = Qy - Cty
            QCz = Qz - Ctz
            rho  = zeta * eta / (zeta + eta)
            rho_einv = rho * einv
            half_einv = HALF * einv
            QPx  = Qx - Px;   QPy  = Qy - Py;   QPz  = Qz - Pz
            xx   = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
            rys1.get_weights(xx)
            rys1.w(:) = rys1.w(:) * (normab * d_cc * .c.cc(cg) * &
                           einv * sqrt(rho_einv) * exp(-c*d_r2cd*einv))
            do n=1,2
              t2    = rys1.r(n)
              wt = rys1.w(n)
              t2_re = t2 * rho_einv
              cf    = (ONE - t2_re) * half_einv
              Ix2   = QCx - t2_re * QPx
              Iy2   = QCy - t2_re * QPy
              Iz2   = QCz - t2_re * QPz
              ssds1 = ssds1 + (Ix2*Ix2 + cf)*wt
              ssds2 = ssds2 + (Iy2*Iy2 + cf)*wt
              ssds3 = ssds3 + (Iz2*Iz2 + cf)*wt
              Iz2   = Iz2 * wt
              ssds4 = ssds4 + Ix2 * Iy2 * wt
              ssds5 = ssds5 + Ix2 * Iz2
              ssds6 = ssds6 + Iy2 * Iz2
            end
          end
        end
      end
    end
    rys1.destroy
    ssds(1) = ssds1 * .cd_normalising_factors(1)
    ssds(2) = ssds2 * .cd_normalising_factors(2)
    ssds(3) = ssds3 * .cd_normalising_factors(3)
    ssds(4) = ssds4 * .cd_normalising_factors(4)
    ssds(5) = ssds5 * .cd_normalising_factors(5)
    ssds(6) = ssds6 * .cd_normalising_factors(6)
  end

  make_pppp(abcd) ::: private
  ! Make the (pp|pp) integrals, summed over primitives.
    self :: IN
    abcd :: REALMAT4, target
    if (.ab_n_gaussian_pairs > n_cc_cutoff) then
      .make_pppp_1(abcd)
    else
      .make_pppp_low_ncc(abcd)
    end
  end

  make_pppp_1(abcd) ::: private
  ! Make the (pp|pp) integrals, summed over primitives.
    self :: IN
    abcd :: REALMAT4, target
    Iab :: REALMAT*
    rys1 :: RYS*
    zeta,eta,xx,normab,zinv,rho,einv,rho_zinv,rho_einv :: REAL
    QPx,QPy,QPz,PAx,PAy,PAz,Qx,Qy,Qz,QCx,QCy,QCz,Px,Py,Pz :: REAL
    BAx,BAy,BAz,DCx,DCy,DCz :: REAL
    ce,cf,bb,bb_2,t2,t2_rz,t2_re,w,half_zinv,half_einv :: REAL
    Ix12,Ix13,Ix21,Ix22,Ix23,Ix31,Ix32,Ix33 :: REAL
    Iy12,Iy13,Iy21,Iy22,Iy23,Iy31,Iy32,Iy33 :: REAL
    Iz12,Iz21,Iz22,Iz23 :: REAL
    Iz13_w,Iz31_w,Iz21_w,Iz22_w,Iz12_w,Iz32_w,Iz23_w,Iz33_w :: REAL
    px__px_,py__px_,pz__px_ :: REAL
    px__py_,py__py_,pz__py_ :: REAL
    px__pz_,py__pz_,pz__pz_ :: REAL
    px__dxx,py__dxx,pz__dxx :: REAL
    px__dyy,py__dyy,pz__dyy :: REAL
    px__dzz,py__dzz,pz__dzz :: REAL
    px__dxy,py__dxy,pz__dxy :: REAL
    px__dxz,py__dxz,pz__dxz :: REAL
    px__dyz,py__dyz,pz__dyz :: REAL
    dxx_px_,dyy_px_,dzz_px_,dxy_px_,dxz_px_,dyz_px_ :: REAL
    dxx_py_,dyy_py_,dzz_py_,dxy_py_,dxz_py_,dyz_py_ :: REAL
    dxx_pz_,dyy_pz_,dzz_pz_,dxy_pz_,dxz_pz_,dyz_pz_ :: REAL
    dxx_dxx,dyy_dxx,dzz_dxx,dxy_dxx,dxz_dxx,dyz_dxx :: REAL
    dxx_dyy,dyy_dyy,dzz_dyy,dxy_dyy,dxz_dyy,dyz_dyy :: REAL
    dxx_dzz,dyy_dzz,dzz_dzz,dxy_dzz,dxz_dzz,dyz_dzz :: REAL
    dxx_dxy,dyy_dxy,dzz_dxy,dxy_dxy,dxz_dxy,dyz_dxy :: REAL
    dxx_dxz,dyy_dxz,dzz_dxz,dxy_dxz,dxz_dxz,dyz_dxz :: REAL
    dxx_dyz,dyy_dyz,dzz_dyz,dxy_dyz,dxz_dyz,dyz_dyz :: REAL
    Iy12_Iz21,Iy12_Iz12,Iy13_Iz21,Iy21_Iz21,Iy21_Iz22 :: REAL
    Iy21_Iz12,Iy31_Iz12,Iy21_Iz13,Iy12_Iz31,Iy12_Iz22 :: REAL
    Iy22_Iz12,Iy22_Iz21 :: REAL
    Ix22_bb,Iy22_bb,Iz22_bb :: REAL
    Iy12_w, Iy21_w, Iy22_w, Iy13_w, Iy31_w, Iy32_w, Iy23_w :: REAL
    px_,py_,pz_,dxx_,dyy_,dzz_,dxy_,dxz_,dyz_ :: REAL
    ag,bg,cg,dg,n,j,k :: INT

    px__px_ = ZERO; py__px_ = ZERO; pz__px_ = ZERO
    dxx_px_ = ZERO; dyy_px_ = ZERO; dzz_px_ = ZERO
    dxy_px_ = ZERO; dxz_px_ = ZERO; dyz_px_ = ZERO
    px__py_ = ZERO; py__py_ = ZERO; pz__py_ = ZERO
    dxx_py_ = ZERO; dyy_py_ = ZERO; dzz_py_ = ZERO
    dxy_py_ = ZERO; dxz_py_ = ZERO; dyz_py_ = ZERO
    px__pz_ = ZERO; py__pz_ = ZERO; pz__pz_ = ZERO
    dxx_pz_ = ZERO; dyy_pz_ = ZERO; dzz_pz_ = ZERO
    dxy_pz_ = ZERO; dxz_pz_ = ZERO; dyz_pz_ = ZERO
    px__dxx = ZERO; py__dxx = ZERO; pz__dxx = ZERO
    dxx_dxx = ZERO; dyy_dxx = ZERO; dzz_dxx = ZERO
    dxy_dxx = ZERO; dxz_dxx = ZERO; dyz_dxx = ZERO
    px__dyy = ZERO; py__dyy = ZERO; pz__dyy = ZERO
    dxx_dyy = ZERO; dyy_dyy = ZERO; dzz_dyy = ZERO
    dxy_dyy = ZERO; dxz_dyy = ZERO; dyz_dyy = ZERO
    px__dzz = ZERO; py__dzz = ZERO; pz__dzz = ZERO
    dxx_dzz = ZERO; dyy_dzz = ZERO; dzz_dzz = ZERO
    dxy_dzz = ZERO; dxz_dzz = ZERO; dyz_dzz = ZERO
    px__dxy = ZERO; py__dxy = ZERO; pz__dxy = ZERO
    dxx_dxy = ZERO; dyy_dxy = ZERO; dzz_dxy = ZERO
    dxy_dxy = ZERO; dxz_dxy = ZERO; dyz_dxy = ZERO
    px__dxz = ZERO; py__dxz = ZERO; pz__dxz = ZERO
    dxx_dxz = ZERO; dyy_dxz = ZERO; dzz_dxz = ZERO
    dxy_dxz = ZERO; dxz_dxz = ZERO; dyz_dxz = ZERO
    px__dyz = ZERO; py__dyz = ZERO; pz__dyz = ZERO
    dxx_dyz = ZERO; dyy_dyz = ZERO; dzz_dyz = ZERO
    dxy_dyy = ZERO; dxz_dyy = ZERO; dyz_dyy = ZERO
    dxy_dyz = ZERO; dxz_dyz = ZERO; dyz_dyz = ZERO

    rys1.create(3)
    k = 0
    do bg = 1, .b.n_cc
      do ag = 1, .a.n_cc
        k = k + 1
        zeta = .ab_exponent_sum(k)
        zinv = ONE/zeta
        half_zinv = HALF * zinv
        normab = .ab_cc_prefactor(k) * TWOPI5ON2
        Px = .ab_pair_center(1,k)
        Py = .ab_pair_center(2,k)
        Pz = .ab_pair_center(3,k)
        PAx = .ab_center_diff(1,k)
        PAy = .ab_center_diff(2,k)
        PAz = .ab_center_diff(3,k)
        j = 0
        do dg = 1, .d.n_cc
          do cg = 1, .c.n_cc
            j = j + 1
            eta  = .cd_exponent_sum(j)
            einv = ONE/eta
            Qx = .cd_pair_center(1,j)
            Qy = .cd_pair_center(2,j)
            Qz = .cd_pair_center(3,j)
            QCx = .cd_center_diff(1,j)
            QCy = .cd_center_diff(2,j)
            QCz = .cd_center_diff(3,j)
            rho  = zeta * eta / (zeta + eta)
            rho_zinv = rho * zinv
            rho_einv = rho * einv
            QPx  = Qx - Px;   QPy  = Qy - Py;   QPz  = Qz - Pz
            xx   = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
            rys1.get_weights(xx)
            rys1.w = rys1.w * normab * .cd_cc_prefactor(j) * sqrt(rho)
            half_einv = HALF * einv
            do n=1,3
              t2    = rys1.r(n)
              w     = rys1.w(n)
              t2_rz = t2 * rho_zinv
              t2_re = t2 * rho_einv
              bb    = t2_rz * half_einv
              bb_2  = bb+bb
              cf    = (ONE - t2_re) * half_einv
              ce    = (ONE - t2_rz) * half_zinv
              Ix12 = QCx - t2_re * QPx           ! form 2 dimensional integrals.
              Iy12 = QCy - t2_re * QPy
              Iz12 = QCz - t2_re * QPz
              Ix21 = PAx + t2_rz * QPx
              Iy21 = PAy + t2_rz * QPy
              Iz21 = PAz + t2_rz * QPz
              Ix22 = Ix12 * Ix21 + bb
              Iy22 = Iy12 * Iy21 + bb
              Iz22 = Iz12 * Iz21 + bb
              Ix13 = Ix12 * Ix12 + cf
              Iy13 = Iy12 * Iy12 + cf
              Iz13_w = (Iz12 * Iz12 + cf) * w
              Ix31 = Ix21 * Ix21 + ce
              Iy31 = Iy21 * Iy21 + ce
              Iz31_w = (Iz21 * Iz21 + ce) * w
              Ix22_bb = Ix22 + bb
              Iy22_bb = Iy22 + bb
              Iz22_bb = Iz22 + bb
              Ix23 = Ix12 * Ix22_bb + cf * Ix21
              Iy23 = Iy12 * Iy22_bb + cf * Iy21
              Iz23 = Iz12 * Iz22_bb + cf * Iz21
              Iz21_w = Iz21 * w    ! Merge the weights and reduce multiplications.
              Iz22_w = Iz22 * w
              Iz12_w = Iz12 * w
              Iz23_w = Iz23 * w
              Iy12_w = Iy12 * w
              Iy21_w = Iy21 * w
              Iy22_w = Iy22 * w
              Iy13_w = Iy13 * w
              Iy31_w = Iy31 * w
              Iy23_w = Iy23 * w
              Ix32 = Ix21 * Ix22_bb + ce * Ix12
              Iy32 = Iy21 * Iy22_bb + ce * Iy12
              Iz32_w = Iz21_w * Iz22_bb + ce * Iz12_w
              Ix33 = Ix21 * Ix23 + ce * Ix13 + bb_2 * Ix22
              Iy33 = Iy21 * Iy23 + ce * Iy13 + bb_2 * Iy22
              Iz33_w = Iz21_w * Iz23 + ce * Iz13_w + bb_2 * Iz22_w
              Iy32_w = Iy32 * w

              Iy12_Iz21 = Iy12 * Iz21_w
              Iy12_Iz12 = Iy12 * Iz12_w
              Iy12_Iz22 = Iy12 * Iz22_w
              Iy12_Iz31 = Iy12 * Iz31_w
              Iy13_Iz21 = Iy13 * Iz21_w
              Iy21_Iz21 = Iy21 * Iz21_w
              Iy21_Iz22 = Iy21 * Iz22_w
              Iy21_Iz12 = Iy21 * Iz12_w
              Iy21_Iz13 = Iy21 * Iz13_w
              Iy31_Iz12 = Iy31 * Iz12_w
              Iy22_Iz12 = Iy22 * Iz12_w
              Iy22_Iz21 = Iy22 * Iz21_w

              px__px_ = px__px_ + Ix22 * w     !  combine 2d ints.
              py__px_ = py__px_ + Ix12 * Iy21_w
              pz__px_ = pz__px_ + Ix12 * Iz21_w
              dxx_px_ = dxx_px_ + Ix32 * w
              dyy_px_ = dyy_px_ + Ix12 * Iy31_w
              dzz_px_ = dzz_px_ + Ix12 * Iz31_w
              dxy_px_ = dxy_px_ + Ix22 * Iy21_w
              dxz_px_ = dxz_px_ + Ix22 * Iz21_w
              dyz_px_ = dyz_px_ + Ix12 * Iy21_Iz21
              px__py_ = px__py_ + Ix21 * Iy12_w
              py__py_ = py__py_ + Iy22_w
              pz__py_ = pz__py_ + Iy12_Iz21
              dxx_py_ = dxx_py_ + Ix31 * Iy12_w
              dyy_py_ = dyy_py_ + Iy32_w
              dzz_py_ = dzz_py_ + Iy12_Iz31
              dxy_py_ = dxy_py_ + Ix21 * Iy22_w
              dxz_py_ = dxz_py_ + Ix21 * Iy12_Iz21
              dyz_py_ = dyz_py_ + Iy22_Iz21
              px__pz_ = px__pz_ + Ix21 * Iz12_w
              py__pz_ = py__pz_ + Iy21_Iz12
              pz__pz_ = pz__pz_ + Iz22_w
              dxx_pz_ = dxx_pz_ + Ix31 * Iz12_w
              dyy_pz_ = dyy_pz_ + Iy31_Iz12
              dzz_pz_ = dzz_pz_ + Iz32_w
              dxy_pz_ = dxy_pz_ + Ix21 * Iy21_Iz12
              dxz_pz_ = dxz_pz_ + Ix21 * Iz22_w
              dyz_pz_ = dyz_pz_ + Iy21_Iz22
              px__dxx = px__dxx + Ix23 * w
              py__dxx = py__dxx + Ix13 * Iy21_w
              pz__dxx = pz__dxx + Ix13 * Iz21_w
              dxx_dxx = dxx_dxx + Ix33 * w
              dyy_dxx = dyy_dxx + Ix13 * Iy31_w
              dzz_dxx = dzz_dxx + Ix13 * Iz31_w
              dxy_dxx = dxy_dxx + Ix23 * Iy21_w
              dxz_dxx = dxz_dxx + Ix23 * Iz21_w
              dyz_dxx = dyz_dxx + Ix13 * Iy21_Iz21
              px__dyy = px__dyy + Ix21 * Iy13_w
              py__dyy = py__dyy + Iy23_w
              pz__dyy = pz__dyy + Iy13_Iz21
              dxx_dyy = dxx_dyy + Ix31 * Iy13_w
              dyy_dyy = dyy_dyy + Iy33 * w
              dzz_dyy = dzz_dyy + Iy13 * Iz31_w
              dxy_dyy = dxy_dyy + Ix21 * Iy23_w
              dxz_dyy = dxz_dyy + Ix21 * Iy13_Iz21
              dyz_dyy = dyz_dyy + Iy23 * Iz21_w
              px__dzz = px__dzz + Ix21 * Iz13_w
              py__dzz = py__dzz + Iy21_Iz13
              pz__dzz = pz__dzz + Iz23_w
              dxx_dzz = dxx_dzz + Ix31 * Iz13_w
              dyy_dzz = dyy_dzz + Iy31 * Iz13_w
              dzz_dzz = dzz_dzz + Iz33_w
              dxy_dzz = dxy_dzz + Ix21 * Iy21_Iz13
              dxz_dzz = dxz_dzz + Ix21 * Iz23_w
              dyz_dzz = dyz_dzz + Iy21 * Iz23_w
              px__dxy = px__dxy + Ix22 * Iy12_w
              py__dxy = py__dxy + Ix12 * Iy22_w
              pz__dxy = pz__dxy + Ix12 * Iy12_Iz21
              dxx_dxy = dxx_dxy + Ix32 * Iy12_w
              dyy_dxy = dyy_dxy + Ix12 * Iy32_w
              dzz_dxy = dzz_dxy + Ix12 * Iy12_Iz31
              dxy_dxy = dxy_dxy + Ix22 * Iy22_w
              dxz_dxy = dxz_dxy + Ix22 * Iy12_Iz21
              dyz_dxy = dyz_dxy + Ix12 * Iy22_Iz21
              px__dxz = px__dxz + Ix22 * Iz12_w
              py__dxz = py__dxz + Ix12 * Iy21_Iz12
              pz__dxz = pz__dxz + Ix12 * Iz22_w
              dxx_dxz = dxx_dxz + Ix32 * Iz12_w
              dyy_dxz = dyy_dxz + Ix12 * Iy31_Iz12
              dzz_dxz = dzz_dxz + Ix12 * Iz32_w
              dxy_dxz = dxy_dxz + Ix22 * Iy21_Iz12
              dxz_dxz = dxz_dxz + Ix22 * Iz22_w
              dyz_dxz = dyz_dxz + Ix12 * Iy21_Iz22
              px__dyz = px__dyz + Ix21 * Iy12_Iz12
              py__dyz = py__dyz + Iy22_Iz12
              pz__dyz = pz__dyz + Iy12_Iz22
              dxx_dyz = dxx_dyz + Ix31 * Iy12_Iz12
              dyy_dyz = dyy_dyz + Iy32 * Iz12_w
              dzz_dyz = dzz_dyz + Iy12 * Iz32_w
              dxy_dyz = dxy_dyz + Ix21 * Iy22_Iz12
              dxz_dyz = dxz_dyz + Ix21 * Iy12_Iz22
              dyz_dyz = dyz_dyz + Iy22 * Iz22_w
            end
          end
        end
      end
    end
    rys1.destroy

    BAx = .pos_b(1) - .pos_a(1)
    BAy = .pos_b(2) - .pos_a(2)
    BAz = .pos_b(3) - .pos_a(3)
    DCx = .pos_d(1) - .pos_c(1)
    DCy = .pos_d(2) - .pos_c(2)
    DCz = .pos_d(3) - .pos_c(3)

    px_  = px__dxx + DCx * px__px_
    py_  = py__dxx + DCx * py__px_
    pz_  = pz__dxx + DCx * pz__px_
    dxx_ = dxx_dxx + DCx * dxx_px_
    dyy_ = dyy_dxx + DCx * dyy_px_
    dzz_ = dzz_dxx + DCx * dzz_px_
    dxy_ = dxy_dxx + DCx * dxy_px_
    dxz_ = dxz_dxx + DCx * dxz_px_
    dyz_ = dyz_dxx + DCx * dyz_px_
    Iab => abcd(:,:,1,1)
    Iab(1,1) = dxx_ + BAx * px_
    Iab(2,1) = dxy_ + BAy * px_
    Iab(3,1) = dxz_ + BAz * px_
    Iab(1,2) = dxy_ + BAx * py_
    Iab(2,2) = dyy_ + BAy * py_
    Iab(3,2) = dyz_ + BAz * py_
    Iab(1,3) = dxz_ + BAx * pz_
    Iab(2,3) = dyz_ + BAy * pz_
    Iab(3,3) = dzz_ + BAz * pz_

    px_  = px__dxy + DCy * px__px_
    py_  = py__dxy + DCy * py__px_
    pz_  = pz__dxy + DCy * pz__px_
    dxx_ = dxx_dxy + DCy * dxx_px_
    dyy_ = dyy_dxy + DCy * dyy_px_
    dzz_ = dzz_dxy + DCy * dzz_px_
    dxy_ = dxy_dxy + DCy * dxy_px_
    dxz_ = dxz_dxy + DCy * dxz_px_
    dyz_ = dyz_dxy + DCy * dyz_px_
    Iab => abcd(:,:,2,1)
    Iab(1,1) = dxx_ + BAx * px_
    Iab(2,1) = dxy_ + BAy * px_
    Iab(3,1) = dxz_ + BAz * px_
    Iab(1,2) = dxy_ + BAx * py_
    Iab(2,2) = dyy_ + BAy * py_
    Iab(3,2) = dyz_ + BAz * py_
    Iab(1,3) = dxz_ + BAx * pz_
    Iab(2,3) = dyz_ + BAy * pz_
    Iab(3,3) = dzz_ + BAz * pz_

    px_  = px__dxz + DCz * px__px_
    py_  = py__dxz + DCz * py__px_
    pz_  = pz__dxz + DCz * pz__px_
    dxx_ = dxx_dxz + DCz * dxx_px_
    dyy_ = dyy_dxz + DCz * dyy_px_
    dzz_ = dzz_dxz + DCz * dzz_px_
    dxy_ = dxy_dxz + DCz * dxy_px_
    dxz_ = dxz_dxz + DCz * dxz_px_
    dyz_ = dyz_dxz + DCz * dyz_px_
    Iab => abcd(:,:,3,1)
    Iab(1,1) = dxx_ + BAx * px_
    Iab(2,1) = dxy_ + BAy * px_
    Iab(3,1) = dxz_ + BAz * px_
    Iab(1,2) = dxy_ + BAx * py_
    Iab(2,2) = dyy_ + BAy * py_
    Iab(3,2) = dyz_ + BAz * py_
    Iab(1,3) = dxz_ + BAx * pz_
    Iab(2,3) = dyz_ + BAy * pz_
    Iab(3,3) = dzz_ + BAz * pz_

    px_  = px__dxy + DCx * px__py_
    py_  = py__dxy + DCx * py__py_
    pz_  = pz__dxy + DCx * pz__py_
    dxx_ = dxx_dxy + DCx * dxx_py_
    dyy_ = dyy_dxy + DCx * dyy_py_
    dzz_ = dzz_dxy + DCx * dzz_py_
    dxy_ = dxy_dxy + DCx * dxy_py_
    dxz_ = dxz_dxy + DCx * dxz_py_
    dyz_ = dyz_dxy + DCx * dyz_py_
    Iab => abcd(:,:,1,2)
    Iab(1,1) = dxx_ + BAx * px_
    Iab(2,1) = dxy_ + BAy * px_
    Iab(3,1) = dxz_ + BAz * px_
    Iab(1,2) = dxy_ + BAx * py_
    Iab(2,2) = dyy_ + BAy * py_
    Iab(3,2) = dyz_ + BAz * py_
    Iab(1,3) = dxz_ + BAx * pz_
    Iab(2,3) = dyz_ + BAy * pz_
    Iab(3,3) = dzz_ + BAz * pz_

    px_  = px__dyy + DCy * px__py_
    py_  = py__dyy + DCy * py__py_
    pz_  = pz__dyy + DCy * pz__py_
    dxx_ = dxx_dyy + DCy * dxx_py_
    dyy_ = dyy_dyy + DCy * dyy_py_
    dzz_ = dzz_dyy + DCy * dzz_py_
    dxy_ = dxy_dyy + DCy * dxy_py_
    dxz_ = dxz_dyy + DCy * dxz_py_
    dyz_ = dyz_dyy + DCy * dyz_py_
    Iab => abcd(:,:,2,2)
    Iab(1,1) = dxx_ + BAx * px_
    Iab(2,1) = dxy_ + BAy * px_
    Iab(3,1) = dxz_ + BAz * px_
    Iab(1,2) = dxy_ + BAx * py_
    Iab(2,2) = dyy_ + BAy * py_
    Iab(3,2) = dyz_ + BAz * py_
    Iab(1,3) = dxz_ + BAx * pz_
    Iab(2,3) = dyz_ + BAy * pz_
    Iab(3,3) = dzz_ + BAz * pz_

    px_  = px__dyz + DCz * px__py_
    py_  = py__dyz + DCz * py__py_
    pz_  = pz__dyz + DCz * pz__py_
    dxx_ = dxx_dyz + DCz * dxx_py_
    dyy_ = dyy_dyz + DCz * dyy_py_
    dzz_ = dzz_dyz + DCz * dzz_py_
    dxy_ = dxy_dyz + DCz * dxy_py_
    dxz_ = dxz_dyz + DCz * dxz_py_
    dyz_ = dyz_dyz + DCz * dyz_py_
    Iab => abcd(:,:,3,2)
    Iab(1,1) = dxx_ + BAx * px_
    Iab(2,1) = dxy_ + BAy * px_
    Iab(3,1) = dxz_ + BAz * px_
    Iab(1,2) = dxy_ + BAx * py_
    Iab(2,2) = dyy_ + BAy * py_
    Iab(3,2) = dyz_ + BAz * py_
    Iab(1,3) = dxz_ + BAx * pz_
    Iab(2,3) = dyz_ + BAy * pz_
    Iab(3,3) = dzz_ + BAz * pz_

    px_  = px__dxz + DCx * px__pz_
    py_  = py__dxz + DCx * py__pz_
    pz_  = pz__dxz + DCx * pz__pz_
    dxx_ = dxx_dxz + DCx * dxx_pz_
    dyy_ = dyy_dxz + DCx * dyy_pz_
    dzz_ = dzz_dxz + DCx * dzz_pz_
    dxy_ = dxy_dxz + DCx * dxy_pz_
    dxz_ = dxz_dxz + DCx * dxz_pz_
    dyz_ = dyz_dxz + DCx * dyz_pz_
    Iab => abcd(:,:,1,3)
    Iab(1,1) = dxx_ + BAx * px_
    Iab(2,1) = dxy_ + BAy * px_
    Iab(3,1) = dxz_ + BAz * px_
    Iab(1,2) = dxy_ + BAx * py_
    Iab(2,2) = dyy_ + BAy * py_
    Iab(3,2) = dyz_ + BAz * py_
    Iab(1,3) = dxz_ + BAx * pz_
    Iab(2,3) = dyz_ + BAy * pz_
    Iab(3,3) = dzz_ + BAz * pz_

    px_  = px__dyz + DCy * px__pz_
    py_  = py__dyz + DCy * py__pz_
    pz_  = pz__dyz + DCy * pz__pz_
    dxx_ = dxx_dyz + DCy * dxx_pz_
    dyy_ = dyy_dyz + DCy * dyy_pz_
    dzz_ = dzz_dyz + DCy * dzz_pz_
    dxy_ = dxy_dyz + DCy * dxy_pz_
    dxz_ = dxz_dyz + DCy * dxz_pz_
    dyz_ = dyz_dyz + DCy * dyz_pz_
    Iab => abcd(:,:,2,3)
    Iab(1,1) = dxx_ + BAx * px_
    Iab(2,1) = dxy_ + BAy * px_
    Iab(3,1) = dxz_ + BAz * px_
    Iab(1,2) = dxy_ + BAx * py_
    Iab(2,2) = dyy_ + BAy * py_
    Iab(3,2) = dyz_ + BAz * py_
    Iab(1,3) = dxz_ + BAx * pz_
    Iab(2,3) = dyz_ + BAy * pz_
    Iab(3,3) = dzz_ + BAz * pz_

    px_  = px__dzz + DCz * px__pz_
    py_  = py__dzz + DCz * py__pz_
    pz_  = pz__dzz + DCz * pz__pz_
    dxx_ = dxx_dzz + DCz * dxx_pz_
    dyy_ = dyy_dzz + DCz * dyy_pz_
    dzz_ = dzz_dzz + DCz * dzz_pz_
    dxy_ = dxy_dzz + DCz * dxy_pz_
    dxz_ = dxz_dzz + DCz * dxz_pz_
    dyz_ = dyz_dzz + DCz * dyz_pz_
    Iab => abcd(:,:,3,3)
    Iab(1,1) = dxx_ + BAx * px_
    Iab(2,1) = dxy_ + BAy * px_
    Iab(3,1) = dxz_ + BAz * px_
    Iab(1,2) = dxy_ + BAx * py_
    Iab(2,2) = dyy_ + BAy * py_
    Iab(3,2) = dyz_ + BAz * py_
    Iab(1,3) = dxz_ + BAx * pz_
    Iab(2,3) = dyz_ + BAy * pz_
    Iab(3,3) = dzz_ + BAz * pz_
  end

  make_pppp_low_ncc(abcd) ::: private
  ! Make the (pp|pp) integrals, summed over primitives.
    self :: IN
    abcd :: REALMAT4, target
    Iab :: REALMAT*
    rys1 :: RYS*
    zeta,eta,xx,normab,zinv,rho,einv,rho_zinv,rho_einv :: REAL
    QPx,QPy,QPz,PAx,PAy,PAz,Qx,Qy,Qz,QCx,QCy,QCz,Px,Py,Pz :: REAL
    BAx,BAy,BAz,DCx,DCy,DCz :: REAL
    ce,cf,bb,bb_2,t2,t2_rz,t2_re,w,half_zinv,half_einv :: REAL
    Ix12,Ix13,Ix21,Ix22,Ix23,Ix31,Ix32,Ix33 :: REAL
    Iy12,Iy13,Iy21,Iy22,Iy23,Iy31,Iy32,Iy33 :: REAL
    Iz12,Iz21,Iz22,Iz23 :: REAL
    Iz13_w,Iz31_w,Iz21_w,Iz22_w,Iz12_w,Iz32_w,Iz23_w,Iz33_w :: REAL
    Dx,Dy,Dz,Cx,Cy,Cz,Ctx,Cty,Ctz :: REAL
    d,d_cc,d_r2cd,c :: REAL
    px__px_,py__px_,pz__px_ :: REAL
    px__py_,py__py_,pz__py_ :: REAL
    px__pz_,py__pz_,pz__pz_ :: REAL
    px__dxx,py__dxx,pz__dxx :: REAL
    px__dyy,py__dyy,pz__dyy :: REAL
    px__dzz,py__dzz,pz__dzz :: REAL
    px__dxy,py__dxy,pz__dxy :: REAL
    px__dxz,py__dxz,pz__dxz :: REAL
    px__dyz,py__dyz,pz__dyz :: REAL
    dxx_px_,dyy_px_,dzz_px_,dxy_px_,dxz_px_,dyz_px_ :: REAL
    dxx_py_,dyy_py_,dzz_py_,dxy_py_,dxz_py_,dyz_py_ :: REAL
    dxx_pz_,dyy_pz_,dzz_pz_,dxy_pz_,dxz_pz_,dyz_pz_ :: REAL
    dxx_dxx,dyy_dxx,dzz_dxx,dxy_dxx,dxz_dxx,dyz_dxx :: REAL
    dxx_dyy,dyy_dyy,dzz_dyy,dxy_dyy,dxz_dyy,dyz_dyy :: REAL
    dxx_dzz,dyy_dzz,dzz_dzz,dxy_dzz,dxz_dzz,dyz_dzz :: REAL
    dxx_dxy,dyy_dxy,dzz_dxy,dxy_dxy,dxz_dxy,dyz_dxy :: REAL
    dxx_dxz,dyy_dxz,dzz_dxz,dxy_dxz,dxz_dxz,dyz_dxz :: REAL
    dxx_dyz,dyy_dyz,dzz_dyz,dxy_dyz,dxz_dyz,dyz_dyz :: REAL
    Iy12_Iz21,Iy12_Iz12,Iy13_Iz21,Iy21_Iz21,Iy21_Iz22 :: REAL
    Iy21_Iz12,Iy31_Iz12,Iy21_Iz13,Iy12_Iz31,Iy12_Iz22 :: REAL
    Iy22_Iz12,Iy22_Iz21 :: REAL
    Ix22_bb,Iy22_bb,Iz22_bb :: REAL
    Iy12_w, Iy21_w, Iy22_w, Iy13_w, Iy31_w, Iy32_w, Iy23_w :: REAL
    px_,py_,pz_,dxx_,dyy_,dzz_,dxy_,dxz_,dyz_ :: REAL
    ag,bg,cg,dg,n,k :: INT

    px__px_ = ZERO; py__px_ = ZERO; pz__px_ = ZERO
    dxx_px_ = ZERO; dyy_px_ = ZERO; dzz_px_ = ZERO
    dxy_px_ = ZERO; dxz_px_ = ZERO; dyz_px_ = ZERO
    px__py_ = ZERO; py__py_ = ZERO; pz__py_ = ZERO
    dxx_py_ = ZERO; dyy_py_ = ZERO; dzz_py_ = ZERO
    dxy_py_ = ZERO; dxz_py_ = ZERO; dyz_py_ = ZERO
    px__pz_ = ZERO; py__pz_ = ZERO; pz__pz_ = ZERO
    dxx_pz_ = ZERO; dyy_pz_ = ZERO; dzz_pz_ = ZERO
    dxy_pz_ = ZERO; dxz_pz_ = ZERO; dyz_pz_ = ZERO
    px__dxx = ZERO; py__dxx = ZERO; pz__dxx = ZERO
    dxx_dxx = ZERO; dyy_dxx = ZERO; dzz_dxx = ZERO
    dxy_dxx = ZERO; dxz_dxx = ZERO; dyz_dxx = ZERO
    px__dyy = ZERO; py__dyy = ZERO; pz__dyy = ZERO
    dxx_dyy = ZERO; dyy_dyy = ZERO; dzz_dyy = ZERO
    dxy_dyy = ZERO; dxz_dyy = ZERO; dyz_dyy = ZERO
    px__dzz = ZERO; py__dzz = ZERO; pz__dzz = ZERO
    dxx_dzz = ZERO; dyy_dzz = ZERO; dzz_dzz = ZERO
    dxy_dzz = ZERO; dxz_dzz = ZERO; dyz_dzz = ZERO
    px__dxy = ZERO; py__dxy = ZERO; pz__dxy = ZERO
    dxx_dxy = ZERO; dyy_dxy = ZERO; dzz_dxy = ZERO
    dxy_dxy = ZERO; dxz_dxy = ZERO; dyz_dxy = ZERO
    px__dxz = ZERO; py__dxz = ZERO; pz__dxz = ZERO
    dxx_dxz = ZERO; dyy_dxz = ZERO; dzz_dxz = ZERO
    dxy_dxz = ZERO; dxz_dxz = ZERO; dyz_dxz = ZERO
    px__dyz = ZERO; py__dyz = ZERO; pz__dyz = ZERO
    dxx_dyz = ZERO; dyy_dyz = ZERO; dzz_dyz = ZERO
    dxy_dyy = ZERO; dxz_dyy = ZERO; dyz_dyy = ZERO
    dxy_dyz = ZERO; dxz_dyz = ZERO; dyz_dyz = ZERO
    Cx = .pos_c(1);  Dx = .pos_d(1)
    Cy = .pos_c(2);  Dy = .pos_d(2)
    Cz = .pos_c(3);  Dz = .pos_d(3)
    if (.c.l > .d.l) then
      Ctx = Cx;  Cty = Cy;  Ctz = Cz
    else
      Ctx = Dx;  Cty = Dy;  Ctz = Dz
    end

    rys1.create(3)
    k = 0
    do bg = 1, .b.n_cc
      do ag = 1, .a.n_cc
        k = k + 1
        zeta = .ab_exponent_sum(k)
        zinv = ONE/zeta
        half_zinv = HALF * zinv
        normab = .ab_cc_prefactor(k) * TWOPI5ON2
        Px = .ab_pair_center(1,k)
        Py = .ab_pair_center(2,k)
        Pz = .ab_pair_center(3,k)
        PAx = .ab_center_diff(1,k)
        PAy = .ab_center_diff(2,k)
        PAz = .ab_center_diff(3,k)
        do dg = 1, .d.n_cc
          d      = .d.ex(dg)
          d_cc   = .d.cc(dg)
          d_r2cd = d * .r2cd
          do cg = 1, .c.n_cc
            c    = .c.ex(cg)
            eta  = c + d
            einv = ONE/eta
            Qx = (d*Dx + c*Cx) * einv
            Qy = (d*Dy + c*Cy) * einv
            Qz = (d*Dz + c*Cz) * einv
            QCx = Qx - Ctx
            QCy = Qy - Cty
            QCz = Qz - Ctz
            rho  = zeta * eta / (zeta + eta)
            rho_zinv = rho * zinv
            rho_einv = rho * einv
            half_einv = HALF * einv
            QPx  = Qx - Px;   QPy  = Qy - Py;   QPz  = Qz - Pz
            xx   = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
            rys1.get_weights(xx)
            rys1.w(:) = rys1.w(:) * (normab * d_cc * .c.cc(cg) * &
                           einv * sqrt(rho_einv) * exp(-c*d_r2cd*einv))
            do n=1,3
              t2    = rys1.r(n)
              w     = rys1.w(n)
              t2_rz = t2 * rho_zinv
              t2_re = t2 * rho_einv
              bb    = t2_rz * half_einv
              bb_2  = bb+bb
              cf    = (ONE - t2_re) * half_einv
              ce    = (ONE - t2_rz) * half_zinv
              Ix12 = QCx - t2_re * QPx           ! form 2 dimensional integrals.
              Iy12 = QCy - t2_re * QPy
              Iz12 = QCz - t2_re * QPz
              Ix21 = PAx + t2_rz * QPx
              Iy21 = PAy + t2_rz * QPy
              Iz21 = PAz + t2_rz * QPz
              Ix22 = Ix12 * Ix21 + bb
              Iy22 = Iy12 * Iy21 + bb
              Iz22 = Iz12 * Iz21 + bb
              Ix13 = Ix12 * Ix12 + cf
              Iy13 = Iy12 * Iy12 + cf
              Iz13_w = (Iz12 * Iz12 + cf) * w
              Ix31 = Ix21 * Ix21 + ce
              Iy31 = Iy21 * Iy21 + ce
              Iz31_w = (Iz21 * Iz21 + ce) * w
              Ix22_bb = Ix22 + bb
              Iy22_bb = Iy22 + bb
              Iz22_bb = Iz22 + bb
              Ix23 = Ix12 * Ix22_bb + cf * Ix21
              Iy23 = Iy12 * Iy22_bb + cf * Iy21
              Iz23 = Iz12 * Iz22_bb + cf * Iz21
              Iz21_w = Iz21 * w    ! Merge the weights and reduce multiplications.
              Iz22_w = Iz22 * w
              Iz12_w = Iz12 * w
              Iz23_w = Iz23 * w
              Iy12_w = Iy12 * w
              Iy21_w = Iy21 * w
              Iy22_w = Iy22 * w
              Iy13_w = Iy13 * w
              Iy31_w = Iy31 * w
              Iy23_w = Iy23 * w
              Ix32 = Ix21 * Ix22_bb + ce * Ix12
              Iy32 = Iy21 * Iy22_bb + ce * Iy12
              Iz32_w = Iz21_w * Iz22_bb + ce * Iz12_w
              Ix33 = Ix21 * Ix23 + ce * Ix13 + bb_2 * Ix22
              Iy33 = Iy21 * Iy23 + ce * Iy13 + bb_2 * Iy22
              Iz33_w = Iz21_w * Iz23 + ce * Iz13_w + bb_2 * Iz22_w
              Iy32_w = Iy32 * w

              Iy12_Iz21 = Iy12 * Iz21_w
              Iy12_Iz12 = Iy12 * Iz12_w
              Iy12_Iz22 = Iy12 * Iz22_w
              Iy12_Iz31 = Iy12 * Iz31_w
              Iy13_Iz21 = Iy13 * Iz21_w
              Iy21_Iz21 = Iy21 * Iz21_w
              Iy21_Iz22 = Iy21 * Iz22_w
              Iy21_Iz12 = Iy21 * Iz12_w
              Iy21_Iz13 = Iy21 * Iz13_w
              Iy31_Iz12 = Iy31 * Iz12_w
              Iy22_Iz12 = Iy22 * Iz12_w
              Iy22_Iz21 = Iy22 * Iz21_w

              px__px_ = px__px_ + Ix22 * w     !  combine 2d ints.
              py__px_ = py__px_ + Ix12 * Iy21_w
              pz__px_ = pz__px_ + Ix12 * Iz21_w
              dxx_px_ = dxx_px_ + Ix32 * w
              dyy_px_ = dyy_px_ + Ix12 * Iy31_w
              dzz_px_ = dzz_px_ + Ix12 * Iz31_w
              dxy_px_ = dxy_px_ + Ix22 * Iy21_w
              dxz_px_ = dxz_px_ + Ix22 * Iz21_w
              dyz_px_ = dyz_px_ + Ix12 * Iy21_Iz21
              px__py_ = px__py_ + Ix21 * Iy12_w
              py__py_ = py__py_ + Iy22_w
              pz__py_ = pz__py_ + Iy12_Iz21
              dxx_py_ = dxx_py_ + Ix31 * Iy12_w
              dyy_py_ = dyy_py_ + Iy32_w
              dzz_py_ = dzz_py_ + Iy12_Iz31
              dxy_py_ = dxy_py_ + Ix21 * Iy22_w
              dxz_py_ = dxz_py_ + Ix21 * Iy12_Iz21
              dyz_py_ = dyz_py_ + Iy22_Iz21
              px__pz_ = px__pz_ + Ix21 * Iz12_w
              py__pz_ = py__pz_ + Iy21_Iz12
              pz__pz_ = pz__pz_ + Iz22_w
              dxx_pz_ = dxx_pz_ + Ix31 * Iz12_w
              dyy_pz_ = dyy_pz_ + Iy31_Iz12
              dzz_pz_ = dzz_pz_ + Iz32_w
              dxy_pz_ = dxy_pz_ + Ix21 * Iy21_Iz12
              dxz_pz_ = dxz_pz_ + Ix21 * Iz22_w
              dyz_pz_ = dyz_pz_ + Iy21_Iz22
              px__dxx = px__dxx + Ix23 * w
              py__dxx = py__dxx + Ix13 * Iy21_w
              pz__dxx = pz__dxx + Ix13 * Iz21_w
              dxx_dxx = dxx_dxx + Ix33 * w
              dyy_dxx = dyy_dxx + Ix13 * Iy31_w
              dzz_dxx = dzz_dxx + Ix13 * Iz31_w
              dxy_dxx = dxy_dxx + Ix23 * Iy21_w
              dxz_dxx = dxz_dxx + Ix23 * Iz21_w
              dyz_dxx = dyz_dxx + Ix13 * Iy21_Iz21
              px__dyy = px__dyy + Ix21 * Iy13_w
              py__dyy = py__dyy + Iy23_w
              pz__dyy = pz__dyy + Iy13_Iz21
              dxx_dyy = dxx_dyy + Ix31 * Iy13_w
              dyy_dyy = dyy_dyy + Iy33 * w
              dzz_dyy = dzz_dyy + Iy13 * Iz31_w
              dxy_dyy = dxy_dyy + Ix21 * Iy23_w
              dxz_dyy = dxz_dyy + Ix21 * Iy13_Iz21
              dyz_dyy = dyz_dyy + Iy23 * Iz21_w
              px__dzz = px__dzz + Ix21 * Iz13_w
              py__dzz = py__dzz + Iy21_Iz13
              pz__dzz = pz__dzz + Iz23_w
              dxx_dzz = dxx_dzz + Ix31 * Iz13_w
              dyy_dzz = dyy_dzz + Iy31 * Iz13_w
              dzz_dzz = dzz_dzz + Iz33_w
              dxy_dzz = dxy_dzz + Ix21 * Iy21_Iz13
              dxz_dzz = dxz_dzz + Ix21 * Iz23_w
              dyz_dzz = dyz_dzz + Iy21 * Iz23_w
              px__dxy = px__dxy + Ix22 * Iy12_w
              py__dxy = py__dxy + Ix12 * Iy22_w
              pz__dxy = pz__dxy + Ix12 * Iy12_Iz21
              dxx_dxy = dxx_dxy + Ix32 * Iy12_w
              dyy_dxy = dyy_dxy + Ix12 * Iy32_w
              dzz_dxy = dzz_dxy + Ix12 * Iy12_Iz31
              dxy_dxy = dxy_dxy + Ix22 * Iy22_w
              dxz_dxy = dxz_dxy + Ix22 * Iy12_Iz21
              dyz_dxy = dyz_dxy + Ix12 * Iy22_Iz21
              px__dxz = px__dxz + Ix22 * Iz12_w
              py__dxz = py__dxz + Ix12 * Iy21_Iz12
              pz__dxz = pz__dxz + Ix12 * Iz22_w
              dxx_dxz = dxx_dxz + Ix32 * Iz12_w
              dyy_dxz = dyy_dxz + Ix12 * Iy31_Iz12
              dzz_dxz = dzz_dxz + Ix12 * Iz32_w
              dxy_dxz = dxy_dxz + Ix22 * Iy21_Iz12
              dxz_dxz = dxz_dxz + Ix22 * Iz22_w
              dyz_dxz = dyz_dxz + Ix12 * Iy21_Iz22
              px__dyz = px__dyz + Ix21 * Iy12_Iz12
              py__dyz = py__dyz + Iy22_Iz12
              pz__dyz = pz__dyz + Iy12_Iz22
              dxx_dyz = dxx_dyz + Ix31 * Iy12_Iz12
              dyy_dyz = dyy_dyz + Iy32 * Iz12_w
              dzz_dyz = dzz_dyz + Iy12 * Iz32_w
              dxy_dyz = dxy_dyz + Ix21 * Iy22_Iz12
              dxz_dyz = dxz_dyz + Ix21 * Iy12_Iz22
              dyz_dyz = dyz_dyz + Iy22 * Iz22_w
            end
          end
        end
      end
    end
    rys1.destroy

    BAx = .pos_b(1) - .pos_a(1)
    BAy = .pos_b(2) - .pos_a(2)
    BAz = .pos_b(3) - .pos_a(3)
    DCx = .pos_d(1) - .pos_c(1)
    DCy = .pos_d(2) - .pos_c(2)
    DCz = .pos_d(3) - .pos_c(3)

    px_  = px__dxx + DCx * px__px_
    py_  = py__dxx + DCx * py__px_
    pz_  = pz__dxx + DCx * pz__px_
    dxx_ = dxx_dxx + DCx * dxx_px_
    dyy_ = dyy_dxx + DCx * dyy_px_
    dzz_ = dzz_dxx + DCx * dzz_px_
    dxy_ = dxy_dxx + DCx * dxy_px_
    dxz_ = dxz_dxx + DCx * dxz_px_
    dyz_ = dyz_dxx + DCx * dyz_px_
    Iab => abcd(:,:,1,1)
    Iab(1,1) = dxx_ + BAx * px_
    Iab(2,1) = dxy_ + BAy * px_
    Iab(3,1) = dxz_ + BAz * px_
    Iab(1,2) = dxy_ + BAx * py_
    Iab(2,2) = dyy_ + BAy * py_
    Iab(3,2) = dyz_ + BAz * py_
    Iab(1,3) = dxz_ + BAx * pz_
    Iab(2,3) = dyz_ + BAy * pz_
    Iab(3,3) = dzz_ + BAz * pz_

    px_  = px__dxy + DCy * px__px_
    py_  = py__dxy + DCy * py__px_
    pz_  = pz__dxy + DCy * pz__px_
    dxx_ = dxx_dxy + DCy * dxx_px_
    dyy_ = dyy_dxy + DCy * dyy_px_
    dzz_ = dzz_dxy + DCy * dzz_px_
    dxy_ = dxy_dxy + DCy * dxy_px_
    dxz_ = dxz_dxy + DCy * dxz_px_
    dyz_ = dyz_dxy + DCy * dyz_px_
    Iab => abcd(:,:,2,1)
    Iab(1,1) = dxx_ + BAx * px_
    Iab(2,1) = dxy_ + BAy * px_
    Iab(3,1) = dxz_ + BAz * px_
    Iab(1,2) = dxy_ + BAx * py_
    Iab(2,2) = dyy_ + BAy * py_
    Iab(3,2) = dyz_ + BAz * py_
    Iab(1,3) = dxz_ + BAx * pz_
    Iab(2,3) = dyz_ + BAy * pz_
    Iab(3,3) = dzz_ + BAz * pz_

    px_  = px__dxz + DCz * px__px_
    py_  = py__dxz + DCz * py__px_
    pz_  = pz__dxz + DCz * pz__px_
    dxx_ = dxx_dxz + DCz * dxx_px_
    dyy_ = dyy_dxz + DCz * dyy_px_
    dzz_ = dzz_dxz + DCz * dzz_px_
    dxy_ = dxy_dxz + DCz * dxy_px_
    dxz_ = dxz_dxz + DCz * dxz_px_
    dyz_ = dyz_dxz + DCz * dyz_px_
    Iab => abcd(:,:,3,1)
    Iab(1,1) = dxx_ + BAx * px_
    Iab(2,1) = dxy_ + BAy * px_
    Iab(3,1) = dxz_ + BAz * px_
    Iab(1,2) = dxy_ + BAx * py_
    Iab(2,2) = dyy_ + BAy * py_
    Iab(3,2) = dyz_ + BAz * py_
    Iab(1,3) = dxz_ + BAx * pz_
    Iab(2,3) = dyz_ + BAy * pz_
    Iab(3,3) = dzz_ + BAz * pz_

    px_  = px__dxy + DCx * px__py_
    py_  = py__dxy + DCx * py__py_
    pz_  = pz__dxy + DCx * pz__py_
    dxx_ = dxx_dxy + DCx * dxx_py_
    dyy_ = dyy_dxy + DCx * dyy_py_
    dzz_ = dzz_dxy + DCx * dzz_py_
    dxy_ = dxy_dxy + DCx * dxy_py_
    dxz_ = dxz_dxy + DCx * dxz_py_
    dyz_ = dyz_dxy + DCx * dyz_py_
    Iab => abcd(:,:,1,2)
    Iab(1,1) = dxx_ + BAx * px_
    Iab(2,1) = dxy_ + BAy * px_
    Iab(3,1) = dxz_ + BAz * px_
    Iab(1,2) = dxy_ + BAx * py_
    Iab(2,2) = dyy_ + BAy * py_
    Iab(3,2) = dyz_ + BAz * py_
    Iab(1,3) = dxz_ + BAx * pz_
    Iab(2,3) = dyz_ + BAy * pz_
    Iab(3,3) = dzz_ + BAz * pz_

    px_  = px__dyy + DCy * px__py_
    py_  = py__dyy + DCy * py__py_
    pz_  = pz__dyy + DCy * pz__py_
    dxx_ = dxx_dyy + DCy * dxx_py_
    dyy_ = dyy_dyy + DCy * dyy_py_
    dzz_ = dzz_dyy + DCy * dzz_py_
    dxy_ = dxy_dyy + DCy * dxy_py_
    dxz_ = dxz_dyy + DCy * dxz_py_
    dyz_ = dyz_dyy + DCy * dyz_py_
    Iab => abcd(:,:,2,2)
    Iab(1,1) = dxx_ + BAx * px_
    Iab(2,1) = dxy_ + BAy * px_
    Iab(3,1) = dxz_ + BAz * px_
    Iab(1,2) = dxy_ + BAx * py_
    Iab(2,2) = dyy_ + BAy * py_
    Iab(3,2) = dyz_ + BAz * py_
    Iab(1,3) = dxz_ + BAx * pz_
    Iab(2,3) = dyz_ + BAy * pz_
    Iab(3,3) = dzz_ + BAz * pz_

    px_  = px__dyz + DCz * px__py_
    py_  = py__dyz + DCz * py__py_
    pz_  = pz__dyz + DCz * pz__py_
    dxx_ = dxx_dyz + DCz * dxx_py_
    dyy_ = dyy_dyz + DCz * dyy_py_
    dzz_ = dzz_dyz + DCz * dzz_py_
    dxy_ = dxy_dyz + DCz * dxy_py_
    dxz_ = dxz_dyz + DCz * dxz_py_
    dyz_ = dyz_dyz + DCz * dyz_py_
    Iab => abcd(:,:,3,2)
    Iab(1,1) = dxx_ + BAx * px_
    Iab(2,1) = dxy_ + BAy * px_
    Iab(3,1) = dxz_ + BAz * px_
    Iab(1,2) = dxy_ + BAx * py_
    Iab(2,2) = dyy_ + BAy * py_
    Iab(3,2) = dyz_ + BAz * py_
    Iab(1,3) = dxz_ + BAx * pz_
    Iab(2,3) = dyz_ + BAy * pz_
    Iab(3,3) = dzz_ + BAz * pz_

    px_  = px__dxz + DCx * px__pz_
    py_  = py__dxz + DCx * py__pz_
    pz_  = pz__dxz + DCx * pz__pz_
    dxx_ = dxx_dxz + DCx * dxx_pz_
    dyy_ = dyy_dxz + DCx * dyy_pz_
    dzz_ = dzz_dxz + DCx * dzz_pz_
    dxy_ = dxy_dxz + DCx * dxy_pz_
    dxz_ = dxz_dxz + DCx * dxz_pz_
    dyz_ = dyz_dxz + DCx * dyz_pz_
    Iab => abcd(:,:,1,3)
    Iab(1,1) = dxx_ + BAx * px_
    Iab(2,1) = dxy_ + BAy * px_
    Iab(3,1) = dxz_ + BAz * px_
    Iab(1,2) = dxy_ + BAx * py_
    Iab(2,2) = dyy_ + BAy * py_
    Iab(3,2) = dyz_ + BAz * py_
    Iab(1,3) = dxz_ + BAx * pz_
    Iab(2,3) = dyz_ + BAy * pz_
    Iab(3,3) = dzz_ + BAz * pz_

    px_  = px__dyz + DCy * px__pz_
    py_  = py__dyz + DCy * py__pz_
    pz_  = pz__dyz + DCy * pz__pz_
    dxx_ = dxx_dyz + DCy * dxx_pz_
    dyy_ = dyy_dyz + DCy * dyy_pz_
    dzz_ = dzz_dyz + DCy * dzz_pz_
    dxy_ = dxy_dyz + DCy * dxy_pz_
    dxz_ = dxz_dyz + DCy * dxz_pz_
    dyz_ = dyz_dyz + DCy * dyz_pz_
    Iab => abcd(:,:,2,3)
    Iab(1,1) = dxx_ + BAx * px_
    Iab(2,1) = dxy_ + BAy * px_
    Iab(3,1) = dxz_ + BAz * px_
    Iab(1,2) = dxy_ + BAx * py_
    Iab(2,2) = dyy_ + BAy * py_
    Iab(3,2) = dyz_ + BAz * py_
    Iab(1,3) = dxz_ + BAx * pz_
    Iab(2,3) = dyz_ + BAy * pz_
    Iab(3,3) = dzz_ + BAz * pz_

    px_  = px__dzz + DCz * px__pz_
    py_  = py__dzz + DCz * py__pz_
    pz_  = pz__dzz + DCz * pz__pz_
    dxx_ = dxx_dzz + DCz * dxx_pz_
    dyy_ = dyy_dzz + DCz * dyy_pz_
    dzz_ = dzz_dzz + DCz * dzz_pz_
    dxy_ = dxy_dzz + DCz * dxy_pz_
    dxz_ = dxz_dzz + DCz * dxz_pz_
    dyz_ = dyz_dzz + DCz * dyz_pz_
    Iab => abcd(:,:,3,3)
    Iab(1,1) = dxx_ + BAx * px_
    Iab(2,1) = dxy_ + BAy * px_
    Iab(3,1) = dxz_ + BAz * px_
    Iab(1,2) = dxy_ + BAx * py_
    Iab(2,2) = dyy_ + BAy * py_
    Iab(3,2) = dyz_ + BAz * py_
    Iab(1,3) = dxz_ + BAx * pz_
    Iab(2,3) = dyz_ + BAy * pz_
    Iab(3,3) = dzz_ + BAz * pz_
  end

  make_ppps(abcd) ::: private
  ! Make the (pp|ps) integrals, summed over primitives.
    self :: IN
    abcd :: REALMAT4, OUT
    Iabf :: REALMAT3*
    Iabf.create(3,3,3)
    if (.ab_n_gaussian_pairs > n_cc_cutoff) then
      .make_ppps(Iabf)
    else
      .make_ppps_low_ncc(Iabf)
    end
    if (.c.l==0) then
      abcd(:,:,1,:) = Iabf
    else ! .d.l==0
      abcd(:,:,:,1) = Iabf
    end
    Iabf.destroy
  end

  make_ppps(Iabf) ::: private
  ! Make the (pp|ps) integrals, summed over primitives.
    self :: IN
    Iabf :: REALMAT3, OUT
    rys1 :: RYS*
    zeta,eta,xx,normab,zinv,rho,einv,rho_zinv,rho_einv :: REAL
    QPx,QPy,QPz,PAx,PAy,PAz,Qx,Qy,Qz,QCx,QCy,QCz,Px,Py,Pz,BAx,BAy,BAz :: REAL
    ce,bb,t2,t2_rz,t2_re,w,half_zinv,half_einv :: REAL
    Ix12,Ix21,Ix22,Ix31,Ix32 :: REAL
    Iy12,Iy21,Iy22,Iy31,Iy32 :: REAL
    Iz12,Iz21,Iz22,Iz31,Iz32 :: REAL
    px__px_,py__px_,pz__px_ :: REAL
    px__py_,py__py_,pz__py_ :: REAL
    px__pz_,py__pz_,pz__pz_ :: REAL
    dxx_px_,dyy_px_,dzz_px_,dxy_px_,dxz_px_,dyz_px_ :: REAL
    dxx_py_,dyy_py_,dzz_py_,dxy_py_,dxz_py_,dyz_py_ :: REAL
    dxx_pz_,dyy_pz_,dzz_pz_,dxy_pz_,dxz_pz_,dyz_pz_ :: REAL
    Iy12_Iz21,Iy21_Iz12,Ix12_Iz21 :: REAL
    Iy12_w,Iy21_w,Iy22_w :: REAL
    ag,bg,cg,dg,nroots,n,j,k :: INT

    px__px_ = ZERO; py__px_ = ZERO; pz__px_ = ZERO
    dxx_px_ = ZERO; dyy_px_ = ZERO; dzz_px_ = ZERO
    dxy_px_ = ZERO; dxz_px_ = ZERO; dyz_px_ = ZERO
    px__py_ = ZERO; py__py_ = ZERO; pz__py_ = ZERO
    dxx_py_ = ZERO; dyy_py_ = ZERO; dzz_py_ = ZERO
    dxy_py_ = ZERO; dxz_py_ = ZERO; dyz_py_ = ZERO
    px__pz_ = ZERO; py__pz_ = ZERO; pz__pz_ = ZERO
    dxx_pz_ = ZERO; dyy_pz_ = ZERO; dzz_pz_ = ZERO
    dxy_pz_ = ZERO; dxz_pz_ = ZERO; dyz_pz_ = ZERO

    nroots = (.a.l+.b.l+.c.l+.d.l+2)/2
    rys1.create(nroots)

    k = 0
    do bg = 1, .b.n_cc
      do ag = 1, .a.n_cc
        k = k + 1
        zeta = .ab_exponent_sum(k)
        zinv = ONE/zeta
        half_zinv = HALF * zinv
        normab = .ab_cc_prefactor(k) * TWOPI5ON2
        Px = .ab_pair_center(1,k)
        Py = .ab_pair_center(2,k)
        Pz = .ab_pair_center(3,k)
        PAx = .ab_center_diff(1,k)
        PAy = .ab_center_diff(2,k)
        PAz = .ab_center_diff(3,k)
        j = 0
        do dg = 1, .d.n_cc
          do cg = 1, .c.n_cc
            j = j + 1
            eta  = .cd_exponent_sum(j)
            einv = ONE/eta
            Qx = .cd_pair_center(1,j)
            Qy = .cd_pair_center(2,j)
            Qz = .cd_pair_center(3,j)
            QCx = .cd_center_diff(1,j)
            QCy = .cd_center_diff(2,j)
            QCz = .cd_center_diff(3,j)
            rho  = zeta * eta / (zeta + eta)
            rho_zinv = rho * zinv
            rho_einv = rho * einv
            QPx  = Qx - Px;   QPy  = Qy - Py;   QPz  = Qz - Pz
            xx   = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
            rys1.get_weights(xx)
            rys1.w(:) = rys1.w(:) * normab * .cd_cc_prefactor(j) * sqrt(rho)

            half_einv = HALF * einv
            do n=1,nroots
              t2    = rys1.r(n)
              w     = rys1.w(n)
              t2_rz = t2 * rho_zinv
              t2_re = t2 * rho_einv
              bb    = t2_rz * half_einv
              ce    = (ONE - t2_rz) * half_zinv
              Ix12 = QCx - t2_re * QPx       ! form 2 dimensional integrals.
              Iy12 = QCy - t2_re * QPy
              Iz12 = QCz - t2_re * QPz
              Ix21 = PAx + t2_rz * QPx
              Iy21 = PAy + t2_rz * QPy
              Iz21 = PAz + t2_rz * QPz
              Ix22 = Ix12 * Ix21 + bb
              Iy22 = Iy12 * Iy21 + bb
              Iz22 = Iz12 * Iz21 + bb
              Ix31 = Ix21 * Ix21 + ce
              Iy31 = Iy21 * Iy21 + ce
              Iz31 = Iz21 * Iz21 + ce
              Ix32 = Ix21 * (Ix22 + bb) + ce * Ix12
              Iy32 = Iy21 * (Iy22 + bb) + ce * Iy12
              Iz32 = Iz21 * (Iz22 + bb) + ce * Iz12

              Iz21 = Iz21 * w    ! Merge the weights and reduce multiplications.
              Iz31 = Iz31 * w
              Iz12 = Iz12 * w
              Iz22 = Iz22 * w
              Iy12_Iz21 = Iy12 * Iz21
              Iy21_Iz12 = Iy21 * Iz12
              Ix12_Iz21 = Ix12 * Iz21
              Iy12_w    = Iy12 * w
              Iy21_w    = Iy21 * w
              Iy22_w    = Iy22 * w

              px__px_ = px__px_ + Ix22 * w         ! combine 2d ints.
              py__px_ = py__px_ + Ix12 * Iy21_w
              pz__px_ = pz__px_ + Ix12_Iz21
              dxx_px_ = dxx_px_ + Ix32 * w
              dyy_px_ = dyy_px_ + Ix12 * Iy31 * w
              dzz_px_ = dzz_px_ + Ix12 * Iz31
              dxy_px_ = dxy_px_ + Ix22 * Iy21_w
              dxz_px_ = dxz_px_ + Ix22 * Iz21
              dyz_px_ = dyz_px_ + Ix12_Iz21 * Iy21
              px__py_ = px__py_ + Ix21 * Iy12_w
              py__py_ = py__py_ + Iy22_w
              pz__py_ = pz__py_ + Iy12_Iz21
              dxx_py_ = dxx_py_ + Ix31 * Iy12_w
              dyy_py_ = dyy_py_ + Iy32 * w
              dzz_py_ = dzz_py_ + Iy12 * Iz31
              dxy_py_ = dxy_py_ + Ix21 * Iy22_w
              dxz_py_ = dxz_py_ + Ix21 * Iy12_Iz21
              dyz_py_ = dyz_py_ + Iy22 * Iz21
              px__pz_ = px__pz_ + Ix21 * Iz12
              py__pz_ = py__pz_ + Iy21_Iz12
              pz__pz_ = pz__pz_ + Iz22
              dxx_pz_ = dxx_pz_ + Ix31 * Iz12
              dyy_pz_ = dyy_pz_ + Iy31 * Iz12
              dzz_pz_ = dzz_pz_ + Iz32 * w
              dxy_pz_ = dxy_pz_ + Ix21 * Iy21_Iz12
              dxz_pz_ = dxz_pz_ + Ix21 * Iz22
              dyz_pz_ = dyz_pz_ + Iy21 * Iz22
            end
          end
        end
      end
    end
    rys1.destroy

    BAx = .pos_b(1) - .pos_a(1)
    BAy = .pos_b(2) - .pos_a(2)
    BAz = .pos_b(3) - .pos_a(3)

    Iabf(1,1,1) = dxx_px_ + BAx * px__px_
    Iabf(1,1,2) = dxx_py_ + BAx * px__py_
    Iabf(1,1,3) = dxx_pz_ + BAx * px__pz_
    Iabf(2,1,1) = dxy_px_ + BAy * px__px_
    Iabf(2,1,2) = dxy_py_ + BAy * px__py_
    Iabf(2,1,3) = dxy_pz_ + BAy * px__pz_
    Iabf(3,1,1) = dxz_px_ + BAz * px__px_
    Iabf(3,1,2) = dxz_py_ + BAz * px__py_
    Iabf(3,1,3) = dxz_pz_ + BAz * px__pz_
    Iabf(1,2,1) = dxy_px_ + BAx * py__px_
    Iabf(1,2,2) = dxy_py_ + BAx * py__py_
    Iabf(1,2,3) = dxy_pz_ + BAx * py__pz_
    Iabf(2,2,1) = dyy_px_ + BAy * py__px_
    Iabf(2,2,2) = dyy_py_ + BAy * py__py_
    Iabf(2,2,3) = dyy_pz_ + BAy * py__pz_
    Iabf(3,2,1) = dyz_px_ + BAz * py__px_
    Iabf(3,2,2) = dyz_py_ + BAz * py__py_
    Iabf(3,2,3) = dyz_pz_ + BAz * py__pz_
    Iabf(1,3,1) = dxz_px_ + BAx * pz__px_
    Iabf(1,3,2) = dxz_py_ + BAx * pz__py_
    Iabf(1,3,3) = dxz_pz_ + BAx * pz__pz_
    Iabf(2,3,1) = dyz_px_ + BAy * pz__px_
    Iabf(2,3,2) = dyz_py_ + BAy * pz__py_
    Iabf(2,3,3) = dyz_pz_ + BAy * pz__pz_
    Iabf(3,3,1) = dzz_px_ + BAz * pz__px_
    Iabf(3,3,2) = dzz_py_ + BAz * pz__py_
    Iabf(3,3,3) = dzz_pz_ + BAz * pz__pz_
  end

  make_ppps_low_ncc(Iabf) ::: private
  ! Make the (pp|ps) integrals, summed over primitives.
    self :: IN
    Iabf :: REALMAT3, OUT
    rys1 :: RYS*
    zeta,eta,xx,normab,zinv,rho,einv,rho_zinv,rho_einv :: REAL
    QPx,QPy,QPz,PAx,PAy,PAz,Qx,Qy,Qz,QCx,QCy,QCz,Px,Py,Pz,BAx,BAy,BAz :: REAL
    ce,bb,t2,t2_rz,t2_re,w,half_zinv,half_einv :: REAL
    Ix12,Ix21,Ix22,Ix31,Ix32 :: REAL
    Iy12,Iy21,Iy22,Iy31,Iy32 :: REAL
    Iz12,Iz21,Iz22,Iz31,Iz32 :: REAL
    Dx,Dy,Dz,Cx,Cy,Cz,Ctx,Cty,Ctz :: REAL
    d,d_cc,d_r2cd,c :: REAL
    px__px_,py__px_,pz__px_ :: REAL
    px__py_,py__py_,pz__py_ :: REAL
    px__pz_,py__pz_,pz__pz_ :: REAL
    dxx_px_,dyy_px_,dzz_px_,dxy_px_,dxz_px_,dyz_px_ :: REAL
    dxx_py_,dyy_py_,dzz_py_,dxy_py_,dxz_py_,dyz_py_ :: REAL
    dxx_pz_,dyy_pz_,dzz_pz_,dxy_pz_,dxz_pz_,dyz_pz_ :: REAL
    Iy12_Iz21,Iy21_Iz12,Ix12_Iz21 :: REAL
    Iy12_w,Iy21_w,Iy22_w :: REAL
    ag,bg,cg,dg,nroots,n,k :: INT

    px__px_ = ZERO; py__px_ = ZERO; pz__px_ = ZERO
    dxx_px_ = ZERO; dyy_px_ = ZERO; dzz_px_ = ZERO
    dxy_px_ = ZERO; dxz_px_ = ZERO; dyz_px_ = ZERO
    px__py_ = ZERO; py__py_ = ZERO; pz__py_ = ZERO
    dxx_py_ = ZERO; dyy_py_ = ZERO; dzz_py_ = ZERO
    dxy_py_ = ZERO; dxz_py_ = ZERO; dyz_py_ = ZERO
    px__pz_ = ZERO; py__pz_ = ZERO; pz__pz_ = ZERO
    dxx_pz_ = ZERO; dyy_pz_ = ZERO; dzz_pz_ = ZERO
    dxy_pz_ = ZERO; dxz_pz_ = ZERO; dyz_pz_ = ZERO

    nroots = (.a.l+.b.l+.c.l+.d.l+2)/2
    rys1.create(nroots)
    Cx = .pos_c(1);  Dx = .pos_d(1)
    Cy = .pos_c(2);  Dy = .pos_d(2)
    Cz = .pos_c(3);  Dz = .pos_d(3)
    if (.c.l > .d.l) then
      Ctx = Cx;  Cty = Cy;  Ctz = Cz
    else
      Ctx = Dx;  Cty = Dy;  Ctz = Dz
    end

    k = 0
    do bg = 1, .b.n_cc
      do ag = 1, .a.n_cc
        k = k + 1
        zeta = .ab_exponent_sum(k)
        zinv = ONE/zeta
        half_zinv = HALF * zinv
        normab = .ab_cc_prefactor(k) * TWOPI5ON2
        Px = .ab_pair_center(1,k)
        Py = .ab_pair_center(2,k)
        Pz = .ab_pair_center(3,k)
        PAx = .ab_center_diff(1,k)
        PAy = .ab_center_diff(2,k)
        PAz = .ab_center_diff(3,k)
        do dg = 1, .d.n_cc
          d      = .d.ex(dg)
          d_cc   = .d.cc(dg)
          d_r2cd = d * .r2cd
          do cg = 1, .c.n_cc
            c    = .c.ex(cg)
            eta  = c + d
            einv = ONE/eta
            Qx = (d*Dx + c*Cx) * einv
            Qy = (d*Dy + c*Cy) * einv
            Qz = (d*Dz + c*Cz) * einv
            QCx = Qx - Ctx
            QCy = Qy - Cty
            QCz = Qz - Ctz
            rho  = zeta * eta / (zeta + eta)
            rho_zinv = rho * zinv
            rho_einv = rho * einv
            half_einv = HALF * einv
            QPx  = Qx - Px;   QPy  = Qy - Py;   QPz  = Qz - Pz
            xx   = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
            rys1.get_weights(xx)
            rys1.w(:) = rys1.w(:) * (normab * d_cc * .c.cc(cg) * &
                           einv * sqrt(rho_einv) * exp(-c*d_r2cd*einv))
            do n=1,nroots
              t2    = rys1.r(n)
              w     = rys1.w(n)
              t2_rz = t2 * rho_zinv
              t2_re = t2 * rho_einv
              bb    = t2_rz * half_einv
              ce    = (ONE - t2_rz) * half_zinv
              Ix12 = QCx - t2_re * QPx       ! form 2 dimensional integrals.
              Iy12 = QCy - t2_re * QPy
              Iz12 = QCz - t2_re * QPz
              Ix21 = PAx + t2_rz * QPx
              Iy21 = PAy + t2_rz * QPy
              Iz21 = PAz + t2_rz * QPz
              Ix22 = Ix12 * Ix21 + bb
              Iy22 = Iy12 * Iy21 + bb
              Iz22 = Iz12 * Iz21 + bb
              Ix31 = Ix21 * Ix21 + ce
              Iy31 = Iy21 * Iy21 + ce
              Iz31 = Iz21 * Iz21 + ce
              Ix32 = Ix21 * (Ix22 + bb) + ce * Ix12
              Iy32 = Iy21 * (Iy22 + bb) + ce * Iy12
              Iz32 = Iz21 * (Iz22 + bb) + ce * Iz12

              Iz21 = Iz21 * w    ! Merge the weights and reduce multiplications.
              Iz31 = Iz31 * w
              Iz12 = Iz12 * w
              Iz22 = Iz22 * w
              Iy12_Iz21 = Iy12 * Iz21
              Iy21_Iz12 = Iy21 * Iz12
              Ix12_Iz21 = Ix12 * Iz21
              Iy12_w    = Iy12 * w
              Iy21_w    = Iy21 * w
              Iy22_w    = Iy22 * w

              px__px_ = px__px_ + Ix22 * w         ! combine 2d ints.
              py__px_ = py__px_ + Ix12 * Iy21_w
              pz__px_ = pz__px_ + Ix12_Iz21
              dxx_px_ = dxx_px_ + Ix32 * w
              dyy_px_ = dyy_px_ + Ix12 * Iy31 * w
              dzz_px_ = dzz_px_ + Ix12 * Iz31
              dxy_px_ = dxy_px_ + Ix22 * Iy21_w
              dxz_px_ = dxz_px_ + Ix22 * Iz21
              dyz_px_ = dyz_px_ + Ix12_Iz21 * Iy21
              px__py_ = px__py_ + Ix21 * Iy12_w
              py__py_ = py__py_ + Iy22_w
              pz__py_ = pz__py_ + Iy12_Iz21
              dxx_py_ = dxx_py_ + Ix31 * Iy12_w
              dyy_py_ = dyy_py_ + Iy32 * w
              dzz_py_ = dzz_py_ + Iy12 * Iz31
              dxy_py_ = dxy_py_ + Ix21 * Iy22_w
              dxz_py_ = dxz_py_ + Ix21 * Iy12_Iz21
              dyz_py_ = dyz_py_ + Iy22 * Iz21
              px__pz_ = px__pz_ + Ix21 * Iz12
              py__pz_ = py__pz_ + Iy21_Iz12
              pz__pz_ = pz__pz_ + Iz22
              dxx_pz_ = dxx_pz_ + Ix31 * Iz12
              dyy_pz_ = dyy_pz_ + Iy31 * Iz12
              dzz_pz_ = dzz_pz_ + Iz32 * w
              dxy_pz_ = dxy_pz_ + Ix21 * Iy21_Iz12
              dxz_pz_ = dxz_pz_ + Ix21 * Iz22
              dyz_pz_ = dyz_pz_ + Iy21 * Iz22
            end
          end
        end
      end
    end
    rys1.destroy

    BAx = .pos_b(1) - .pos_a(1)
    BAy = .pos_b(2) - .pos_a(2)
    BAz = .pos_b(3) - .pos_a(3)

    Iabf(1,1,1) = dxx_px_ + BAx * px__px_
    Iabf(1,1,2) = dxx_py_ + BAx * px__py_
    Iabf(1,1,3) = dxx_pz_ + BAx * px__pz_
    Iabf(2,1,1) = dxy_px_ + BAy * px__px_
    Iabf(2,1,2) = dxy_py_ + BAy * px__py_
    Iabf(2,1,3) = dxy_pz_ + BAy * px__pz_
    Iabf(3,1,1) = dxz_px_ + BAz * px__px_
    Iabf(3,1,2) = dxz_py_ + BAz * px__py_
    Iabf(3,1,3) = dxz_pz_ + BAz * px__pz_
    Iabf(1,2,1) = dxy_px_ + BAx * py__px_
    Iabf(1,2,2) = dxy_py_ + BAx * py__py_
    Iabf(1,2,3) = dxy_pz_ + BAx * py__pz_
    Iabf(2,2,1) = dyy_px_ + BAy * py__px_
    Iabf(2,2,2) = dyy_py_ + BAy * py__py_
    Iabf(2,2,3) = dyy_pz_ + BAy * py__pz_
    Iabf(3,2,1) = dyz_px_ + BAz * py__px_
    Iabf(3,2,2) = dyz_py_ + BAz * py__py_
    Iabf(3,2,3) = dyz_pz_ + BAz * py__pz_
    Iabf(1,3,1) = dxz_px_ + BAx * pz__px_
    Iabf(1,3,2) = dxz_py_ + BAx * pz__py_
    Iabf(1,3,3) = dxz_pz_ + BAx * pz__pz_
    Iabf(2,3,1) = dyz_px_ + BAy * pz__px_
    Iabf(2,3,2) = dyz_py_ + BAy * pz__py_
    Iabf(2,3,3) = dyz_pz_ + BAy * pz__pz_
    Iabf(3,3,1) = dzz_px_ + BAz * pz__px_
    Iabf(3,3,2) = dzz_py_ + BAz * pz__py_
    Iabf(3,3,3) = dzz_pz_ + BAz * pz__pz_
  end

  make_pspp(abcd) ::: private
  ! Make the (ps|pp) integrals, summed over primitives.
    self :: IN
    abcd :: REALMAT4, OUT
    Iabf :: REALMAT3*
    Iabf.create(3,3,3)
    if (.ab_n_gaussian_pairs > n_cc_cutoff) then
      .make_pspp(Iabf)
    else
      .make_pspp_low_ncc(Iabf)
    end
    if (.a.l==0) then
      abcd(1,:,:,:) = Iabf
    else ! .b.l==0
      abcd(:,1,:,:) = Iabf
    end
    Iabf.destroy
  end

  make_pspp(Iabf) ::: private
  ! Make the (ps|pp) integrals, summed over primitives.
    self :: IN
    Iabf :: REALMAT3, OUT
    rys1 :: RYS*
    zeta,eta,xx,normab,zinv,rho,einv,rho_zinv,rho_einv :: REAL
    QPx,QPy,QPz,PAx,PAy,PAz,Qx,Qy,Qz,QCx,QCy,QCz,Px,Py,Pz,DCx,DCy,DCz :: REAL
    cf,bb,t2,t2_rz,t2_re,w,half_zinv,half_einv :: REAL
    Ix12,Ix13,Ix21,Ix22,Ix23 :: REAL
    Iy12,Iy13,Iy21,Iy22,Iy23 :: REAL
    Iz12,Iz13,Iz21,Iz22,Iz23 :: REAL
    px__px_,py__px_,pz__px_ :: REAL
    px__py_,py__py_,pz__py_ :: REAL
    px__pz_,py__pz_,pz__pz_ :: REAL
    px__dxx,py__dxx,pz__dxx :: REAL
    px__dyy,py__dyy,pz__dyy :: REAL
    px__dzz,py__dzz,pz__dzz :: REAL
    px__dxy,py__dxy,pz__dxy :: REAL
    px__dxz,py__dxz,pz__dxz :: REAL
    px__dyz,py__dyz,pz__dyz :: REAL
    Iy12_Iz21,Iy21_Iz12,Ix21_Iz12 :: REAL
    Iy12_w,Iy21_w,Iy22_w :: REAL
    ag,bg,cg,dg,nroots,n,j,k :: INT

    px__px_ = ZERO; py__px_ = ZERO; pz__px_ = ZERO
    px__py_ = ZERO; py__py_ = ZERO; pz__py_ = ZERO
    px__pz_ = ZERO; py__pz_ = ZERO; pz__pz_ = ZERO
    px__dxx = ZERO; py__dxx = ZERO; pz__dxx = ZERO
    px__dyy = ZERO; py__dyy = ZERO; pz__dyy = ZERO
    px__dzz = ZERO; py__dzz = ZERO; pz__dzz = ZERO
    px__dxy = ZERO; py__dxy = ZERO; pz__dxy = ZERO
    px__dxz = ZERO; py__dxz = ZERO; pz__dxz = ZERO
    px__dyz = ZERO; py__dyz = ZERO; pz__dyz = ZERO

    nroots = (.ab_l_sum+.cd_l_sum+2)/2
    rys1.create(nroots)
    k = 0
    do bg = 1, .b.n_cc
      do ag = 1, .a.n_cc
        k = k + 1
        zeta = .ab_exponent_sum(k)
        zinv = ONE/zeta
        half_zinv = HALF * zinv
        normab = .ab_cc_prefactor(k) * TWOPI5ON2
        Px = .ab_pair_center(1,k)
        Py = .ab_pair_center(2,k)
        Pz = .ab_pair_center(3,k)
        PAx = .ab_center_diff(1,k)
        PAy = .ab_center_diff(2,k)
        PAz = .ab_center_diff(3,k)
        j = 0
        do dg = 1, .d.n_cc
          do cg = 1, .c.n_cc
            j = j + 1
            eta  = .cd_exponent_sum(j)
            einv = ONE/eta
            Qx = .cd_pair_center(1,j)
            Qy = .cd_pair_center(2,j)
            Qz = .cd_pair_center(3,j)
            QCx = .cd_center_diff(1,j)
            QCy = .cd_center_diff(2,j)
            QCz = .cd_center_diff(3,j)
            rho  = zeta * eta / (zeta + eta)
            rho_zinv = rho * zinv
            rho_einv = rho * einv
            QPx  = Qx - Px;   QPy  = Qy - Py;   QPz  = Qz - Pz
            xx   = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
            rys1.get_weights(xx)
            rys1.w(:) = rys1.w(:) * normab * .cd_cc_prefactor(j) * sqrt(rho)
            half_zinv = HALF * zinv
            half_einv = HALF * einv
            do n=1,nroots
              t2    = rys1.r(n)
              w     = rys1.w(n)
              t2_rz = t2 * rho_zinv
              t2_re = t2 * rho_einv
              bb    = t2_rz * half_einv
              cf    = (ONE - t2_re) * half_einv
              Ix12 = QCx - t2_re * QPx           ! form 2 dimensional integrals.
              Iy12 = QCy - t2_re * QPy
              Iz12 = QCz - t2_re * QPz
              Ix21 = PAx + t2_rz * QPx
              Iy21 = PAy + t2_rz * QPy
              Iz21 = PAz + t2_rz * QPz
              Ix22 = Ix12 * Ix21 + bb
              Iy22 = Iy12 * Iy21 + bb
              Iz22 = Iz12 * Iz21 + bb
              Ix13 = Ix12 * Ix12 + cf
              Iy13 = Iy12 * Iy12 + cf
              Iz13 = Iz12 * Iz12 + cf
              Ix23 = Ix12 * (Ix22 + bb) + cf * Ix21
              Iy23 = Iy12 * (Iy22 + bb) + cf * Iy21
              Iz23 = Iz12 * (Iz22 + bb) + cf * Iz21

              Iz21 = Iz21 * w    ! Merge the weights and reduce multiplications.
              Iz12 = Iz12 * w
              Iz22 = Iz22 * w
              Iz13 = Iz13 * w
              Iy12_Iz21 = Iy12 * Iz21
              Iy21_Iz12 = Iy21 * Iz12
              Ix21_Iz12 = Ix21 * Iz12
              Iy12_w    = Iy12 * w
              Iy21_w    = Iy21 * w
              Iy22_w    = Iy22 * w

              px__px_ = px__px_ + Ix22 * w     ! combine 2d ints.
              py__px_ = py__px_ + Ix12 * Iy21_w
              pz__px_ = pz__px_ + Ix12 * Iz21
              px__py_ = px__py_ + Ix21 * Iy12_w
              py__py_ = py__py_ + Iy22_w
              pz__py_ = pz__py_ + Iy12_Iz21
              px__pz_ = px__pz_ + Ix21_Iz12
              py__pz_ = py__pz_ + Iy21_Iz12
              pz__pz_ = pz__pz_ + Iz22
              px__dxx = px__dxx + Ix23 * w
              py__dxx = py__dxx + Ix13 * Iy21_w
              pz__dxx = pz__dxx + Ix13 * Iz21
              px__dyy = px__dyy + Ix21 * Iy13 * w
              py__dyy = py__dyy + Iy23 * w
              pz__dyy = pz__dyy + Iy13 * Iz21
              px__dzz = px__dzz + Ix21 * Iz13
              py__dzz = py__dzz + Iy21 * Iz13
              pz__dzz = pz__dzz + Iz23 * w
              px__dxy = px__dxy + Ix22 * Iy12_w
              py__dxy = py__dxy + Ix12 * Iy22_w
              pz__dxy = pz__dxy + Ix12 * Iy12_Iz21
              px__dxz = px__dxz + Ix22 * Iz12
              py__dxz = py__dxz + Ix12 * Iy21_Iz12
              pz__dxz = pz__dxz + Ix12 * Iz22
              px__dyz = px__dyz + Ix21_Iz12 * Iy12
              py__dyz = py__dyz + Iy22 * Iz12
              pz__dyz = pz__dyz + Iy12 * Iz22
            end
          end
        end
      end
    end
    rys1.destroy

    DCx = .pos_d(1) - .pos_c(1)
    DCy = .pos_d(2) - .pos_c(2)
    DCz = .pos_d(3) - .pos_c(3)

    Iabf(1,1,1) = px__dxx + DCx * px__px_
    Iabf(2,1,1) = py__dxx + DCx * py__px_
    Iabf(3,1,1) = pz__dxx + DCx * pz__px_
    Iabf(1,2,1) = px__dxy + DCy * px__px_
    Iabf(2,2,1) = py__dxy + DCy * py__px_
    Iabf(3,2,1) = pz__dxy + DCy * pz__px_
    Iabf(1,3,1) = px__dxz + DCz * px__px_
    Iabf(2,3,1) = py__dxz + DCz * py__px_
    Iabf(3,3,1) = pz__dxz + DCz * pz__px_
    Iabf(1,1,2) = px__dxy + DCx * px__py_
    Iabf(2,1,2) = py__dxy + DCx * py__py_
    Iabf(3,1,2) = pz__dxy + DCx * pz__py_
    Iabf(1,2,2) = px__dyy + DCy * px__py_
    Iabf(2,2,2) = py__dyy + DCy * py__py_
    Iabf(3,2,2) = pz__dyy + DCy * pz__py_
    Iabf(1,3,2) = px__dyz + DCz * px__py_
    Iabf(2,3,2) = py__dyz + DCz * py__py_
    Iabf(3,3,2) = pz__dyz + DCz * pz__py_
    Iabf(1,1,3) = px__dxz + DCx * px__pz_
    Iabf(2,1,3) = py__dxz + DCx * py__pz_
    Iabf(3,1,3) = pz__dxz + DCx * pz__pz_
    Iabf(1,2,3) = px__dyz + DCy * px__pz_
    Iabf(2,2,3) = py__dyz + DCy * py__pz_
    Iabf(3,2,3) = pz__dyz + DCy * pz__pz_
    Iabf(1,3,3) = px__dzz + DCz * px__pz_
    Iabf(2,3,3) = py__dzz + DCz * py__pz_
    Iabf(3,3,3) = pz__dzz + DCz * pz__pz_
  end

  make_pspp_low_ncc(Iabf) ::: private
  ! Make the (ps|pp) integrals, summed over primitives.
    self :: IN
    Iabf :: REALMAT3, OUT
    rys1 :: RYS*
    zeta,eta,xx,normab,zinv,rho,einv,rho_zinv,rho_einv :: REAL
    QPx,QPy,QPz,PAx,PAy,PAz,Qx,Qy,Qz,QCx,QCy,QCz,Px,Py,Pz,DCx,DCy,DCz :: REAL
    cf,bb,t2,t2_rz,t2_re,w,half_einv :: REAL
    Ix12,Ix13,Ix21,Ix22,Ix23 :: REAL
    Iy12,Iy13,Iy21,Iy22,Iy23 :: REAL
    Iz12,Iz13,Iz21,Iz22,Iz23 :: REAL
    Dx,Dy,Dz,Cx,Cy,Cz,Ctx,Cty,Ctz :: REAL
    d,d_cc,d_r2cd,c :: REAL
    px__px_,py__px_,pz__px_ :: REAL
    px__py_,py__py_,pz__py_ :: REAL
    px__pz_,py__pz_,pz__pz_ :: REAL
    px__dxx,py__dxx,pz__dxx :: REAL
    px__dyy,py__dyy,pz__dyy :: REAL
    px__dzz,py__dzz,pz__dzz :: REAL
    px__dxy,py__dxy,pz__dxy :: REAL
    px__dxz,py__dxz,pz__dxz :: REAL
    px__dyz,py__dyz,pz__dyz :: REAL
    Iy12_Iz21,Iy21_Iz12,Ix21_Iz12 :: REAL
    Iy12_w,Iy21_w,Iy22_w :: REAL
    ag,bg,cg,dg,nroots,n,k :: INT

    px__px_ = ZERO; py__px_ = ZERO; pz__px_ = ZERO
    px__py_ = ZERO; py__py_ = ZERO; pz__py_ = ZERO
    px__pz_ = ZERO; py__pz_ = ZERO; pz__pz_ = ZERO
    px__dxx = ZERO; py__dxx = ZERO; pz__dxx = ZERO
    px__dyy = ZERO; py__dyy = ZERO; pz__dyy = ZERO
    px__dzz = ZERO; py__dzz = ZERO; pz__dzz = ZERO
    px__dxy = ZERO; py__dxy = ZERO; pz__dxy = ZERO
    px__dxz = ZERO; py__dxz = ZERO; pz__dxz = ZERO
    px__dyz = ZERO; py__dyz = ZERO; pz__dyz = ZERO
    Cx = .pos_c(1);  Dx = .pos_d(1)
    Cy = .pos_c(2);  Dy = .pos_d(2)
    Cz = .pos_c(3);  Dz = .pos_d(3)
    if (.c.l > .d.l) then
      Ctx = Cx;  Cty = Cy;  Ctz = Cz
    else
      Ctx = Dx;  Cty = Dy;  Ctz = Dz
    end

    nroots = (.ab_l_sum+.cd_l_sum+2)/2
    rys1.create(nroots)
    k = 0
    do bg = 1, .b.n_cc
      do ag = 1, .a.n_cc
        k = k + 1
        zeta = .ab_exponent_sum(k)
        zinv = ONE/zeta
        normab = .ab_cc_prefactor(k) * TWOPI5ON2
        Px = .ab_pair_center(1,k)
        Py = .ab_pair_center(2,k)
        Pz = .ab_pair_center(3,k)
        PAx = .ab_center_diff(1,k)
        PAy = .ab_center_diff(2,k)
        PAz = .ab_center_diff(3,k)
        do dg = 1, .d.n_cc
          d      = .d.ex(dg)
          d_cc   = .d.cc(dg)
          d_r2cd = d * .r2cd
          do cg = 1, .c.n_cc
            c    = .c.ex(cg)
            eta  = c + d
            einv = ONE/eta
            Qx = (d*Dx + c*Cx) * einv
            Qy = (d*Dy + c*Cy) * einv
            Qz = (d*Dz + c*Cz) * einv
            QCx = Qx - Ctx
            QCy = Qy - Cty
            QCz = Qz - Ctz
            rho  = zeta * eta / (zeta + eta)
            rho_zinv = rho * zinv
            rho_einv = rho * einv
            half_einv = HALF * einv
            QPx  = Qx - Px;   QPy  = Qy - Py;   QPz  = Qz - Pz
            xx   = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
            rys1.get_weights(xx)
            rys1.w(:) = rys1.w(:) * (normab * d_cc * .c.cc(cg) * &
                           einv * sqrt(rho_einv) * exp(-c*d_r2cd*einv))
            do n=1,nroots
              t2    = rys1.r(n)
              w     = rys1.w(n)
              t2_rz = t2 * rho_zinv
              t2_re = t2 * rho_einv
              bb    = t2_rz * half_einv
              cf    = (ONE - t2_re) * half_einv
              Ix12 = QCx - t2_re * QPx           ! form 2 dimensional integrals.
              Iy12 = QCy - t2_re * QPy
              Iz12 = QCz - t2_re * QPz
              Ix21 = PAx + t2_rz * QPx
              Iy21 = PAy + t2_rz * QPy
              Iz21 = PAz + t2_rz * QPz
              Ix22 = Ix12 * Ix21 + bb
              Iy22 = Iy12 * Iy21 + bb
              Iz22 = Iz12 * Iz21 + bb
              Ix13 = Ix12 * Ix12 + cf
              Iy13 = Iy12 * Iy12 + cf
              Iz13 = Iz12 * Iz12 + cf
              Ix23 = Ix12 * (Ix22 + bb) + cf * Ix21
              Iy23 = Iy12 * (Iy22 + bb) + cf * Iy21
              Iz23 = Iz12 * (Iz22 + bb) + cf * Iz21

              Iz21 = Iz21 * w    ! Merge the weights and reduce multiplications.
              Iz12 = Iz12 * w
              Iz22 = Iz22 * w
              Iz13 = Iz13 * w
              Iy12_Iz21 = Iy12 * Iz21
              Iy21_Iz12 = Iy21 * Iz12
              Ix21_Iz12 = Ix21 * Iz12
              Iy12_w    = Iy12 * w
              Iy21_w    = Iy21 * w
              Iy22_w    = Iy22 * w

              px__px_ = px__px_ + Ix22 * w     ! combine 2d ints.
              py__px_ = py__px_ + Ix12 * Iy21_w
              pz__px_ = pz__px_ + Ix12 * Iz21
              px__py_ = px__py_ + Ix21 * Iy12_w
              py__py_ = py__py_ + Iy22_w
              pz__py_ = pz__py_ + Iy12_Iz21
              px__pz_ = px__pz_ + Ix21_Iz12
              py__pz_ = py__pz_ + Iy21_Iz12
              pz__pz_ = pz__pz_ + Iz22
              px__dxx = px__dxx + Ix23 * w
              py__dxx = py__dxx + Ix13 * Iy21_w
              pz__dxx = pz__dxx + Ix13 * Iz21
              px__dyy = px__dyy + Ix21 * Iy13 * w
              py__dyy = py__dyy + Iy23 * w
              pz__dyy = pz__dyy + Iy13 * Iz21
              px__dzz = px__dzz + Ix21 * Iz13
              py__dzz = py__dzz + Iy21 * Iz13
              pz__dzz = pz__dzz + Iz23 * w
              px__dxy = px__dxy + Ix22 * Iy12_w
              py__dxy = py__dxy + Ix12 * Iy22_w
              pz__dxy = pz__dxy + Ix12 * Iy12_Iz21
              px__dxz = px__dxz + Ix22 * Iz12
              py__dxz = py__dxz + Ix12 * Iy21_Iz12
              pz__dxz = pz__dxz + Ix12 * Iz22
              px__dyz = px__dyz + Ix21_Iz12 * Iy12
              py__dyz = py__dyz + Iy22 * Iz12
              pz__dyz = pz__dyz + Iy12 * Iz22
            end
          end
        end
      end
    end
    rys1.destroy

    DCx = .pos_d(1) - .pos_c(1)
    DCy = .pos_d(2) - .pos_c(2)
    DCz = .pos_d(3) - .pos_c(3)

    Iabf(1,1,1) = px__dxx + DCx * px__px_
    Iabf(2,1,1) = py__dxx + DCx * py__px_
    Iabf(3,1,1) = pz__dxx + DCx * pz__px_
    Iabf(1,2,1) = px__dxy + DCy * px__px_
    Iabf(2,2,1) = py__dxy + DCy * py__px_
    Iabf(3,2,1) = pz__dxy + DCy * pz__px_
    Iabf(1,3,1) = px__dxz + DCz * px__px_
    Iabf(2,3,1) = py__dxz + DCz * py__px_
    Iabf(3,3,1) = pz__dxz + DCz * pz__px_
    Iabf(1,1,2) = px__dxy + DCx * px__py_
    Iabf(2,1,2) = py__dxy + DCx * py__py_
    Iabf(3,1,2) = pz__dxy + DCx * pz__py_
    Iabf(1,2,2) = px__dyy + DCy * px__py_
    Iabf(2,2,2) = py__dyy + DCy * py__py_
    Iabf(3,2,2) = pz__dyy + DCy * pz__py_
    Iabf(1,3,2) = px__dyz + DCz * px__py_
    Iabf(2,3,2) = py__dyz + DCz * py__py_
    Iabf(3,3,2) = pz__dyz + DCz * pz__py_
    Iabf(1,1,3) = px__dxz + DCx * px__pz_
    Iabf(2,1,3) = py__dxz + DCx * py__pz_
    Iabf(3,1,3) = pz__dxz + DCx * pz__pz_
    Iabf(1,2,3) = px__dyz + DCy * px__pz_
    Iabf(2,2,3) = py__dyz + DCy * py__pz_
    Iabf(3,2,3) = pz__dyz + DCy * pz__pz_
    Iabf(1,3,3) = px__dzz + DCz * px__pz_
    Iabf(2,3,3) = py__dzz + DCz * py__pz_
    Iabf(3,3,3) = pz__dzz + DCz * pz__pz_
  end

  make_psps(abcd) ::: private
  ! Makes the (ps|ps) integrals, summed over primitives.
    self :: IN
    abcd :: REALMAT4, OUT
    psps :: REALMAT(3,3)
    if (.ab_n_gaussian_pairs > n_cc_cutoff) then
      .make_psps(psps)
    else
      .make_psps_low_ncc(psps)
    end
    if (.a.l == 1) then
      if (.c.l ==1) then
        abcd(:,1,:,1) = psps ! psps
      else
        abcd(:,1,1,:) = psps ! pssp
      end
    else
      if (.c.l ==1) then
        abcd(1,:,:,1) = psps ! spps
      else
        abcd(1,:,1,:) = psps ! spsp
      end
    end
  end

  make_psps(psps) ::: private
  ! Makes the (ps|ps) integrals, summed over primitives.
  ! Does ps|ps, ps|sp, sp|ps, sp|sp.
    self :: IN
    psps :: REALMAT, OUT
    rys1 :: RYS*
    zeta,eta,xx,normab,zinv,rho,einv,norm,half_zinv :: REAL
    QPx,QPy,QPz,QCx,QCy,QCz,PAx,PAy,PAz,Px,Py,Pz,Qx,Qy,Qz :: REAL
    root,tmp2,tmp3,tmp4,weight,rho_zinv,rho_einv :: REAL
    Ix12,Iy12,Iz12,Ix21,Iy21,Iz21 :: REAL
    psps11,psps12,psps13,psps21,psps22,psps23,psps31,psps32,psps33 :: REAL
    ag,bg,cg,dg,n,j,k :: INT

    rys1.create(2)

    psps11=ZERO; psps12=ZERO; psps13=ZERO
    psps21=ZERO; psps22=ZERO; psps23=ZERO
    psps31=ZERO; psps32=ZERO; psps33=ZERO
    k = 0
    do bg = 1, .b.n_cc
      do ag = 1, .a.n_cc
        k = k + 1
        zeta = .ab_exponent_sum(k)
        zinv = ONE/zeta
        half_zinv = HALF * zinv
        normab = .ab_cc_prefactor(k) * TWOPI5ON2
        Px = .ab_pair_center(1,k)
        Py = .ab_pair_center(2,k)
        Pz = .ab_pair_center(3,k)
        PAx = .ab_center_diff(1,k)
        PAy = .ab_center_diff(2,k)
        PAz = .ab_center_diff(3,k)
        j = 0
        do dg = 1, .d.n_cc
          do cg = 1, .c.n_cc
            j = j + 1
            eta  = .cd_exponent_sum(j)
            einv = ONE/eta
            Qx = .cd_pair_center(1,j)
            Qy = .cd_pair_center(2,j)
            Qz = .cd_pair_center(3,j)
            QCx = .cd_center_diff(1,j)
            QCy = .cd_center_diff(2,j)
            QCz = .cd_center_diff(3,j)
            rho  = zeta * eta / (zeta + eta)
            rho_zinv = rho * zinv
            rho_einv = rho * einv
            !half_rho_einv_zinv = rho_einv * half_zinv
            norm = normab * .cd_cc_prefactor(j) * sqrt(rho)
            QPx  = Qx - Px;   QPy  = Qy - Py;   QPz  = Qz - Pz
            xx   = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
            rys1.get_weights(xx)
            do n=1,2
              root   = rys1.r(n)
              weight = rys1.w(n) * norm
              tmp2 = root * rho_zinv
              tmp3 = root * rho_einv
              !tmp4 = root * half_rho_einv_zinv*weight
              tmp4 = tmp3 * half_zinv*weight
              Ix21 = (PAx + tmp2 * QPx)*weight
              Iy21 = (PAy + tmp2 * QPy)*weight
              Iz21 = (PAz + tmp2 * QPz)*weight
              ! Note that weights are included in the above variables, which
              ! filter through to the others.
              Ix12 = QCx - tmp3 * QPx
              Iy12 = QCy - tmp3 * QPy
              Iz12 = QCz - tmp3 * QPz
              psps11 = psps11 + Ix12 * Ix21 + tmp4 ! = Ix22
              psps12 = psps12 + Ix21 * Iy12
              psps13 = psps13 + Ix21 * Iz12
              psps21 = psps21 + Ix12 * Iy21
              psps22 = psps22 + Iy12 * Iy21 + tmp4 ! = Iy22
              psps23 = psps23 + Iy21 * Iz12
              psps31 = psps31 + Ix12 * Iz21
              psps32 = psps32 + Iy12 * Iz21
              psps33 = psps33 + Iz12 * Iz21 + tmp4 ! = Iz22
            end
          end
        end
      end
    end
    psps(1,1) = psps11
    psps(2,1) = psps21
    psps(3,1) = psps31
    psps(1,2) = psps12
    psps(2,2) = psps22
    psps(3,2) = psps32
    psps(1,3) = psps13
    psps(2,3) = psps23
    psps(3,3) = psps33
    rys1.destroy
  end

  make_psps_low_ncc(psps) ::: private
  ! Makes the (ps|ps) integrals, summed over primitives.
  ! Does ps|ps, ps|sp, sp|ps, sp|sp.
    self :: IN
    psps :: REALMAT, OUT
    rys1 :: RYS*
    zeta,eta,xx,normab,zinv,rho,einv,half_zinv :: REAL
    QPx,QPy,QPz,QCx,QCy,QCz,PAx,PAy,PAz,Px,Py,Pz,Qx,Qy,Qz :: REAL
    root,tmp2,tmp3,tmp4,weight,rho_zinv,rho_einv :: REAL
    Ix12,Iy12,Iz12,Ix21,Iy21,Iz21 :: REAL
    Dx,Dy,Dz,Cx,Cy,Cz,Ctx,Cty,Ctz :: REAL
    d,d_cc,d_r2cd,c :: REAL
    psps11,psps12,psps13,psps21,psps22,psps23,psps31,psps32,psps33 :: REAL
    ag,bg,cg,dg,n,k :: INT

    rys1.create(2)

    psps11=ZERO; psps12=ZERO; psps13=ZERO
    psps21=ZERO; psps22=ZERO; psps23=ZERO
    psps31=ZERO; psps32=ZERO; psps33=ZERO
    Cx = .pos_c(1);  Dx = .pos_d(1)
    Cy = .pos_c(2);  Dy = .pos_d(2)
    Cz = .pos_c(3);  Dz = .pos_d(3)
    if (.c.l > .d.l) then
      Ctx = Cx;  Cty = Cy;  Ctz = Cz
    else
      Ctx = Dx;  Cty = Dy;  Ctz = Dz
    end
    k = 0
    do bg = 1, .b.n_cc
      do ag = 1, .a.n_cc
        k = k + 1
        zeta = .ab_exponent_sum(k)
        zinv = ONE/zeta
        half_zinv = HALF * zinv
        normab = .ab_cc_prefactor(k) * TWOPI5ON2
        Px = .ab_pair_center(1,k)
        Py = .ab_pair_center(2,k)
        Pz = .ab_pair_center(3,k)
        PAx = .ab_center_diff(1,k)
        PAy = .ab_center_diff(2,k)
        PAz = .ab_center_diff(3,k)
        do dg = 1, .d.n_cc
          d      = .d.ex(dg)
          d_cc   = .d.cc(dg)
          d_r2cd = d * .r2cd
          do cg = 1, .c.n_cc
            c    = .c.ex(cg)
            eta  = c + d
            einv = ONE/eta
            Qx = (d*Dx + c*Cx) * einv
            Qy = (d*Dy + c*Cy) * einv
            Qz = (d*Dz + c*Cz) * einv
            QCx = Qx - Ctx
            QCy = Qy - Cty
            QCz = Qz - Ctz
            rho  = zeta * eta / (zeta + eta)
            rho_zinv = rho * zinv
            rho_einv = rho * einv
            QPx  = Qx - Px;   QPy  = Qy - Py;   QPz  = Qz - Pz
            xx   = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
            rys1.get_weights(xx)
            rys1.w(:) = rys1.w(:) * (normab * d_cc * .c.cc(cg) * &
                           einv * sqrt(rho_einv) * exp(-c*d_r2cd*einv))
            do n=1,2
              root   = rys1.r(n)
              weight = rys1.w(n)
              tmp2 = root * rho_zinv
              tmp3 = root * rho_einv
              tmp4 = tmp3 * half_zinv*weight
              Ix21 = (PAx + tmp2 * QPx)*weight
              Iy21 = (PAy + tmp2 * QPy)*weight
              Iz21 = (PAz + tmp2 * QPz)*weight
              ! Note that weights are included in the above variables, which
              ! filter through to the others.
              Ix12 = QCx - tmp3 * QPx
              Iy12 = QCy - tmp3 * QPy
              Iz12 = QCz - tmp3 * QPz
              psps11 = psps11 + Ix12 * Ix21 + tmp4 ! = Ix22
              psps12 = psps12 + Ix21 * Iy12
              psps13 = psps13 + Ix21 * Iz12
              psps21 = psps21 + Ix12 * Iy21
              psps22 = psps22 + Iy12 * Iy21 + tmp4 ! = Iy22
              psps23 = psps23 + Iy21 * Iz12
              psps31 = psps31 + Ix12 * Iz21
              psps32 = psps32 + Iy12 * Iz21
              psps33 = psps33 + Iz12 * Iz21 + tmp4 ! = Iz22
            end
          end
        end
      end
    end
    psps(1,1) = psps11
    psps(2,1) = psps21
    psps(3,1) = psps31
    psps(1,2) = psps12
    psps(2,2) = psps22
    psps(3,2) = psps32
    psps(1,3) = psps13
    psps(2,3) = psps23
    psps(3,3) = psps33
    rys1.destroy
  end

  make_abss(abcd) ::: private
  ! Makes the (ab|ss) integrals, summed over primitives.
    self :: IN
    abcd :: REALMAT4, OUT
    abss :: REALMAT*
    abss.create(size(abcd,1),size(abcd,2))
    .make_abss(abss)
    abcd(:,:,1,1) = abss(:,:)
    abss.destroy
  end

  make_abss(ab) ::: private
  ! Makes the (ab|ss) integrals, summed over primitives.
    self :: IN
    ab :: REALMAT, OUT
    esss :: REALVEC*
    sh :: SHELL2*
    eub,i,j,k,imax :: INT
    eub = .ab_l_sum.n_comp_sum - (.ab_l_max-1).n_comp_sum
    esss.create(eub)
    if (.ab_n_gaussian_pairs > n_cc_cutoff) then
      .make_esss(esss)
    else
      .make_esss_low_ncc(esss)
    end
    sh.create(.a,.b,.pos_a,.pos_b)
    sh.transfer(esss,ab)
    if (.ab_l_sum > 1) then
      k = 0
      imax = .a.n_comp
      do j=1,.b.n_comp
        do i=1,imax
          k = k + 1
          ab(i,j) = ab(i,j) * .ab_normalising_factors(k)
        end
      end
    end
    sh.destroy
    esss.destroy
  end

  make_asss(asss) ::: private
  ! Makes the (as|ss) or (sb|ss) integrals, summed over primitives.
    asss :: REALVEC, OUT
    if (.ab_n_gaussian_pairs > n_cc_cutoff) then
      .make_esss(asss)
    else
      .make_esss_low_ncc(asss)
    end
    if (.ab_l_sum > 1) asss = asss * .ab_normalising_factors
  end

  make_esss(esss) ::: private
  ! Makes the (es|ss) integrals, summed over primitives.
    self :: IN
    esss :: REALVEC, OUT
    Izz :: REALVEC*
    Ix,Iy,Iz,Iyz :: REALMAT*
    e_x,e_y,e_z,ii_ivec :: INTVEC*
    rys1 :: RYS*
    zeta,zinv,eta,rho,xx,normab,rho_zinv,half_zinv :: REAL
    QPx,QPy,QPz,PAx,PAy,PAz,Qx,Qy,Qz,Px,Py,Pz :: REAL
    rzt,ce1,rzthze,Ix2,Iy2,Iz2,Ix3,Iy3,Iz3,wt :: REAL
    Ixe,Ixe1,Iye,Iye1,Ize,Ize1,Ixep1,Iyep1,Izep1 :: REAL
    ag,bg,cg,dg,nroots,eub,dim :: INT
    ep1,n,dim1,y,z,ii,e,j,k :: INT
    apply_rms :: BIN

    dim = .ab_l_sum+1
    dim1 = .ab_l_sum+2
    eub = .ab_l_sum.n_comp_sum - (.ab_l_max-1).n_comp_sum

    nroots = (dim1) / 2
    rys1.create(nroots)
    Ix.create(nroots,dim)
    Iy.create(nroots,dim)
    Iz.create(nroots,dim)
    Iyz.create(nroots,dim*dim1/2)

    apply_rms = .ab_l_min < ERI_rms_min_l
    e_x => .ab_form_3dints_x_indices
    e_y => .ab_form_3dints_y_indices
    e_z => .ab_form_3dints_z_indices
    if (apply_rms) ii_ivec => .ab_form_3dints_yz_rms_indices

    esss = ZERO
    k = 0
    do bg = 1, .b.n_cc
      do ag = 1, .a.n_cc
        k = k + 1
        zeta = .ab_exponent_sum(k)
        zinv = ONE/zeta
        half_zinv = HALF * zinv
        normab = .ab_cc_prefactor(k) * TWOPI5ON2
        Px = .ab_pair_center(1,k)
        Py = .ab_pair_center(2,k)
        Pz = .ab_pair_center(3,k)
        PAx = .ab_center_diff(1,k)
        PAy = .ab_center_diff(2,k)
        PAz = .ab_center_diff(3,k)
        j = 0
        do dg = 1, .d.n_cc
          do cg = 1, .c.n_cc
            j = j + 1
            eta  = .cd_exponent_sum(j)
            Qx = .cd_pair_center(1,j)
            Qy = .cd_pair_center(2,j)
            Qz = .cd_pair_center(3,j)
            rho  = zeta * eta / (zeta + eta)
            rho_zinv = rho * zinv
            QPx  = Qx - Px;   QPy  = Qy - Py;   QPz  = Qz - Pz
            xx   = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
            rys1.get_weights(xx)
            rys1.w = rys1.w * normab * .cd_cc_prefactor(j) * sqrt(rho)

            ! Form the 2 dimensional integrals
            do n=1,nroots
              wt = rys1.w(n)
              rzt      = rys1.r(n) * rho_zinv
              rzthze   = (ONE - rzt) * half_zinv
              Ix2 = PAx + rzt * QPx
              Iy2 = PAy + rzt * QPy
              Iz2 = PAz + rzt * QPz
              Ix3 = Ix2 * Ix2 + rzthze
              Iy3 = Iy2 * Iy2 + rzthze
              Iz3 = Iz2 * Iz2 + rzthze
              Ix(n,1) = ONE; Iy(n,1) = ONE; Iz(n,1) = wt
              Ix(n,2) = Ix2; Iy(n,2) = Iy2; Iz(n,2) = Iz2 * wt
              Ix(n,3) = Ix3; Iy(n,3) = Iy3; Iz(n,3) = Iz3 * wt

              if (.ab_l_sum > 2) then
                Ixe = Ix3;    Iye = Iy3;    Ize = Iz3
                Ixe1 = Ix2;   Iye1 = Iy2;   Ize1 = Iz2
                ce1 = rzthze
                do ep1 = 4, .ab_l_sum+1
                  ce1 = ce1 + rzthze
                  Ixep1 = Ix2 * Ixe + ce1 * Ixe1
                  Iyep1 = Iy2 * Iye + ce1 * Iye1
                  Izep1 = Iz2 * Ize + ce1 * Ize1
                  Ix(n,ep1) = Ixep1;   Iy(n,ep1) = Iyep1;   Iz(n,ep1) = Izep1 * wt
                  Ixe1 = Ixe;   Iye1 = Iye;   Ize1 = Ize
                  Ixe = Ixep1;  Iye = Iyep1;  Ize = Izep1
                end
              end
            end

            if (apply_rms) then
              ! Apply the reduced multiplication scheme.
              ii = 0
              do z=1,dim
                Izz => Iz(:,z)
                do y=1,dim1-z
                  ii = ii + 1
                  Iyz(:,ii) = Izz * Iy(:,y)
                end
              end
              do e=1,eub
                esss(e) = esss(e) + sum(Ix(:,e_x(e)) * Iyz(:,ii_ivec(e)))
              end
            else
              do e=1,eub
                esss(e) = esss(e) + sum(Ix(:,e_x(e)) * Iy(:,e_y(e)) * Iz(:,e_z(e)))
              end
            end
          end
        end
      end
    end
    Iyz.destroy
    Iz.destroy
    Iy.destroy
    Ix.destroy
    rys1.destroy
  end

  make_esss_low_ncc(esss) ::: private
  ! Makes the (es|ss) integrals, summed over primitives.
    self :: IN
    esss :: REALVEC, OUT
    Izz :: REALVEC*
    Ix,Iy,Iz,Iyz :: REALMAT*
    e_x,e_y,e_z,ii_ivec :: INTVEC*
    rys1 :: RYS*
    zeta,zinv,eta,rho,xx,normab,rho_zinv,half_zinv,einv,rho_einv :: REAL
    QPx,QPy,QPz,PAx,PAy,PAz,Qx,Qy,Qz,Px,Py,Pz :: REAL
    rzt,ce1,rzthze,Ix2,Iy2,Iz2,Ix3,Iy3,Iz3,wt :: REAL
    Ixe,Ixe1,Iye,Iye1,Ize,Ize1,Ixep1,Iyep1,Izep1 :: REAL
    Dx,Dy,Dz,Cx,Cy,Cz :: REAL
    d,d_cc,d_r2cd,c :: REAL
    ag,bg,cg,dg,nroots,eub,dim :: INT
    ep1,n,dim1,y,z,ii,e,k :: INT
    apply_rms :: BIN

    dim = .ab_l_sum+1
    dim1 = .ab_l_sum+2
    eub = .ab_l_sum.n_comp_sum - (.ab_l_max-1).n_comp_sum
    Cx = .pos_c(1);  Dx = .pos_d(1)
    Cy = .pos_c(2);  Dy = .pos_d(2)
    Cz = .pos_c(3);  Dz = .pos_d(3)

    nroots = (dim1) / 2
    rys1.create(nroots)
    Ix.create(nroots,dim)
    Iy.create(nroots,dim)
    Iz.create(nroots,dim)
    Iyz.create(nroots,dim*dim1/2)

    apply_rms = .ab_l_min < ERI_rms_min_l
    e_x => .ab_form_3dints_x_indices
    e_y => .ab_form_3dints_y_indices
    e_z => .ab_form_3dints_z_indices
    if (apply_rms) ii_ivec => .ab_form_3dints_yz_rms_indices

    esss = ZERO
    k = 0
    do bg = 1, .b.n_cc
      do ag = 1, .a.n_cc
        k = k + 1
        zeta = .ab_exponent_sum(k)
        zinv = ONE/zeta
        half_zinv = HALF * zinv
        normab = .ab_cc_prefactor(k) * TWOPI5ON2
        Px = .ab_pair_center(1,k)
        Py = .ab_pair_center(2,k)
        Pz = .ab_pair_center(3,k)
        PAx = .ab_center_diff(1,k)
        PAy = .ab_center_diff(2,k)
        PAz = .ab_center_diff(3,k)
        do dg = 1, .d.n_cc
          d      = .d.ex(dg)
          d_cc   = .d.cc(dg)
          d_r2cd = d * .r2cd
          do cg = 1, .c.n_cc
            c    = .c.ex(cg)
            eta  = c + d
            einv = ONE/eta
            Qx = (d*Dx + c*Cx) * einv
            Qy = (d*Dy + c*Cy) * einv
            Qz = (d*Dz + c*Cz) * einv
            rho  = zeta * eta / (zeta + eta)
            rho_zinv = rho * zinv
            rho_einv = rho * einv
            QPx  = Qx - Px;   QPy  = Qy - Py;   QPz  = Qz - Pz
            xx   = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
            rys1.get_weights(xx)
            rys1.w(:) = rys1.w(:) * (normab * d_cc * .c.cc(cg) * &
                           einv * sqrt(rho_einv) * exp(-c*d_r2cd*einv))

            ! Form the 2 dimensional integrals
            do n=1,nroots
              wt = rys1.w(n)
              rzt      = rys1.r(n) * rho_zinv
              rzthze   = (ONE - rzt) * half_zinv
              Ix2 = PAx + rzt * QPx
              Iy2 = PAy + rzt * QPy
              Iz2 = PAz + rzt * QPz
              Ix3 = Ix2 * Ix2 + rzthze
              Iy3 = Iy2 * Iy2 + rzthze
              Iz3 = Iz2 * Iz2 + rzthze
              Ix(n,1) = ONE; Iy(n,1) = ONE; Iz(n,1) = wt
              Ix(n,2) = Ix2; Iy(n,2) = Iy2; Iz(n,2) = Iz2 * wt
              Ix(n,3) = Ix3; Iy(n,3) = Iy3; Iz(n,3) = Iz3 * wt

              if (.ab_l_sum > 2) then
                Ixe = Ix3;    Iye = Iy3;    Ize = Iz3
                Ixe1 = Ix2;   Iye1 = Iy2;   Ize1 = Iz2
                ce1 = rzthze
                do ep1 = 4, .ab_l_sum+1
                  ce1 = ce1 + rzthze
                  Ixep1 = Ix2 * Ixe + ce1 * Ixe1
                  Iyep1 = Iy2 * Iye + ce1 * Iye1
                  Izep1 = Iz2 * Ize + ce1 * Ize1
                  Ix(n,ep1) = Ixep1;   Iy(n,ep1) = Iyep1;   Iz(n,ep1) = Izep1 * wt
                  Ixe1 = Ixe;   Iye1 = Iye;   Ize1 = Ize
                  Ixe = Ixep1;  Iye = Iyep1;  Ize = Izep1
                end
              end
            end

            if (apply_rms) then
              ! Apply the reduced multiplication scheme.
              ii = 0
              do z=1,dim
                Izz => Iz(:,z)
                do y=1,dim1-z
                  ii = ii + 1
                  Iyz(:,ii) = Izz * Iy(:,y)
                end
              end
              do e=1,eub
                esss(e) = esss(e) + sum(Ix(:,e_x(e)) * Iyz(:,ii_ivec(e)))
              end
            else
              do e=1,eub
                esss(e) = esss(e) + sum(Ix(:,e_x(e)) * Iy(:,e_y(e)) * Iz(:,e_z(e)))
              end
            end
          end
        end
      end
    end
    Iyz.destroy
    Iz.destroy
    Iy.destroy
    Ix.destroy
    rys1.destroy
  end

  make_sscd(abcd) ::: private
  ! Makes the (ss|cd) integrals, summed over primitives.
    self :: IN
    abcd :: REALMAT4, OUT
    sscd :: REALMAT*
    sscd.create(size(abcd,3),size(abcd,4))
    .make_sscd(sscd)
    abcd(1,1,:,:) = sscd(:,:)
    sscd.destroy
  end

  make_sscd(sscd) ::: private
  ! Makes the (ss|cd) integrals, summed over primitives.
    self :: IN
    sscd :: REALMAT, OUT
    ssfs :: REALVEC*
    sh :: SHELL2*
    fub,i,j,k,imax :: INT
    fub = .cd_l_sum.n_comp_sum - (.cd_l_max-1).n_comp_sum
    ssfs.create(fub)
    if (.ab_n_gaussian_pairs > n_cc_cutoff) then
      .make_ssfs(ssfs)
    else
      .make_ssfs_low_ncc(ssfs)
    end
    sh.create(.c,.d,.pos_c,.pos_d)
    sh.transfer(ssfs,sscd)
    if (.cd_l_sum > 1) then
      k = 0
      imax = .c.n_comp
      do j=1,.d.n_comp
        do i=1,imax
          k = k + 1
          sscd(i,j) = sscd(i,j) * .cd_normalising_factors(k)
        end
      end
    end
    sh.destroy
    ssfs.destroy
  end

  make_sscs(sscs) ::: private
  ! Makes the (ss|cs) or (ss|sd) integrals, summed over primitives.
    self :: IN
    sscs :: REALVEC, OUT
    if (.ab_n_gaussian_pairs > n_cc_cutoff) then
      .make_ssfs(sscs)
    else
      .make_ssfs_low_ncc(sscs)
    end
    if (.cd_l_sum > 1) sscs = sscs * .cd_normalising_factors
  end

  make_ssfs(ssfs) ::: private
  ! Makes the (ss|cd) integrals, summed over primitives.
    self :: IN
    ssfs :: REALVEC, OUT
    Izz :: REALVEC*
    Ix,Iy,Iz,Iyz :: REALMAT*
    rys1 :: RYS*
    f_x,f_y,f_z,ii_ivec :: INTVEC*
    zeta,eta,einv,rho,xx :: REAL
    normab,rho_einv,half_einv :: REAL
    QPx,QPy,QPz,QCx,QCy,QCz,Qx,Qy,Qz,Px,Py,Pz :: REAL
    Ix2,Iy2,Iz2,Ix3,Iy3,Iz3 :: REAL
    Ixf,Ixf1,Iyf,Iyf1,Izf,Izf1,Ixfp1,Iyfp1,Izfp1 :: REAL
    ret,cf1,rethen,wt :: REAL
    ag,bg,cg,dg,nroots,fub,f,y,z :: INT
    fp1,n,ii,dim0,dim1,j,k :: INT
    apply_rms :: BIN

    dim0 = .cd_l_sum+1
    dim1 = .cd_l_sum+2
    fub = .cd_l_sum.n_comp_sum - (.cd_l_max-1).n_comp_sum

    nroots = dim1/2
    rys1.create(nroots)
    Ix.create(nroots,dim0)
    Iy.create(nroots,dim0)
    Iz.create(nroots,dim0)
    Iyz.create(nroots,dim0*dim1/2)

    apply_rms = .cd_l_min < ERI_rms_min_l
    f_x => .cd_form_3dints_x_indices
    f_y => .cd_form_3dints_y_indices
    f_z => .cd_form_3dints_z_indices
    if (apply_rms) ii_ivec => .cd_form_3dints_yz_rms_indices

    ssfs=ZERO
    k = 0
    do bg = 1, .b.n_cc
      do ag = 1, .a.n_cc
        k = k + 1
        zeta = .ab_exponent_sum(k)
        normab = .ab_cc_prefactor(k) * TWOPI5ON2
        Px = .ab_pair_center(1,k)
        Py = .ab_pair_center(2,k)
        Pz = .ab_pair_center(3,k)
        j = 0
        do dg = 1, .d.n_cc
          do cg = 1, .c.n_cc
            j = j + 1
            eta  = .cd_exponent_sum(j)
            einv = ONE/eta
            Qx = .cd_pair_center(1,j)
            Qy = .cd_pair_center(2,j)
            Qz = .cd_pair_center(3,j)
            QCx = .cd_center_diff(1,j)
            QCy = .cd_center_diff(2,j)
            QCz = .cd_center_diff(3,j)
            rho  = zeta * eta / (zeta + eta)
            rho_einv = rho * einv
            QPx  = Qx - Px;   QPy  = Qy - Py;   QPz  = Qz - Pz
            xx   = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
            rys1.get_weights(xx)
            rys1.w = rys1.w * normab * .cd_cc_prefactor(j) * sqrt(rho)
            half_einv = HALF * einv

            ! Form the 2 dimensional integrals.
            do n=1,nroots
              ret     = rys1.r(n) * rho_einv
              rethen  = (ONE - ret) * half_einv
              Ix2 = QCx - ret * QPx
              Iy2 = QCy - ret * QPy
              Iz2 = QCz - ret * QPz
              Ix3 = Ix2 * Ix2 + rethen
              Iy3 = Iy2 * Iy2 + rethen
              Iz3 = Iz2 * Iz2 + rethen
              wt = rys1.w(n)

              Ix(n,1) = ONE; Iy(n,1) = ONE; Iz(n,1) = wt
              Ix(n,2) = Ix2; Iy(n,2) = Iy2; Iz(n,2) = Iz2 * wt
              Ix(n,3) = Ix3; Iy(n,3) = Iy3; Iz(n,3) = Iz3 * wt

              if (.cd_l_sum > 2) then
                Ixf = Ix3;    Iyf = Iy3;    Izf = Iz3
                Ixf1 = Ix2;   Iyf1 = Iy2;   Izf1 = Iz2
                cf1 = rethen
                do fp1 = 4, .cd_l_sum+1
                  cf1 = cf1+rethen
                  !cf1 = (fp1-2) * rethen
                  Ixfp1 = Ix2 * Ixf + cf1 * Ixf1
                  Iyfp1 = Iy2 * Iyf + cf1 * Iyf1
                  Izfp1 = Iz2 * Izf + cf1 * Izf1
                  Ix(n,fp1) = Ixfp1;   Iy(n,fp1) = Iyfp1;   Iz(n,fp1) = Izfp1 * wt
                  Ixf1 = Ixf;   Iyf1 = Iyf;   Izf1 = Izf
                  Ixf = Ixfp1;  Iyf = Iyfp1;  Izf = Izfp1
                end
              end
            end

            if (apply_rms) then
              ! Apply the reduced multiplication scheme.
              ii = 0
              do z=1,dim0
                Izz => Iz(:,z)
                do y=1,dim1-z
                  ii = ii + 1
                  Iyz(:,ii) = Izz * Iy(:,y)
                end
              end
              do f=1,fub
                ssfs(f) = ssfs(f) + sum(Ix(:,f_x(f)) * Iyz(:,ii_ivec(f)))
              end
            else
              do f=1,fub
                ssfs(f) = ssfs(f) + sum(Ix(:,f_x(f)) * Iy(:,f_y(f)) * Iz(:,f_z(f)))
              end
            end
          end
        end
      end
    end
    Iyz.destroy
    Iz.destroy
    Iy.destroy
    Ix.destroy
    rys1.destroy
  end

  make_ssfs_low_ncc(ssfs) ::: private
  ! Makes the (ss|cd) integrals, summed over primitives.
    self :: IN
    ssfs :: REALVEC, OUT
    Izz :: REALVEC*
    Ix,Iy,Iz,Iyz :: REALMAT*
    rys1 :: RYS*
    f_x,f_y,f_z,ii_ivec :: INTVEC*
    zeta,eta,einv,rho,xx :: REAL
    normab,rho_einv,half_einv :: REAL
    QPx,QPy,QPz,QCx,QCy,QCz,Qx,Qy,Qz,Px,Py,Pz :: REAL
    Ix2,Iy2,Iz2,Ix3,Iy3,Iz3 :: REAL
    Ixf,Ixf1,Iyf,Iyf1,Izf,Izf1,Ixfp1,Iyfp1,Izfp1 :: REAL
    ret,cf1,rethen,wt :: REAL
    Dx,Dy,Dz,Cx,Cy,Cz,Ctx,Cty,Ctz :: REAL
    d,d_cc,d_r2cd,c :: REAL
    ag,bg,cg,dg,nroots,fub,f,y,z :: INT
    fp1,n,ii,dim0,dim1,k :: INT
    apply_rms :: BIN

    dim0 = .cd_l_sum+1
    dim1 = .cd_l_sum+2
    fub = .cd_l_sum.n_comp_sum - (.cd_l_max-1).n_comp_sum

    nroots = dim1/2
    rys1.create(nroots)
    Ix.create(nroots,dim0)
    Iy.create(nroots,dim0)
    Iz.create(nroots,dim0)
    Iyz.create(nroots,dim0*dim1/2)
    Cx = .pos_c(1);  Dx = .pos_d(1)
    Cy = .pos_c(2);  Dy = .pos_d(2)
    Cz = .pos_c(3);  Dz = .pos_d(3)
    if (.c.l > .d.l) then
      Ctx = Cx;  Cty = Cy;  Ctz = Cz
    else
      Ctx = Dx;  Cty = Dy;  Ctz = Dz
    end

    apply_rms = .cd_l_min < ERI_rms_min_l
    f_x => .cd_form_3dints_x_indices
    f_y => .cd_form_3dints_y_indices
    f_z => .cd_form_3dints_z_indices
    if (apply_rms) ii_ivec => .cd_form_3dints_yz_rms_indices

    ssfs=ZERO
    k = 0
    do bg = 1, .b.n_cc
      do ag = 1, .a.n_cc
        k = k + 1
        zeta = .ab_exponent_sum(k)
        normab = .ab_cc_prefactor(k) * TWOPI5ON2
        Px = .ab_pair_center(1,k)
        Py = .ab_pair_center(2,k)
        Pz = .ab_pair_center(3,k)
        do dg = 1, .d.n_cc
          d      = .d.ex(dg)
          d_cc   = .d.cc(dg)
          d_r2cd = d * .r2cd
          do cg = 1, .c.n_cc
            c    = .c.ex(cg)
            eta  = c + d
            einv = ONE/eta
            Qx = (d*Dx + c*Cx) * einv
            Qy = (d*Dy + c*Cy) * einv
            Qz = (d*Dz + c*Cz) * einv
            QCx = Qx - Ctx
            QCy = Qy - Cty
            QCz = Qz - Ctz
            rho  = zeta * eta / (zeta + eta)
            rho_einv = rho * einv
            half_einv = HALF * einv
            QPx  = Qx - Px;   QPy  = Qy - Py;   QPz  = Qz - Pz
            xx   = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
            rys1.get_weights(xx)
            rys1.w(:) = rys1.w(:) * (normab * d_cc * .c.cc(cg) * &
                           einv * sqrt(rho_einv) * exp(-c*d_r2cd*einv))

            ! Form the 2 dimensional integrals.
            do n=1,nroots
              ret     = rys1.r(n) * rho_einv
              rethen  = (ONE - ret) * half_einv
              Ix2 = QCx - ret * QPx
              Iy2 = QCy - ret * QPy
              Iz2 = QCz - ret * QPz
              Ix3 = Ix2 * Ix2 + rethen
              Iy3 = Iy2 * Iy2 + rethen
              Iz3 = Iz2 * Iz2 + rethen
              wt = rys1.w(n)

              Ix(n,1) = ONE; Iy(n,1) = ONE; Iz(n,1) = wt
              Ix(n,2) = Ix2; Iy(n,2) = Iy2; Iz(n,2) = Iz2 * wt
              Ix(n,3) = Ix3; Iy(n,3) = Iy3; Iz(n,3) = Iz3 * wt

              if (.cd_l_sum > 2) then
                Ixf = Ix3;    Iyf = Iy3;    Izf = Iz3
                Ixf1 = Ix2;   Iyf1 = Iy2;   Izf1 = Iz2
                cf1 = rethen
                do fp1 = 4, .cd_l_sum+1
                  cf1 = cf1+rethen
                  !cf1 = (fp1-2) * rethen
                  Ixfp1 = Ix2 * Ixf + cf1 * Ixf1
                  Iyfp1 = Iy2 * Iyf + cf1 * Iyf1
                  Izfp1 = Iz2 * Izf + cf1 * Izf1
                  Ix(n,fp1) = Ixfp1;   Iy(n,fp1) = Iyfp1;   Iz(n,fp1) = Izfp1 * wt
                  Ixf1 = Ixf;   Iyf1 = Iyf;   Izf1 = Izf
                  Ixf = Ixfp1;  Iyf = Iyfp1;  Izf = Izfp1
                end
              end
            end

            if (apply_rms) then
              ! Apply the reduced multiplication scheme.
              ii = 0
              do z=1,dim0
                Izz => Iz(:,z)
                do y=1,dim1-z
                  ii = ii + 1
                  Iyz(:,ii) = Izz * Iy(:,y)
                end
              end
              do f=1,fub
                ssfs(f) = ssfs(f) + sum(Ix(:,f_x(f)) * Iyz(:,ii_ivec(f)))
              end
            else
              do f=1,fub
                ssfs(f) = ssfs(f) + sum(Ix(:,f_x(f)) * Iy(:,f_y(f)) * Iz(:,f_z(f)))
              end
            end
          end
        end
      end
    end
    Iyz.destroy
    Iz.destroy
    Iy.destroy
    Ix.destroy
    rys1.destroy
  end

  make_ppss(abcd) ::: private
  ! Creates the initial (pp|ss) integrals, summed over primitives.
    self :: IN
    abcd :: REALMAT4, OUT
    abss :: REALMAT(3,3)
    if (.ab_n_gaussian_pairs > n_cc_cutoff) then
      .make_ppss(abss)
    else
      .make_ppss_low_ncc(abss)
    end
    abcd(:,:,1,1) = abss(:,:)
  end

  make_ppss(abss) ::: private
  ! Creates the initial (pp|ss) integrals, summed over primitives.
    self :: IN
    abss :: REALMAT, OUT
    rys1 :: RYS*
    zeta,zinv,eta,rho,xx :: REAL
    normab,norm,rho_zinv,half_zinv :: REAL
    QPx,QPy,QPz,PAx,PAy,PAz :: REAL
    Qx,Qy,Qz,Px,Py,Pz :: REAL
    rzt,rzthze :: REAL
    Ix2,Iy2,Iz2,Ix3,Iy3,Iz3,Ix2_w,Iy2_w,Iz2_w,w :: REAL
    px_s,py_s,pz_s,dxx_s,dyy_s,dzz_s,dxy_s,dxz_s,dyz_s :: REAL
    BAx,BAy,BAz :: REAL
    ag,bg,cg,dg,n,j,k :: INT

    rys1.create(2)              ! nroots = 2
    px_s  = ZERO; py_s  = ZERO; pz_s  = ZERO
    dxx_s = ZERO; dyy_s = ZERO; dzz_s = ZERO
    dxy_s = ZERO; dxz_s = ZERO; dyz_s = ZERO
    k = 0
    do bg = 1, .b.n_cc
      do ag = 1, .a.n_cc
        k = k + 1
        zeta = .ab_exponent_sum(k)
        zinv = ONE/zeta
        half_zinv = HALF * zinv
        normab = .ab_cc_prefactor(k) * TWOPI5ON2
        Px = .ab_pair_center(1,k)
        Py = .ab_pair_center(2,k)
        Pz = .ab_pair_center(3,k)
        PAx = .ab_center_diff(1,k)
        PAy = .ab_center_diff(2,k)
        PAz = .ab_center_diff(3,k)
        j = 0
        do dg = 1, .d.n_cc
          do cg = 1, .c.n_cc
            j = j + 1
            eta  = .cd_exponent_sum(j)
            Qx = .cd_pair_center(1,j)
            Qy = .cd_pair_center(2,j)
            Qz = .cd_pair_center(3,j)
            rho  = zeta * eta / (zeta + eta)
            rho_zinv = rho * zinv
            norm = normab * .cd_cc_prefactor(j) * sqrt(rho)
            QPx  = Qx - Px;   QPy  = Qy - Py;   QPz  = Qz - Pz
            xx   = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
            rys1.get_weights(xx)
            rys1.w = rys1.w * norm
            do n=1,2
              rzt      = rys1.r(n) * rho_zinv
              w        = rys1.w(n)
              rzthze   = (ONE - rzt) * half_zinv * w
              Ix2 = PAx + rzt * QPx
              Iy2 = PAy + rzt * QPy
              Iz2 = PAz + rzt * QPz
              Iz2_w = Iz2 * w
              Iy2_w = Iy2 * w
              Ix2_w = Ix2 * w
              Ix3 = Ix2 * Ix2_w + rzthze
              Iy3 = Iy2 * Iy2_w + rzthze
              Iz3 = Iz2 * Iz2_w + rzthze

              px_s  = px_s  + Ix2_w
              py_s  = py_s  + Iy2_w
              pz_s  = pz_s  + Iz2_w
              dxx_s = dxx_s + Ix3
              dyy_s = dyy_s + Iy3
              dzz_s = dzz_s + Iz3
              dxy_s = dxy_s + Ix2 * Iy2_w
              dxz_s = dxz_s + Ix2 * Iz2_w
              dyz_s = dyz_s + Iy2 * Iz2_w
            end
          end
        end
      end
    end
    rys1.destroy

    ! Transfer equation.
    BAx = .pos_b(1) - .pos_a(1)
    BAy = .pos_b(2) - .pos_a(2)
    BAz = .pos_b(3) - .pos_a(3)
    abss(1,1) = dxx_s + BAx * px_s
    abss(1,2) = dxy_s + BAx * py_s
    abss(1,3) = dxz_s + BAx * pz_s
    abss(2,1) = dxy_s + BAy * px_s
    abss(2,2) = dyy_s + BAy * py_s
    abss(2,3) = dyz_s + BAy * pz_s
    abss(3,1) = dxz_s + BAz * px_s
    abss(3,2) = dyz_s + BAz * py_s
    abss(3,3) = dzz_s + BAz * pz_s
  end

  make_ppss_low_ncc(abss) ::: private
  ! Creates the initial (pp|ss) integrals, summed over primitives.
    self :: IN
    abss :: REALMAT, OUT
    rys1 :: RYS*
    c,d,zeta,zinv,eta,einv,rho,xx :: REAL
    normab,rho_zinv,half_zinv,rho_einv :: REAL
    QPx,QPy,QPz,PAx,PAy,PAz :: REAL
    Qx,Qy,Qz,Px,Py,Pz :: REAL
    rzt,rzthze :: REAL
    Dx,Dy,Dz,Cx,Cy,Cz :: REAL
    d_cc,d_r2cd :: REAL
    Ix2,Iy2,Iz2,Ix3,Iy3,Iz3,Ix2_w,Iy2_w,Iz2_w,w :: REAL
    px_s,py_s,pz_s,dxx_s,dyy_s,dzz_s,dxy_s,dxz_s,dyz_s :: REAL
    BAx,BAy,BAz :: REAL
    ag,bg,cg,dg,n,k :: INT

    rys1.create(2)              ! nroots = 2
    px_s  = ZERO; py_s  = ZERO; pz_s  = ZERO
    dxx_s = ZERO; dyy_s = ZERO; dzz_s = ZERO
    dxy_s = ZERO; dxz_s = ZERO; dyz_s = ZERO
    Cx = .pos_c(1);  Dx = .pos_d(1)
    Cy = .pos_c(2);  Dy = .pos_d(2)
    Cz = .pos_c(3);  Dz = .pos_d(3)
    k = 0
    do bg = 1, .b.n_cc
      do ag = 1, .a.n_cc
        k = k + 1
        zeta = .ab_exponent_sum(k)
        zinv = ONE/zeta
        half_zinv = HALF * zinv
        normab = .ab_cc_prefactor(k) * TWOPI5ON2
        Px = .ab_pair_center(1,k)
        Py = .ab_pair_center(2,k)
        Pz = .ab_pair_center(3,k)
        PAx = .ab_center_diff(1,k)
        PAy = .ab_center_diff(2,k)
        PAz = .ab_center_diff(3,k)
        do dg = 1, .d.n_cc
          d      = .d.ex(dg)
          d_cc   = .d.cc(dg)
          d_r2cd = d * .r2cd
          do cg = 1, .c.n_cc
            c    = .c.ex(cg)
            eta  = c + d
            einv = ONE/eta
            Qx = (d*Dx + c*Cx) * einv
            Qy = (d*Dy + c*Cy) * einv
            Qz = (d*Dz + c*Cz) * einv
            rho  = zeta * eta / (zeta + eta)
            rho_zinv = rho * zinv
            rho_einv = rho * einv
            QPx  = Qx - Px;   QPy  = Qy - Py;   QPz  = Qz - Pz
            xx   = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
            rys1.get_weights(xx)
            rys1.w(:) = rys1.w(:) * (normab * d_cc * .c.cc(cg) * &
                           einv * sqrt(rho_einv) * exp(-c*d_r2cd*einv))
            do n=1,2
              rzt      = rys1.r(n) * rho_zinv
              w        = rys1.w(n)
              rzthze   = (ONE - rzt) * half_zinv * w
              Ix2 = PAx + rzt * QPx
              Iy2 = PAy + rzt * QPy
              Iz2 = PAz + rzt * QPz
              Iz2_w = Iz2 * w
              Iy2_w = Iy2 * w
              Ix2_w = Ix2 * w
              Ix3 = Ix2 * Ix2_w + rzthze
              Iy3 = Iy2 * Iy2_w + rzthze
              Iz3 = Iz2 * Iz2_w + rzthze

              px_s  = px_s  + Ix2_w
              py_s  = py_s  + Iy2_w
              pz_s  = pz_s  + Iz2_w
              dxx_s = dxx_s + Ix3
              dyy_s = dyy_s + Iy3
              dzz_s = dzz_s + Iz3
              dxy_s = dxy_s + Ix2 * Iy2_w
              dxz_s = dxz_s + Ix2 * Iz2_w
              dyz_s = dyz_s + Iy2 * Iz2_w
            end
          end
        end
      end
    end
    rys1.destroy

    ! Transfer equation.
    BAx = .pos_b(1) - .pos_a(1)
    BAy = .pos_b(2) - .pos_a(2)
    BAz = .pos_b(3) - .pos_a(3)
    abss(1,1) = dxx_s + BAx * px_s
    abss(1,2) = dxy_s + BAx * py_s
    abss(1,3) = dxz_s + BAx * pz_s
    abss(2,1) = dxy_s + BAy * px_s
    abss(2,2) = dyy_s + BAy * py_s
    abss(2,3) = dyz_s + BAy * pz_s
    abss(3,1) = dxz_s + BAz * px_s
    abss(3,2) = dyz_s + BAz * py_s
    abss(3,3) = dzz_s + BAz * pz_s
  end

  make_sspp(abcd) ::: private
  ! Creates the (ss|pp) integrals, summed over primitives.
    self :: IN
    abcd :: REALMAT4, OUT
    sscd :: REALMAT(3,3)
    if (.ab_n_gaussian_pairs > n_cc_cutoff) then
      .make_sspp(sscd)
    else
      .make_sspp_low_ncc(sscd)
    end
    abcd(1,1,:,:) = sscd(:,:)
  end

  make_sspp(sscd) ::: private
  ! Creates the (ss|pp) integrals, summed over primitives.
    self :: IN
    sscd :: REALMAT, OUT
    rys1 :: RYS*
    zeta,eta,einv,rho,xx :: REAL
    normab,rho_einv,half_einv :: REAL
    QPx,QPy,QPz,QCx,QCy,QCz,DCx,DCy,DCz :: REAL
    Qx,Qy,Qz,Px,Py,Pz :: REAL
    ret,rethen :: REAL
    Ix2,Iy2,Iz2,Ix3,Iy3,Iz3,Ix2_w,Iy2_w,Iz2_w,w :: REAL
    px_s,py_s,pz_s,dxx_s,dyy_s,dzz_s,dxy_s,dxz_s,dyz_s :: REAL
    ag,bg,cg,dg,n,j,k :: INT

    px_s  = ZERO; py_s  = ZERO; pz_s  = ZERO
    dxx_s = ZERO; dyy_s = ZERO; dzz_s = ZERO
    dxy_s = ZERO; dxz_s = ZERO; dyz_s = ZERO

    rys1.create(2)
    k = 0
    do bg = 1, .b.n_cc
      do ag = 1, .a.n_cc
        k = k + 1
        zeta = .ab_exponent_sum(k)
        normab = .ab_cc_prefactor(k) * TWOPI5ON2
        Px = .ab_pair_center(1,k)
        Py = .ab_pair_center(2,k)
        Pz = .ab_pair_center(3,k)
        j = 0
        do dg = 1, .d.n_cc
          do cg = 1, .c.n_cc
            j = j + 1
            eta  = .cd_exponent_sum(j)
            einv = ONE/eta
            Qx = .cd_pair_center(1,j)
            Qy = .cd_pair_center(2,j)
            Qz = .cd_pair_center(3,j)
            QCx = .cd_center_diff(1,j)
            QCy = .cd_center_diff(2,j)
            QCz = .cd_center_diff(3,j)
            rho  = zeta * eta / (zeta + eta)
            half_einv = HALF * einv
            rho_einv = rho * einv
            QPx  = Qx - Px;   QPy  = Qy - Py;   QPz  = Qz - Pz
            xx   = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
            rys1.get_weights(xx)
            rys1.w = rys1.w * normab * .cd_cc_prefactor(j) * sqrt(rho)

            do n=1,2
              ret     = rys1.r(n) * rho_einv
              w       = rys1.w(n)
              rethen  = (ONE - ret) * half_einv * w
              Ix2 = QCx - ret * QPx
              Iy2 = QCy - ret * QPy
              Iz2 = QCz - ret * QPz
              Iz2_w = Iz2 * w
              Iy2_w = Iy2 * w
              Ix2_w = Ix2 * w
              Ix3 = Ix2 * Ix2_w + rethen
              Iy3 = Iy2 * Iy2_w + rethen
              Iz3 = Iz2 * Iz2_w + rethen

              px_s  = px_s  + Ix2_w
              py_s  = py_s  + Iy2_w
              pz_s  = pz_s  + Iz2_w
              dxx_s = dxx_s + Ix3
              dyy_s = dyy_s + Iy3
              dzz_s = dzz_s + Iz3
              dxy_s = dxy_s + Ix2 * Iy2_w
              dxz_s = dxz_s + Ix2 * Iz2_w
              dyz_s = dyz_s + Iy2 * Iz2_w
            end
          end
        end
      end
    end
    rys1.destroy

    ! Transfer equation.
    DCx = .pos_d(1) - .pos_c(1)
    DCy = .pos_d(2) - .pos_c(2)
    DCz = .pos_d(3) - .pos_c(3)
    sscd(1,1) = dxx_s + DCx * px_s
    sscd(1,2) = dxy_s + DCx * py_s
    sscd(1,3) = dxz_s + DCx * pz_s
    sscd(2,1) = dxy_s + DCy * px_s
    sscd(2,2) = dyy_s + DCy * py_s
    sscd(2,3) = dyz_s + DCy * pz_s
    sscd(3,1) = dxz_s + DCz * px_s
    sscd(3,2) = dyz_s + DCz * py_s
    sscd(3,3) = dzz_s + DCz * pz_s
  end

  make_sspp_low_ncc(sscd) ::: private
  ! Creates the (ss|pp) integrals, summed over primitives.
    self :: IN
    sscd :: REALMAT, OUT
    rys1 :: RYS*
    zeta,eta,einv,rho,xx :: REAL
    normab,rho_einv,half_einv :: REAL
    QPx,QPy,QPz,QCx,QCy,QCz,DCx,DCy,DCz :: REAL
    Qx,Qy,Qz,Px,Py,Pz :: REAL
    Dx,Dy,Dz,Cx,Cy,Cz,Ctx,Cty,Ctz :: REAL
    d,d_cc,d_r2cd,c :: REAL
    ret,rethen :: REAL
    Ix2,Iy2,Iz2,Ix3,Iy3,Iz3,Ix2_w,Iy2_w,Iz2_w,w :: REAL
    px_s,py_s,pz_s,dxx_s,dyy_s,dzz_s,dxy_s,dxz_s,dyz_s :: REAL
    ag,bg,cg,dg,n,k :: INT

    px_s  = ZERO; py_s  = ZERO; pz_s  = ZERO
    dxx_s = ZERO; dyy_s = ZERO; dzz_s = ZERO
    dxy_s = ZERO; dxz_s = ZERO; dyz_s = ZERO
    Cx = .pos_c(1);  Dx = .pos_d(1)
    Cy = .pos_c(2);  Dy = .pos_d(2)
    Cz = .pos_c(3);  Dz = .pos_d(3)
    if (.c.l > .d.l) then
      Ctx = Cx;  Cty = Cy;  Ctz = Cz
    else
      Ctx = Dx;  Cty = Dy;  Ctz = Dz
    end

    rys1.create(2)
    k = 0
    do bg = 1, .b.n_cc
      do ag = 1, .a.n_cc
        k = k + 1
        zeta = .ab_exponent_sum(k)
        normab = .ab_cc_prefactor(k) * TWOPI5ON2
        Px = .ab_pair_center(1,k)
        Py = .ab_pair_center(2,k)
        Pz = .ab_pair_center(3,k)
        do dg = 1, .d.n_cc
          d      = .d.ex(dg)
          d_cc   = .d.cc(dg)
          d_r2cd = d * .r2cd
          do cg = 1, .c.n_cc
            c    = .c.ex(cg)
            eta  = c + d
            einv = ONE/eta
            Qx = (d*Dx + c*Cx) * einv
            Qy = (d*Dy + c*Cy) * einv
            Qz = (d*Dz + c*Cz) * einv
            QCx = Qx - Ctx
            QCy = Qy - Cty
            QCz = Qz - Ctz
            rho  = zeta * eta / (zeta + eta)
            rho_einv = rho * einv
            half_einv = HALF * einv
            QPx  = Qx - Px;   QPy  = Qy - Py;   QPz  = Qz - Pz
            xx   = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
            rys1.get_weights(xx)
            rys1.w(:) = rys1.w(:) * (normab * d_cc * .c.cc(cg) * &
                           einv * sqrt(rho_einv) * exp(-c*d_r2cd*einv))
            do n=1,2
              ret     = rys1.r(n) * rho_einv
              w       = rys1.w(n)
              rethen  = (ONE - ret) * half_einv * w
              Ix2 = QCx - ret * QPx
              Iy2 = QCy - ret * QPy
              Iz2 = QCz - ret * QPz
              Iz2_w = Iz2 * w
              Iy2_w = Iy2 * w
              Ix2_w = Ix2 * w
              Ix3 = Ix2 * Ix2_w + rethen
              Iy3 = Iy2 * Iy2_w + rethen
              Iz3 = Iz2 * Iz2_w + rethen

              px_s  = px_s  + Ix2_w
              py_s  = py_s  + Iy2_w
              pz_s  = pz_s  + Iz2_w
              dxx_s = dxx_s + Ix3
              dyy_s = dyy_s + Iy3
              dzz_s = dzz_s + Iz3
              dxy_s = dxy_s + Ix2 * Iy2_w
              dxz_s = dxz_s + Ix2 * Iz2_w
              dyz_s = dyz_s + Iy2 * Iz2_w
            end
          end
        end
      end
    end
    rys1.destroy

    ! Transfer equation.
    DCx = .pos_d(1) - .pos_c(1)
    DCy = .pos_d(2) - .pos_c(2)
    DCz = .pos_d(3) - .pos_c(3)
    sscd(1,1) = dxx_s + DCx * px_s
    sscd(1,2) = dxy_s + DCx * py_s
    sscd(1,3) = dxz_s + DCx * pz_s
    sscd(2,1) = dxy_s + DCy * px_s
    sscd(2,2) = dyy_s + DCy * py_s
    sscd(2,3) = dyz_s + DCy * pz_s
    sscd(3,1) = dxz_s + DCz * px_s
    sscd(3,2) = dyz_s + DCz * py_s
    sscd(3,3) = dzz_s + DCz * pz_s
  end

  make_psss(abcd) ::: private
  ! Creates the (ps|ss) or (sp|ss) integrals, summed over  primitives.
    self :: IN
    abcd :: REALMAT4, OUT
    psss :: REALVEC(3)
    if (.ab_n_gaussian_pairs > n_cc_cutoff) then
      .make_psss(psss)
    else
      .make_psss_low_ncc(psss)
    end
    abcd(1,1,1,1) = psss(1)
    if (.a.l == 1) then           ! psss
      abcd(2,1,1,1) = psss(2)
      abcd(3,1,1,1) = psss(3)
    else                          ! spss
      abcd(1,2,1,1) = psss(2)
      abcd(1,3,1,1) = psss(3)
    end
  end

  make_psss(psss) ::: private
  ! Creates the initial (ps|ss) or (sp|ss) integrals, summed over the
  ! primitives.
    self :: IN
    psss :: REALVEC, OUT
    rys1 :: RYS*
    zeta,zinv,eta,rho,xx,normab,norm_w,rzt :: REAL
    QPx,QPy,QPz,PAx,PAy,PAz,Qx,Qy,Qz,Px,Py,Pz :: REAL
    psss1,psss2,psss3 :: REAL
    ag,bg,cg,dg,j,k :: INT

    rys1.create(1)
    psss1 = ZERO
    psss2 = ZERO
    psss3 = ZERO
    k = 0
    do bg = 1, .b.n_cc
      do ag = 1, .a.n_cc
        k = k + 1
        zeta = .ab_exponent_sum(k)
        zinv = ONE/zeta
        normab = .ab_cc_prefactor(k) * TWOPI5ON2
        Px = .ab_pair_center(1,k)
        Py = .ab_pair_center(2,k)
        Pz = .ab_pair_center(3,k)
        PAx = .ab_center_diff(1,k)
        PAy = .ab_center_diff(2,k)
        PAz = .ab_center_diff(3,k)
        j = 0
        do dg = 1, .d.n_cc
          do cg = 1, .c.n_cc
            j = j + 1
            eta  = .cd_exponent_sum(j)
            Qx = .cd_pair_center(1,j)
            Qy = .cd_pair_center(2,j)
            Qz = .cd_pair_center(3,j)
            rho  = zeta * eta / (zeta + eta)
            QPx  = Qx - Px;   QPy  = Qy - Py;   QPz  = Qz - Pz
            xx   = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
            rys1.get_weights(xx)
            rzt = rys1.r(1) * rho * zinv
            norm_w = rys1.w(1) * normab * .cd_cc_prefactor(j) * sqrt(rho)
            psss1 = psss1 + norm_w * (PAx + rzt * QPx)
            psss2 = psss2 + norm_w * (PAy + rzt * QPy)
            psss3 = psss3 + norm_w * (PAz + rzt * QPz)
          end
        end
      end
    end
    rys1.destroy
    psss(1) = psss1
    psss(2) = psss2
    psss(3) = psss3
  end

  make_psss_low_ncc(psss) ::: private
  ! Creates the initial (ps|ss) or (sp|ss) integrals, summed over the
  ! primitives.
    self :: IN
    psss :: REALVEC, OUT
    rys1 :: RYS*
    zeta,zinv,eta,rho,xx,normab,norm_w,rzt,rho_einv,einv :: REAL
    QPx,QPy,QPz,PAx,PAy,PAz,Qx,Qy,Qz,Px,Py,Pz :: REAL
    Dx,Dy,Dz,Cx,Cy,Cz :: REAL
    d,d_cc,d_r2cd,c :: REAL
    psss1,psss2,psss3 :: REAL
    ag,bg,cg,dg,k :: INT

    rys1.create(1)
    Cx = .pos_c(1);  Dx = .pos_d(1)
    Cy = .pos_c(2);  Dy = .pos_d(2)
    Cz = .pos_c(3);  Dz = .pos_d(3)
    psss1 = ZERO
    psss2 = ZERO
    psss3 = ZERO
    k = 0
    do bg = 1, .b.n_cc
      do ag = 1, .a.n_cc
        k = k + 1
        zeta = .ab_exponent_sum(k)
        zinv = ONE/zeta
        normab = .ab_cc_prefactor(k) * TWOPI5ON2
        Px = .ab_pair_center(1,k)
        Py = .ab_pair_center(2,k)
        Pz = .ab_pair_center(3,k)
        PAx = .ab_center_diff(1,k)
        PAy = .ab_center_diff(2,k)
        PAz = .ab_center_diff(3,k)
        do dg = 1, .d.n_cc
          d      = .d.ex(dg)
          d_cc   = .d.cc(dg)
          d_r2cd = d * .r2cd
          do cg = 1, .c.n_cc
            c    = .c.ex(cg)
            eta  = c + d
            einv = ONE/eta
            Qx = (d*Dx + c*Cx) * einv
            Qy = (d*Dy + c*Cy) * einv
            Qz = (d*Dz + c*Cz) * einv
            rho  = zeta * eta / (zeta + eta)
            rho_einv = rho * einv
            QPx  = Qx - Px;   QPy  = Qy - Py;   QPz  = Qz - Pz
            xx   = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
            rys1.get_weights(xx)
            rzt = rys1.r(1) * rho * zinv
            norm_w = rys1.w(1) * normab * d_cc * .c.cc(cg) * &
                           einv * sqrt(rho_einv) * exp(-c*d_r2cd*einv)
            psss1 = psss1 + norm_w * (PAx + rzt * QPx)
            psss2 = psss2 + norm_w * (PAy + rzt * QPy)
            psss3 = psss3 + norm_w * (PAz + rzt * QPz)
          end
        end
      end
    end
    rys1.destroy
    psss(1) = psss1
    psss(2) = psss2
    psss(3) = psss3
  end

  make_ssps(abcd) ::: private
  ! Creates the (ss|ps) or (ss|sp) integrals, summed over the primitives.
    self :: IN
    abcd :: REALMAT4, OUT
    ssps :: REALVEC(3)
    if (.ab_n_gaussian_pairs > n_cc_cutoff) then
      .make_ssps(ssps)
    else
      .make_ssps_low_ncc(ssps)
    end
    abcd(1,1,1,1) = ssps(1)
    if (.c.l == 1) then           ! ssps
      abcd(1,1,2,1) = ssps(2)
      abcd(1,1,3,1) = ssps(3)
    else                          ! sssp
      abcd(1,1,1,2) = ssps(2)
      abcd(1,1,1,3) = ssps(3)
    end
  end

  make_ssps(ssps) ::: private
  ! Creates the (ss|ps) or (ss|sp) integrals, summed over the primitives.
    self :: IN
    ssps :: REALVEC, OUT
    rys1 :: RYS*
    zeta,eta,einv,rho,xx,ret,normab,norm_w :: REAL
    QPx,QPy,QPz,QCx,QCy,QCz,Qx,Qy,Qz,Px,Py,Pz :: REAL
    ssps1,ssps2,ssps3 :: REAL
    ag,bg,cg,dg,k,j :: INT

    rys1.create(1)
    ssps1=ZERO
    ssps2=ZERO
    ssps3=ZERO
    k = 0
    do bg = 1, .b.n_cc
      do ag = 1, .a.n_cc
        k = k + 1
        zeta = .ab_exponent_sum(k)
        normab = .ab_cc_prefactor(k) * TWOPI5ON2
        Px = .ab_pair_center(1,k)
        Py = .ab_pair_center(2,k)
        Pz = .ab_pair_center(3,k)
        j = 0
        do dg = 1, .d.n_cc
          do cg = 1, .c.n_cc
            j = j + 1
            eta  = .cd_exponent_sum(j)
            einv = ONE/eta
            Qx = .cd_pair_center(1,j)
            Qy = .cd_pair_center(2,j)
            Qz = .cd_pair_center(3,j)
            QCx = .cd_center_diff(1,j)
            QCy = .cd_center_diff(2,j)
            QCz = .cd_center_diff(3,j)
            rho  = zeta * eta / (zeta + eta)
            QPx  = Qx - Px;   QPy  = Qy - Py;   QPz  = Qz - Pz
            xx   = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
            rys1.get_weights(xx)
            ret = rys1.r(1) * rho * einv
            norm_w = rys1.w(1) * normab * .cd_cc_prefactor(j) * sqrt(rho)
            ssps1 = ssps1 + norm_w * (QCx - ret * QPx)
            ssps2 = ssps2 + norm_w * (QCy - ret * QPy)
            ssps3 = ssps3 + norm_w * (QCz - ret * QPz)
          end
        end
      end
    end
    rys1.destroy
    ssps(1) = ssps1
    ssps(2) = ssps2
    ssps(3) = ssps3
  end

  make_ssps_low_ncc(ssps) ::: private
  ! Creates the (ss|ps) or (ss|sp) integrals, summed over the primitives.
    self :: IN
    ssps :: REALVEC, OUT
    rys1 :: RYS*
    zeta,eta,einv,rho,xx,ret,normab,norm_w,rho_einv :: REAL
    QPx,QPy,QPz,QCx,QCy,QCz,Qx,Qy,Qz,Px,Py,Pz :: REAL
    Dx,Dy,Dz,Cx,Cy,Cz,Ctx,Cty,Ctz :: REAL
    d,d_cc,d_r2cd,c :: REAL
    ssps1,ssps2,ssps3 :: REAL
    ag,bg,cg,dg,k :: INT

    rys1.create(1)
    Cx = .pos_c(1);  Dx = .pos_d(1)
    Cy = .pos_c(2);  Dy = .pos_d(2)
    Cz = .pos_c(3);  Dz = .pos_d(3)
    if (.c.l > .d.l) then
      Ctx = Cx;  Cty = Cy;  Ctz = Cz
    else
      Ctx = Dx;  Cty = Dy;  Ctz = Dz
    end
    ssps1=ZERO
    ssps2=ZERO
    ssps3=ZERO
    k = 0
    do bg = 1, .b.n_cc
      do ag = 1, .a.n_cc
        k = k + 1
        zeta = .ab_exponent_sum(k)
        normab = .ab_cc_prefactor(k) * TWOPI5ON2
        Px = .ab_pair_center(1,k)
        Py = .ab_pair_center(2,k)
        Pz = .ab_pair_center(3,k)
        do dg = 1, .d.n_cc
          d      = .d.ex(dg)
          d_cc   = .d.cc(dg)
          d_r2cd = d * .r2cd
          do cg = 1, .c.n_cc
            c    = .c.ex(cg)
            eta  = c + d
            einv = ONE/eta
            Qx = (d*Dx + c*Cx) * einv
            Qy = (d*Dy + c*Cy) * einv
            Qz = (d*Dz + c*Cz) * einv
            QCx = Qx - Ctx
            QCy = Qy - Cty
            QCz = Qz - Ctz
            rho  = zeta * eta / (zeta + eta)
            rho_einv = rho * einv
            QPx  = Qx - Px;   QPy  = Qy - Py;   QPz  = Qz - Pz
            xx   = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
            rys1.get_weights(xx)
            ret = rys1.r(1) * rho * einv
            norm_w = rys1.w(1) * normab * d_cc * .c.cc(cg) * &
                           einv * sqrt(rho_einv) * exp(-c*d_r2cd*einv)
            ssps1 = ssps1 + norm_w * (QCx - ret * QPx)
            ssps2 = ssps2 + norm_w * (QCy - ret * QPy)
            ssps3 = ssps3 + norm_w * (QCz - ret * QPz)
          end
        end
      end
    end
    rys1.destroy
    ssps(1) = ssps1
    ssps(2) = ssps2
    ssps(3) = ssps3
  end

  make_ssss(abcd) ::: private
  ! Creates the (ss|ss) integrals, summed over the primitives.
    self :: IN
    abcd :: REALMAT4, OUT
    ssss :: REAL
    if (.ab_n_gaussian_pairs > n_cc_cutoff) then
      .make_ssss(ssss)
    else
      .make_ssss_low_ncc(ssss)
    end
    abcd(1,1,1,1) = ssss
  end

  make_ssss(ssss) ::: private
  ! Creates the (ss|ss) integrals, summed over the primitives.
    self :: IN
    ssss :: REAL, OUT
    rys1 :: RYS*
    zeta,eta,rho,xx,normab,QPx,QPy,QPz,Px,Py,Pz :: REAL
    ag,bg,cg,dg,j,k :: INT

    rys1.create(1)
    ssss = ZERO
    k = 0
    do bg = 1, .b.n_cc
      do ag = 1, .a.n_cc
        k = k + 1
        zeta = .ab_exponent_sum(k)
        normab = .ab_cc_prefactor(k) * TWOPI5ON2
        Px = .ab_pair_center(1,k)
        Py = .ab_pair_center(2,k)
        Pz = .ab_pair_center(3,k)
        j = 0
        do dg = 1, .d.n_cc
          do cg = 1, .c.n_cc
            j = j + 1
            eta  = .cd_exponent_sum(j)
            QPx = .cd_pair_center(1,j) - Px
            QPy = .cd_pair_center(2,j) - Py
            QPz = .cd_pair_center(3,j) - Pz
            rho  = zeta * eta / (zeta + eta)
            xx   = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
            rys1.get_weights(xx)
            ssss = ssss + normab * .cd_cc_prefactor(j) * sqrt(rho) * rys1.w(1)
          end
        end
      end
    end
    rys1.destroy
  end

  make_ssss_low_ncc(ssss) ::: private
  ! Creates the (ss|ss) integrals, summed over the primitives.
    self :: IN
    ssss :: REAL, OUT
    rys1 :: RYS*
    zeta,eta,rho,xx,normab,QPx,QPy,QPz,Px,Py,Pz,Qx,Qy,Qz :: REAL
    Dx,Dy,Dz,Cx,Cy,Cz,einv :: REAL
    d,d_cc,d_r2cd,c :: REAL
    ag,bg,cg,dg,k :: INT

    rys1.create(1)
    Cx = .pos_c(1);  Dx = .pos_d(1)
    Cy = .pos_c(2);  Dy = .pos_d(2)
    Cz = .pos_c(3);  Dz = .pos_d(3)
    ssss = ZERO
    k = 0
    do bg = 1, .b.n_cc
      do ag = 1, .a.n_cc
        k = k + 1
        zeta = .ab_exponent_sum(k)
        normab = .ab_cc_prefactor(k) * TWOPI5ON2
        Px = .ab_pair_center(1,k)
        Py = .ab_pair_center(2,k)
        Pz = .ab_pair_center(3,k)
        do dg = 1, .d.n_cc
          d      = .d.ex(dg)
          d_cc   = .d.cc(dg)
          d_r2cd = d * .r2cd
          do cg = 1, .c.n_cc
            c    = .c.ex(cg)
            eta  = c + d
            einv = ONE/eta
            Qx = (d*Dx + c*Cx) * einv
            Qy = (d*Dy + c*Cy) * einv
            Qz = (d*Dz + c*Cz) * einv
            rho  = zeta * eta / (zeta + eta)
            QPx  = Qx - Px;   QPy  = Qy - Py;   QPz  = Qz - Pz
            xx   = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
            rys1.get_weights(xx)
            ssss = ssss + rys1.w(1) * normab * d_cc * .c.cc(cg) * &
                           einv * sqrt(rho*einv) * exp(-c*d_r2cd*einv)
          end
        end
      end
    end
    rys1.destroy
  end

  transfer_cd(esfs,escd)
  ! Applies the transfer equation to (es|fs) to give (es|cd)
    self :: IN
    esfs :: REALMAT, IN
    escd :: REALMAT3, OUT
    if (.c.l > .d.l) then
      .transfer_l_c_highest(esfs,escd)
    else
      .transfer_l_d_highest(esfs,escd)
    end
  end

  transfer_ab(escd,abcd)
  ! Applies the transfer equation to (es|cd) to give (ab|cd)
    self :: IN
    escd :: REALMAT3, IN
    abcd :: REALMAT4, OUT
    if (.a.l > .b.l) then
      .transfer_l_a_highest(escd,abcd)
    else
      .transfer_l_b_highest(escd,abcd)
    end
  end

  transfer_ab(escd,abcd)
  ! Applies the transfer equation to (es|cd) to give (ab|cd)
    self :: IN
    escd :: REALMAT, IN
    abcd :: REALMAT3, OUT
    if (.a.l > .b.l) then
      .transfer_l_a_highest(escd,abcd)
    else
      .transfer_l_b_highest(escd,abcd)
    end
  end

   transfer_l_c_highest(esfs,escd) ::: private
   ! Applies the transfer equation to (es|fs) to give (es|cd)
     self :: IN
     esfs :: REALMAT, IN
     escd :: REALMAT3, OUT
     int_new,int_old :: REALMAT3*
     components_c,components_d :: INTMAT*
     index_c,index_d :: INTMAT3*
     component_to_use :: INTVEC*
     CD :: REALVEC(3)
     c,d,c1,c2,c3,d1,ld,cub,dub :: INT
     cx,cy,cz,dx,dy,dz,j,clb,dlb,e,eub :: INT
     CDi,CDx,CDy,CDz,esfs_ec :: REAL

     select case (.d.l)
       case (0)
         escd(:,:,1)=esfs

       case (1)
         if (.c.l==1) then
           eub = .ab_l_sum.n_comp_sum - (.ab_l_max-1).n_comp_sum
           CD   = .pos_c - .pos_d
           CDx=CD(1); CDy=CD(2); CDz=CD(3)
           do e = 1, eub
             esfs_ec = esfs(e,1)
             escd(e,1,1)=esfs(e,4)+CDx*esfs_ec
             escd(e,1,2)=esfs(e,7)+CDy*esfs_ec
             escd(e,1,3)=esfs(e,8)+CDz*esfs_ec
             esfs_ec = esfs(e,2)
             escd(e,2,1)=esfs(e,7)+CDx*esfs_ec
             escd(e,2,2)=esfs(e,5)+CDy*esfs_ec
             escd(e,2,3)=esfs(e,9)+CDz*esfs_ec
             esfs_ec = esfs(e,3)
             escd(e,3,1)=esfs(e,8)+CDx*esfs_ec
             escd(e,3,2)=esfs(e,9)+CDy*esfs_ec
             escd(e,3,3)=esfs(e,6)+CDz*esfs_ec
           end
         else
           clb = (.c.l-1).n_comp_sum
           eub = .ab_l_sum.n_comp_sum - (.ab_l_max-1).n_comp_sum
           CD   = .pos_c - .pos_d
           cub  = .c.n_comp
           components_c => .cd_hrr_components(:,clb+1:)
           index_c => .cd_hrr_index_larger
           CDx = CD(1); CDy = CD(2); CDz = CD(3)
           do c = 1, cub
             cx = components_c(1,c)
             cy = components_c(2,c)
             cz = components_c(3,c)
             c1 = index_c(cx+1,cy,cz)
             c2 = index_c(cx,cy+1,cz)
             c3 = index_c(cx,cy,cz+1)
             do e = 1, eub
               esfs_ec = esfs(e,c)
               escd(e,c,1) = esfs(e,c1) + CDx * esfs_ec
               escd(e,c,2) = esfs(e,c2) + CDy * esfs_ec
               escd(e,c,3) = esfs(e,c3) + CDz * esfs_ec
             end
           end
         end

       case default
         clb  = (.c.l-1).n_comp_sum
         eub  = .ab_l_sum.n_comp_sum - (.ab_l_max-1).n_comp_sum
         CD   = .pos_c - .pos_d
         cub  = (.cd_l_sum-1).n_comp_sum - clb

         index_c => .cd_hrr_index_larger
         index_d => .cd_hrr_index_smaller
         components_c => .cd_hrr_components(:,clb+1:)

         nullify(int_new)
         int_new.create(eub,cub,3)

         CDx = CD(1); CDy = CD(2); CDz = CD(3)
         do c = 1, cub
           cx = components_c(1,c)
           cy = components_c(2,c)
           cz = components_c(3,c)
           c1 = index_c(cx+1,cy,cz)
           c2 = index_c(cx,cy+1,cz)
           c3 = index_c(cx,cy,cz+1)
           do e = 1, eub
             esfs_ec = esfs(e,c)
             int_new(e,c,1) = esfs(e,c1) + CDx * esfs_ec
             int_new(e,c,2) = esfs(e,c2) + CDy * esfs_ec
             int_new(e,c,3) = esfs(e,c3) + CDz * esfs_ec
           end
         end

         do ld=2, .d.l - 1
           dlb              = (ld-1).n_comp_sum
           dub              = ld.n_comp
           cub              = (.cd_l_sum-ld).n_comp_sum - clb
           component_to_use => .cd_hrr_comp_to_use(dlb+1:dlb+dub)
           components_d     => .cd_hrr_components(:,dlb+1:dlb+dub)
           int_old          => int_new
           nullify(int_new)
           int_new.create(eub,cub,dub)
           do d=1,dub
             dx = components_d(1,d)
             dy = components_d(2,d)
             dz = components_d(3,d)
             j=component_to_use(d)
             .subtract_from_component(dx,dy,dz,j)
             d1 = index_d(dx,dy,dz)
             CDi=CD(j)
             do c=1,cub
               cx = components_c(1,c)
               cy = components_c(2,c)
               cz = components_c(3,c)
               .add_to_component(cx,cy,cz,j)
               c1 = index_c(cx,cy,cz)
               int_new(:,c,d)=int_old(:,c1,d1)+CDi*int_old(:,c,d1)
             end
           end
           int_old.destroy
         end

         dlb              = (.d.l-1).n_comp_sum
         dub              = .d.n_comp
         cub              = .c.n_comp
         component_to_use => .cd_hrr_comp_to_use(dlb+1:dlb+dub)
         components_d     => .cd_hrr_components(:,dlb+1:dlb+dub)
         int_old          => int_new
         do d=1,dub
           dx = components_d(1,d)
           dy = components_d(2,d)
           dz = components_d(3,d)
           j=component_to_use(d)
           .subtract_from_component(dx,dy,dz,j)
           d1 = index_d(dx,dy,dz)
           CDi=CD(j)
           do c=1,cub
             cx = components_c(1,c)
             cy = components_c(2,c)
             cz = components_c(3,c)
             .add_to_component(cx,cy,cz,j)
             c1 = index_c(cx,cy,cz)
             escd(:,c,d)=int_old(:,c1,d1)+CDi*int_old(:,c,d1)
           end
         end
         int_old.destroy
     end
   end

   transfer_l_d_highest(esfs,escd) ::: private
   ! Applies the transfer equation to (es|fs) to give (es|cd)
     self :: IN
     esfs :: REALMAT, IN
     escd :: REALMAT3, OUT
     int_new,int_old :: REALMAT3*
     components_c,components_d :: INTMAT*
     index_c,index_d :: INTMAT3*
     component_to_use :: INTVEC*
     DC :: REALVEC(3)
     c,d,c1,d1,d2,d3,lc,cub,dub :: INT
     cx,cy,cz,dx,dy,dz,j,clb,dlb,e,eub :: INT
     DCi,DCx,DCy,DCz,esfs_ed :: REAL

     select case (.c.l)
       case (0)
         escd(:,1,:)=esfs

       case (1)
         if (.d.l==1) then
           eub = .ab_l_sum.n_comp_sum - (.ab_l_max-1).n_comp_sum
           DC   = .pos_d - .pos_c
           DCx=DC(1); DCy=DC(2); DCz=DC(3)
           do e = 1, eub
             esfs_ed = esfs(e,1)
             escd(e,1,1)=esfs(e,4)+DCx*esfs_ed
             escd(e,2,1)=esfs(e,7)+DCy*esfs_ed
             escd(e,3,1)=esfs(e,8)+DCz*esfs_ed
             esfs_ed = esfs(e,2)
             escd(e,1,2)=esfs(e,7)+DCx*esfs_ed
             escd(e,2,2)=esfs(e,5)+DCy*esfs_ed
             escd(e,3,2)=esfs(e,9)+DCz*esfs_ed
             esfs_ed = esfs(e,3)
             escd(e,1,3)=esfs(e,8)+DCx*esfs_ed
             escd(e,2,3)=esfs(e,9)+DCy*esfs_ed
             escd(e,3,3)=esfs(e,6)+DCz*esfs_ed
           end
         else
           dlb = (.d.l-1).n_comp_sum
           eub = .ab_l_sum.n_comp_sum - (.ab_l_max-1).n_comp_sum
           DC   = .pos_d - .pos_c
           dub  = .d.n_comp
           components_d => .cd_hrr_components(:,dlb+1:)
           index_d => .cd_hrr_index_larger
           DCx=DC(1); DCy=DC(2); DCz=DC(3)
           do d=1,dub
             dx = components_d(1,d)
             dy = components_d(2,d)
             dz = components_d(3,d)
             d1 = index_d(dx+1,dy,dz)
             d2 = index_d(dx,dy+1,dz)
             d3 = index_d(dx,dy,dz+1)
             do e = 1, eub
               esfs_ed = esfs(e,d)
               escd(e,1,d)=esfs(e,d1)+DCx*esfs_ed
               escd(e,2,d)=esfs(e,d2)+DCy*esfs_ed
               escd(e,3,d)=esfs(e,d3)+DCz*esfs_ed
             end
           end
         end

       case default
         dlb = (.d.l-1).n_comp_sum
         eub = (.ab_l_sum).n_comp_sum - (.ab_l_max-1).n_comp_sum
         DC   = .pos_d - .pos_c
         dub  = (.cd_l_sum-1).n_comp_sum - dlb

         index_d => .cd_hrr_index_larger
         index_c => .cd_hrr_index_smaller
         components_d => .cd_hrr_components(:,dlb+1:)

         nullify(int_new)
         int_new.create(eub,dub,3)
         DCx=DC(1); DCy=DC(2); DCz=DC(3)
         do d=1,dub
           dx = components_d(1,d)
           dy = components_d(2,d)
           dz = components_d(3,d)
           d1 = index_d(dx+1,dy,dz)
           d2 = index_d(dx,dy+1,dz)
           d3 = index_d(dx,dy,dz+1)
           do e = 1, eub
             esfs_ed = esfs(e,d)
             int_new(e,d,1)=esfs(e,d1)+DCx*esfs_ed
             int_new(e,d,2)=esfs(e,d2)+DCy*esfs_ed
             int_new(e,d,3)=esfs(e,d3)+DCz*esfs_ed
           end
         end
         do lc=2, .c.l - 1
           clb              = (lc-1).n_comp_sum
           cub              = lc.n_comp
           dub              = (.cd_l_sum-lc).n_comp_sum - dlb
           component_to_use => .cd_hrr_comp_to_use(clb+1:clb+cub)
           components_c     => .cd_hrr_components(:,clb+1:clb+cub)
           int_old          => int_new
           nullify(int_new)
           int_new.create(eub,dub,cub)
           do c=1,cub
             cx = components_c(1,c)
             cy = components_c(2,c)
             cz = components_c(3,c)
             j=component_to_use(c)
             .subtract_from_component(cx,cy,cz,j)
             c1 = index_c(cx,cy,cz)
             DCi=DC(j)
             do d=1,dub
               dx = components_d(1,d)
               dy = components_d(2,d)
               dz = components_d(3,d)
               .add_to_component(dx,dy,dz,j)
               d1 = index_d(dx,dy,dz)
               int_new(:,d,c)=int_old(:,d1,c1)+DCi*int_old(:,d,c1)
             end
           end
           int_old.destroy
         end
         clb              = (.c.l-1).n_comp_sum
         cub              = .c.n_comp
         dub              = .d.n_comp
         component_to_use => .cd_hrr_comp_to_use(clb+1:clb+cub)
         components_c     => .cd_hrr_components(:,clb+1:clb+cub)
         int_old          => int_new
         do c=1,cub
           cx = components_c(1,c)
           cy = components_c(2,c)
           cz = components_c(3,c)
           j=component_to_use(c)
           .subtract_from_component(cx,cy,cz,j)
           c1 = index_c(cx,cy,cz)
           DCi=DC(j)
           do d=1,dub
             dx = components_d(1,d)
             dy = components_d(2,d)
             dz = components_d(3,d)
             .add_to_component(dx,dy,dz,j)
             d1 = index_d(dx,dy,dz)
             escd(:,c,d)=int_old(:,d1,c1)+DCi*int_old(:,d,c1)
           end
         end
         int_old.destroy
     end
   end

   transfer_l_a_highest(escd,abcd) ::: private
   ! Applies the transfer equation to (es|cd) to give (ab|cd)
     self :: IN
     escd :: REALMAT3, IN
     abcd :: REALMAT4, OUT
     int_new,int_old :: REALMAT4*
     components_a,components_b :: INTMAT*
     index_a,index_b :: INTMAT3*
     component_to_use :: INTVEC*
     AB :: REALVEC(3)
     a,b,c,d,a1,a2,a3,b1,lb,aub,bub,cub,dub :: INT
     ax,ay,az,bx,by,bz,j,alb,blb :: INT
     ABi,ABx,ABy,ABz,escd_acd :: REAL

     select case (.b.l)
       case (0)
         abcd(:,1,:,:)=escd

       case (1)
         if (.a.l==1) then
           AB   = .pos_b - .pos_a
           ABx = AB(1);    ABy = AB(2);    ABz = AB(3)
           cub  = .c.n_comp
           dub  = .d.n_comp
           do d = 1, dub
             do c = 1, cub
               escd_acd = escd(1,c,d)
               abcd(1,1,c,d) = escd(4,c,d) + ABx * escd_acd
               abcd(1,2,c,d) = escd(7,c,d) + ABy * escd_acd
               abcd(1,3,c,d) = escd(8,c,d) + ABz * escd_acd
               escd_acd = escd(2,c,d)
               abcd(2,1,c,d) = escd(7,c,d) + ABx * escd_acd
               abcd(2,2,c,d) = escd(5,c,d) + ABy * escd_acd
               abcd(2,3,c,d) = escd(9,c,d) + ABz * escd_acd
               escd_acd = escd(3,c,d)
               abcd(3,1,c,d) = escd(8,c,d) + ABx * escd_acd
               abcd(3,2,c,d) = escd(9,c,d) + ABy * escd_acd
               abcd(3,3,c,d) = escd(6,c,d) + ABz * escd_acd
             end
           end
         else
           alb = (.a.l-1).n_comp_sum
           AB   = .pos_a - .pos_b
           aub  = .a.n_comp
           cub  = .c.n_comp
           dub  = .d.n_comp
           components_a => .ab_hrr_components(:,alb+1:)
           index_a => .ab_hrr_index_larger
           ABx=AB(1); ABy=AB(2); ABz=AB(3)
           do a=1,aub
             ax = components_a(1,a)
             ay = components_a(2,a)
             az = components_a(3,a)
             a1 = index_a(ax+1,ay,az)
             a2 = index_a(ax,ay+1,az)
             a3 = index_a(ax,ay,az+1)
             do d=1,dub
               do c=1,cub
                 escd_acd = escd(a,c,d)
                 abcd(a,1,c,d)=escd(a1,c,d) + ABx * escd_acd
                 abcd(a,2,c,d)=escd(a2,c,d) + ABy * escd_acd
                 abcd(a,3,c,d)=escd(a3,c,d) + ABz * escd_acd
               end
             end
           end
         end

       case default
         alb = (.a.l-1).n_comp_sum
         AB   = .pos_a - .pos_b
         aub  = (.ab_l_sum-1).n_comp_sum - alb
         bub  = .b.n_comp
         cub  = .c.n_comp
         dub  = .d.n_comp

         index_a => .ab_hrr_index_larger
         index_b => .ab_hrr_index_smaller
         components_a => .ab_hrr_components(:,alb+1:)

         nullify(int_new)
         int_new.create(cub,dub,bub,aub)
         ABx=AB(1); ABy=AB(2); ABz=AB(3)
         do a=1,aub
           ax = components_a(1,a)
           ay = components_a(2,a)
           az = components_a(3,a)
           a1 = index_a(ax+1,ay,az)
           a2 = index_a(ax,ay+1,az)
           a3 = index_a(ax,ay,az+1)
           do d=1,dub
             do c=1,cub
               escd_acd = escd(a,c,d)
               int_new(c,d,1,a)=escd(a1,c,d) + ABx * escd_acd
               int_new(c,d,2,a)=escd(a2,c,d) + ABy * escd_acd
               int_new(c,d,3,a)=escd(a3,c,d) + ABz * escd_acd
             end
           end
         end

         do lb=2, .b.l - 1
           blb              = (lb-1).n_comp_sum
           bub              = lb.n_comp
           aub              = (.ab_l_sum-lb).n_comp_sum - alb
           component_to_use => .ab_hrr_comp_to_use(blb+1:blb+bub)
           components_b     => .ab_hrr_components(:,blb+1:blb+bub)
           int_old          => int_new
           nullify(int_new)
           int_new.create(cub,dub,bub,aub)
           do b=1,bub
             bx = components_b(1,b)
             by = components_b(2,b)
             bz = components_b(3,b)
             j = component_to_use(b)
             .subtract_from_component(bx,by,bz,j)
             b1 = index_b(bx,by,bz)
             ABi=AB(j)
             do a=1,aub
               ax = components_a(1,a)
               ay = components_a(2,a)
               az = components_a(3,a)
               .add_to_component(ax,ay,az,j)
               a1 = index_a(ax,ay,az)
               int_new(:,:,b,a)=int_old(:,:,b1,a1) + ABi * int_old(:,:,b1,a)
             end
           end
           int_old.destroy
         end

         blb              = (.b.l-1).n_comp_sum
         bub              = .b.n_comp
         aub              = .a.n_comp
         component_to_use => .ab_hrr_comp_to_use(blb+1:blb+bub)
         components_b     => .ab_hrr_components(:,blb+1:blb+bub)
         int_old          => int_new
         do b=1,bub
           bx = components_b(1,b)
           by = components_b(2,b)
           bz = components_b(3,b)
           j = component_to_use(b)
           .subtract_from_component(bx,by,bz,j)
           b1 = index_b(bx,by,bz)
           ABi=AB(j)
           do a=1,aub
             ax = components_a(1,a)
             ay = components_a(2,a)
             az = components_a(3,a)
             .add_to_component(ax,ay,az,j)
             a1 = index_a(ax,ay,az)
             abcd(a,b,:,:)=int_old(:,:,b1,a1) + ABi * int_old(:,:,b1,a)
           end
         end
         int_old.destroy
     end
   end

   transfer_l_b_highest(escd,abcd) ::: private
   ! Applies the transfer equation to (es|cd) to give (ab|cd)
     self :: IN
     escd :: REALMAT3, IN
     abcd :: REALMAT4, OUT
     int_new,int_old :: REALMAT4*
     components_a,components_b :: INTMAT*
     index_a,index_b :: INTMAT3*
     component_to_use :: INTVEC*
     BA :: REALVEC(3)
     a,b,c,d,a1,b1,b2,b3,la,aub,bub,cub,dub :: INT
     ax,ay,az,bx,by,bz,j,alb,blb :: INT
     BAi,BAx,BAy,BAz,escd_bcd :: REAL

     select case (.a.l)
       case (0)
         abcd(1,:,:,:)=escd

       case (1)
         if (.b.l==1) then
           BA   = .pos_b - .pos_a
           BAx = BA(1);    BAy = BA(2);    BAz = BA(3)
           cub  = .c.n_comp
           dub  = .d.n_comp
           do d = 1, dub
             do c = 1, cub
               escd_bcd = escd(1,c,d)
               abcd(1,1,c,d) = escd(4,c,d) + BAx * escd_bcd
               abcd(2,1,c,d) = escd(7,c,d) + BAy * escd_bcd
               abcd(3,1,c,d) = escd(8,c,d) + BAz * escd_bcd
               escd_bcd = escd(2,c,d)
               abcd(1,2,c,d) = escd(7,c,d) + BAx * escd_bcd
               abcd(2,2,c,d) = escd(5,c,d) + BAy * escd_bcd
               abcd(3,2,c,d) = escd(9,c,d) + BAz * escd_bcd
               escd_bcd = escd(3,c,d)
               abcd(1,3,c,d) = escd(8,c,d) + BAx * escd_bcd
               abcd(2,3,c,d) = escd(9,c,d) + BAy * escd_bcd
               abcd(3,3,c,d) = escd(6,c,d) + BAz * escd_bcd
             end
           end
         else
           blb = (.b.l-1).n_comp_sum
           BA   = .pos_b - .pos_a
           bub  = .b.n_comp
           cub  = .c.n_comp
           dub  = .d.n_comp
           components_b => .ab_hrr_components(:,blb+1:)
           index_b => .ab_hrr_index_larger
           BAx = BA(1);    BAy = BA(2);    BAz = BA(3)
           do b = 1, bub
             bx = components_b(1,b)
             by = components_b(2,b)
             bz = components_b(3,b)
             b1 = index_b(bx+1,by,bz)
             b2 = index_b(bx,by+1,bz)
             b3 = index_b(bx,by,bz+1)
             do d = 1, dub
               do c = 1, cub
                 escd_bcd = escd(b,c,d)
                 abcd(1,b,c,d) = escd(b1,c,d) + BAx * escd_bcd
                 abcd(2,b,c,d) = escd(b2,c,d) + BAy * escd_bcd
                 abcd(3,b,c,d) = escd(b3,c,d) + BAz * escd_bcd
               end
             end
           end
         end

       case default
         blb = (.b.l-1).n_comp_sum
         BA   = .pos_b - .pos_a
         bub  = (.ab_l_sum-1).n_comp_sum - blb
         aub  = .a.n_comp
         cub  = .c.n_comp
         dub  = .d.n_comp

         index_b => .ab_hrr_index_larger
         index_a => .ab_hrr_index_smaller
         components_b => .ab_hrr_components(:,blb+1:)

         nullify(int_new)
         int_new.create(cub,dub,bub,aub)

         BAx = BA(1);    BAy = BA(2);    BAz = BA(3)
         do b = 1, bub
           bx = components_b(1,b)
           by = components_b(2,b)
           bz = components_b(3,b)
           b1 = index_b(bx+1,by,bz)
           b2 = index_b(bx,by+1,bz)
           b3 = index_b(bx,by,bz+1)
           do c = 1, cub
             do d = 1, dub
               escd_bcd = escd(b,c,d)
               int_new(c,d,b,1) = escd(b1,c,d) + BAx * escd_bcd
               int_new(c,d,b,2) = escd(b2,c,d) + BAy * escd_bcd
               int_new(c,d,b,3) = escd(b3,c,d) + BAz * escd_bcd
             end
           end
         end

         do la=2, .a.l - 1
           alb              = (la-1).n_comp_sum
           aub              = la.n_comp
           bub              = (.ab_l_sum-la).n_comp_sum - blb
           component_to_use => .ab_hrr_comp_to_use(alb+1:alb+aub)
           components_a     => .ab_hrr_components(:,alb+1:alb+aub)
           int_old          => int_new
           nullify(int_new)
           int_new.create(cub,dub,bub,aub)
           do a=1,aub
             ax = components_a(1,a)
             ay = components_a(2,a)
             az = components_a(3,a)
             j=component_to_use(a)
             .subtract_from_component(ax,ay,az,j)
             a1 = index_a(ax,ay,az)
             BAi=BA(j)
             do b=1,bub
               bx = components_b(1,b)
               by = components_b(2,b)
               bz = components_b(3,b)
               .add_to_component(bx,by,bz,j)
               b1 = index_b(bx,by,bz)
               int_new(:,:,b,a)=int_old(:,:,b1,a1) + BAi * int_old(:,:,b,a1)
             end
           end
           int_old.destroy
         end

         alb              = (.a.l-1).n_comp_sum
         aub              = .a.n_comp
         bub              = .b.n_comp
         component_to_use => .ab_hrr_comp_to_use(alb+1:alb+aub)
         components_a     => .ab_hrr_components(:,alb+1:alb+aub)
         int_old          => int_new
         do a=1,aub
           ax = components_a(1,a)
           ay = components_a(2,a)
           az = components_a(3,a)
           j = component_to_use(a)
           .subtract_from_component(ax,ay,az,j)
           a1 = index_a(ax,ay,az)
           BAi=BA(j)
           do b=1,bub
             bx = components_b(1,b)
             by = components_b(2,b)
             bz = components_b(3,b)
             .add_to_component(bx,by,bz,j)
             b1 = index_b(bx,by,bz)
             abcd(a,b,:,:)=int_old(:,:,b1,a1) + BAi * int_old(:,:,b,a1)
           end
         end
         int_old.destroy
     end
   end

   transfer_l_a_highest(escd,abcd) ::: private
   ! Applies the transfer equation to (es|cd) to give (ab|cd)
     self :: IN
     escd :: REALMAT, IN
     abcd :: REALMAT3, OUT
     int_new,int_old :: REALMAT3*
     components_a,components_b :: INTMAT*
     index_a,index_b :: INTMAT3*
     component_to_use :: INTVEC*
     AB :: REALVEC(3)
     a,b,f,a1,a2,a3,b1,lb,aub,bub,fub :: INT
     ax,ay,az,bx,by,bz,j,alb,blb :: INT
     ABi,ABx,ABy,ABz,escd_acd :: REAL

     select case (.b.l)
       case (0)
         abcd(:,1,:)=escd

       case (1)
         if (.a.l==1) then
           AB   = .pos_b - .pos_a
           ABx = AB(1);    ABy = AB(2);    ABz = AB(3)
           fub  = size(escd,2)
           do f = 1, fub
             escd_acd = escd(1,f)
             abcd(1,1,f) = escd(4,f) + ABx * escd_acd
             abcd(1,2,f) = escd(7,f) + ABy * escd_acd
             abcd(1,3,f) = escd(8,f) + ABz * escd_acd
             escd_acd = escd(2,f)
             abcd(2,1,f) = escd(7,f) + ABx * escd_acd
             abcd(2,2,f) = escd(5,f) + ABy * escd_acd
             abcd(2,3,f) = escd(9,f) + ABz * escd_acd
             escd_acd = escd(3,f)
             abcd(3,1,f) = escd(8,f) + ABx * escd_acd
             abcd(3,2,f) = escd(9,f) + ABy * escd_acd
             abcd(3,3,f) = escd(6,f) + ABz * escd_acd
           end
         else
           alb = (.a.l-1).n_comp_sum
           AB   = .pos_a - .pos_b
           aub  = .a.n_comp
           fub  = size(escd,2)
           components_a => .ab_hrr_components(:,alb+1:)
           index_a => .ab_hrr_index_larger
           ABx=AB(1); ABy=AB(2); ABz=AB(3)
           do a=1,aub
             ax = components_a(1,a)
             ay = components_a(2,a)
             az = components_a(3,a)
             a1 = index_a(ax+1,ay,az)
             a2 = index_a(ax,ay+1,az)
             a3 = index_a(ax,ay,az+1)
             do f=1,fub
               escd_acd = escd(a,f)
               abcd(a,1,f)=escd(a1,f) + ABx * escd_acd
               abcd(a,2,f)=escd(a2,f) + ABy * escd_acd
               abcd(a,3,f)=escd(a3,f) + ABz * escd_acd
             end
           end
         end

       case default
         alb = (.a.l-1).n_comp_sum
         AB   = .pos_a - .pos_b
         aub  = (.ab_l_sum-1).n_comp_sum - alb
         bub  = .b.n_comp
         fub  = size(escd,2)

         index_a => .ab_hrr_index_larger
         index_b => .ab_hrr_index_smaller
         components_a => .ab_hrr_components(:,alb+1:)

         nullify(int_new)
         int_new.create(fub,bub,aub)
         ABx=AB(1); ABy=AB(2); ABz=AB(3)
         do a=1,aub
           ax = components_a(1,a)
           ay = components_a(2,a)
           az = components_a(3,a)
           a1 = index_a(ax+1,ay,az)
           a2 = index_a(ax,ay+1,az)
           a3 = index_a(ax,ay,az+1)
           do f=1,fub
             escd_acd = escd(a,f)
             int_new(f,1,a)=escd(a1,f) + ABx * escd_acd
             int_new(f,2,a)=escd(a2,f) + ABy * escd_acd
             int_new(f,3,a)=escd(a3,f) + ABz * escd_acd
           end
         end

         do lb=2, .b.l - 1
           blb              = (lb-1).n_comp_sum
           bub              = lb.n_comp
           aub              = (.ab_l_sum-lb).n_comp_sum - alb
           component_to_use => .ab_hrr_comp_to_use(blb+1:blb+bub)
           components_b     => .ab_hrr_components(:,blb+1:blb+bub)
           int_old          => int_new
           nullify(int_new)
           int_new.create(fub,bub,aub)
           do b=1,bub
             bx = components_b(1,b)
             by = components_b(2,b)
             bz = components_b(3,b)
             j = component_to_use(b)
             .subtract_from_component(bx,by,bz,j)
             b1 = index_b(bx,by,bz)
             ABi=AB(j)
             do a=1,aub
               ax = components_a(1,a)
               ay = components_a(2,a)
               az = components_a(3,a)
               .add_to_component(ax,ay,az,j)
               a1 = index_a(ax,ay,az)
               int_new(:,b,a)=int_old(:,b1,a1) + ABi * int_old(:,b1,a)
             end
           end
           int_old.destroy
         end

         blb              = (.b.l-1).n_comp_sum
         bub              = .b.n_comp
         aub              = .a.n_comp
         component_to_use => .ab_hrr_comp_to_use(blb+1:blb+bub)
         components_b     => .ab_hrr_components(:,blb+1:blb+bub)
         int_old          => int_new
         do b=1,bub
           bx = components_b(1,b)
           by = components_b(2,b)
           bz = components_b(3,b)
           j = component_to_use(b)
           .subtract_from_component(bx,by,bz,j)
           b1 = index_b(bx,by,bz)
           ABi=AB(j)
           do a=1,aub
             ax = components_a(1,a)
             ay = components_a(2,a)
             az = components_a(3,a)
             .add_to_component(ax,ay,az,j)
             a1 = index_a(ax,ay,az)
             do f=1,fub
               abcd(a,b,f)=int_old(f,b1,a1) + ABi * int_old(f,b1,a)
             end
           end
         end
         int_old.destroy
     end
   end

   transfer_l_b_highest(escd,abcd) ::: private
   ! Applies the transfer equation to (es|cd) to give (ab|cd)
     self :: IN
     escd :: REALMAT, IN
     abcd :: REALMAT3, OUT
     int_new,int_old :: REALMAT3*
     components_a,components_b :: INTMAT*
     index_a,index_b :: INTMAT3*
     component_to_use :: INTVEC*
     BA :: REALVEC(3)
     a,b,f,a1,b1,b2,b3,la,aub,bub,fub :: INT
     ax,ay,az,bx,by,bz,j,alb,blb :: INT
     BAi,BAx,BAy,BAz,escd_bcd :: REAL

     select case (.a.l)
       case (0)
         abcd(1,:,:)=escd

       case (1)
         if (.b.l==1) then
           BA   = .pos_b - .pos_a
           BAx = BA(1);    BAy = BA(2);    BAz = BA(3)
           fub  = size(escd,2)
           do f = 1, fub
             escd_bcd = escd(1,f)
             abcd(1,1,f) = escd(4,f) + BAx * escd_bcd
             abcd(2,1,f) = escd(7,f) + BAy * escd_bcd
             abcd(3,1,f) = escd(8,f) + BAz * escd_bcd
             escd_bcd = escd(2,f)
             abcd(1,2,f) = escd(7,f) + BAx * escd_bcd
             abcd(2,2,f) = escd(5,f) + BAy * escd_bcd
             abcd(3,2,f) = escd(9,f) + BAz * escd_bcd
             escd_bcd = escd(3,f)
             abcd(1,3,f) = escd(8,f) + BAx * escd_bcd
             abcd(2,3,f) = escd(9,f) + BAy * escd_bcd
             abcd(3,3,f) = escd(6,f) + BAz * escd_bcd
           end
         else
           blb = (.b.l-1).n_comp_sum
           BA   = .pos_b - .pos_a
           bub  = .b.n_comp
           fub  = size(escd,2)
           components_b => .ab_hrr_components(:,blb+1:)
           index_b => .ab_hrr_index_larger
           BAx = BA(1);    BAy = BA(2);    BAz = BA(3)
           do b = 1, bub
             bx = components_b(1,b)
             by = components_b(2,b)
             bz = components_b(3,b)
             b1 = index_b(bx+1,by,bz)
             b2 = index_b(bx,by+1,bz)
             b3 = index_b(bx,by,bz+1)
             do f = 1, fub
               escd_bcd = escd(b,f)
               abcd(1,b,f) = escd(b1,f) + BAx * escd_bcd
               abcd(2,b,f) = escd(b2,f) + BAy * escd_bcd
               abcd(3,b,f) = escd(b3,f) + BAz * escd_bcd
             end
           end
         end

       case default
         blb = (.b.l-1).n_comp_sum
         BA   = .pos_b - .pos_a
         bub  = (.ab_l_sum-1).n_comp_sum - blb
         aub  = .a.n_comp
         fub  = size(escd,2)

         index_b => .ab_hrr_index_larger
         index_a => .ab_hrr_index_smaller
         components_b => .ab_hrr_components(:,blb+1:)

         nullify(int_new)
         int_new.create(fub,bub,aub)

         BAx = BA(1);    BAy = BA(2);    BAz = BA(3)
         do b = 1, bub
           bx = components_b(1,b)
           by = components_b(2,b)
           bz = components_b(3,b)
           b1 = index_b(bx+1,by,bz)
           b2 = index_b(bx,by+1,bz)
           b3 = index_b(bx,by,bz+1)
           do f = 1, fub
             escd_bcd = escd(b,f)
             int_new(f,b,1) = escd(b1,f) + BAx * escd_bcd
             int_new(f,b,2) = escd(b2,f) + BAy * escd_bcd
             int_new(f,b,3) = escd(b3,f) + BAz * escd_bcd
           end
         end

         do la=2, .a.l - 1
           alb              = (la-1).n_comp_sum
           aub              = la.n_comp
           bub              = (.ab_l_sum-la).n_comp_sum - blb
           component_to_use => .ab_hrr_comp_to_use(alb+1:alb+aub)
           components_a     => .ab_hrr_components(:,alb+1:alb+aub)
           int_old          => int_new
           nullify(int_new)
           int_new.create(fub,bub,aub)
           do a=1,aub
             ax = components_a(1,a)
             ay = components_a(2,a)
             az = components_a(3,a)
             j=component_to_use(a)
             .subtract_from_component(ax,ay,az,j)
             a1 = index_a(ax,ay,az)
             BAi=BA(j)
             do b=1,bub
               bx = components_b(1,b)
               by = components_b(2,b)
               bz = components_b(3,b)
               .add_to_component(bx,by,bz,j)
               b1 = index_b(bx,by,bz)
               int_new(:,b,a)=int_old(:,b1,a1) + BAi * int_old(:,b,a1)
             end
           end
           int_old.destroy
         end

         alb              = (.a.l-1).n_comp_sum
         aub              = .a.n_comp
         bub              = .b.n_comp
         component_to_use => .ab_hrr_comp_to_use(alb+1:alb+aub)
         components_a     => .ab_hrr_components(:,alb+1:alb+aub)
         int_old          => int_new
         do a=1,aub
           ax = components_a(1,a)
           ay = components_a(2,a)
           az = components_a(3,a)
           j = component_to_use(a)
           .subtract_from_component(ax,ay,az,j)
           a1 = index_a(ax,ay,az)
           BAi=BA(j)
           do b=1,bub
             bx = components_b(1,b)
             by = components_b(2,b)
             bz = components_b(3,b)
             .add_to_component(bx,by,bz,j)
             b1 = index_b(bx,by,bz)
             do f=1,fub
               abcd(a,b,f)=int_old(f,b1,a1) + BAi * int_old(f,b,a1)
             end
           end
         end
         int_old.destroy
     end
   end

   add_to_component(x,y,z,j) ::: private, always_pure
   ! Adds one to the component specified by j.  Used by transfer equation.
   ! j=1 => x=x+1, j=2 => y=y+1, j=3 => z=z+1.
     self :: IN
     x,y,z :: INT, INOUT
     j :: INT, IN
     select case(j)
       case (1); x = x + 1
       case (2); y = y + 1
       case (3); z = z + 1
     end
   end

   subtract_from_component(x,y,z,j) ::: private, always_pure
   ! Subtracts one from the component specified by j.  Used by transfer
   ! equation.  j=1 => x=x-1, j=2 => y=y-1, j=3 => z=z-1.
     self :: IN
     x,y,z :: INT, INOUT
     j :: INT, IN
     select case(j)
       case (1); x = x - 1
       case (2); y = y - 1
       case (3); z = z - 1
     end
   end

 !******************************************************************************
 !                  Normalisation routines.
 !******************************************************************************

   to_normalise(abcd) ::: pure
   ! Multiply the matrix by the orbital normalisation coefficients
   ! for the orbitals a, b, c and d.
     self :: IN
     abcd :: REALMAT4, INOUT
     aub,bub,cub,dub,a,b,c,d,opt,i,j :: INT
     norm_cd :: REAL

     opt = 0
     if (.ab_l_max < 2) opt = opt + 1
     if (.cd_l_max < 2) opt = opt + 2
     select case (opt)
       case (0)
         aub=.a.n_comp
         bub=.b.n_comp
         cub=.c.n_comp
         dub=.d.n_comp
         j = 0
         do d=1,dub
           do c=1,cub
             j = j + 1
             norm_cd=.cd_normalising_factors(j)
             i = 0
             do b=1,bub
               do a=1,aub
                 i = i+1
                 abcd(a,b,c,d)=abcd(a,b,c,d)*norm_cd*.ab_normalising_factors(i)
               end
             end
           end
         end

       case (1)
         cub = .c.n_comp
         dub = .d.n_comp
         j = 0
         do d=1,dub
           do c=1,cub
             j = j + 1
             abcd(:,:,c,d)=abcd(:,:,c,d)*.cd_normalising_factors(j)
           end
         end
       case (2)
         aub = .a.n_comp
         bub = .b.n_comp
         cub = .c.n_comp
         dub = .d.n_comp
         do d=1,dub
           do c=1,cub
             i = 0
             do b=1,bub
               do a=1,aub
                 i = i + 1
                 abcd(a,b,c,d)=abcd(a,b,c,d)*.ab_normalising_factors(i)
               end
             end
           end
         end
       case (3)
         ! do nothing
     end
   end

   to_normalise(X) ::: pure
   ! Multiply the matrix by the orbital normalisation coefficients for the
   ! orbitals a, b, c and d.
     self :: IN
     X :: REALMAT5, INOUT
     i,dim :: INT
     dim = size(X,5)
     do i = 1,dim
        .to_normalise(X(:,:,:,:,i))
     end
   end

   to_normalise_ecd(ecd) ::: private, pure
   ! Multiply the matrix by the orbital normalisation coefficients for the
   ! orbitals where either a.l or b.l = 0.  This routine works on a REALMAT3.
     self :: IN
     ecd :: REALMAT3, INOUT
     cub,dub,c,d,opt,j :: INT

     opt = 0
     if (.ab_l_max < 2) opt = opt + 1
     if (.cd_l_max < 2) opt = opt + 2
     select case (opt)
       case (0)
         cub=.c.n_comp
         dub=.d.n_comp
         j = 0
         do d=1,dub
           do c=1,cub
             j = j + 1
             ecd(:,c,d)=ecd(:,c,d) * &
                    .ab_normalising_factors(:)*.cd_normalising_factors(j)
           end
         end
       case (1)
         cub = .c.n_comp
         dub = .d.n_comp
         j = 0
         do d=1,dub
           do c=1,cub
             j = j + 1
             ecd(:,c,d)=ecd(:,c,d)* .cd_normalising_factors(j)
           end
         end
       case (2)
         cub = .c.n_comp
         dub = .d.n_comp
         do d=1,dub
           do c=1,cub
             ecd(:,c,d)=ecd(:,c,d) * .ab_normalising_factors(:)
           end
         end
       case (3)
         ! do nothing
     end
   end

   to_normalise_abf(abf) ::: private, pure
   ! Multiply the matrix by the orbital normalisation coefficients for the
   ! orbitals where either c.l or d.l = 0.  This routine works on a REALMAT3.
     self :: IN
     abf :: REALMAT3, INOUT
     aub,bub,fub,a,b,f,opt,i :: INT
     normf :: REAL

     opt = 0
     if (.cd_l_max < 2) opt = opt + 1
     if (.ab_l_max < 2) opt = opt + 2
     select case (opt)
       case (0)
         aub = .a.n_comp
         bub = .b.n_comp
         fub = max(.c.n_comp,.d.n_comp)
         do f=1,fub
           normf=.cd_normalising_factors(f)
           i = 0
           do b=1,bub
             do a=1,aub
               i = i + 1
               abf(a,b,f)=abf(a,b,f) * .ab_normalising_factors(i)*normf
             end
           end
         end
       case (1)
         aub = .a.n_comp
         bub = .b.n_comp
         fub = max(.c.n_comp,.d.n_comp)
         do f=1,fub
           i = 0
           do b=1,bub
             do a=1,aub
               i = i + 1
               abf(a,b,f)=abf(a,b,f) * .ab_normalising_factors(i)
             end
           end
         end
       case (2)
         fub = max(.c.n_comp,.d.n_comp)
         do f=1,fub
           abf(:,:,f)=abf(:,:,f) * .cd_normalising_factors(f)
         end
       case (3)
         ! do nothing
     end
   end

!*******************************************************************************
!       make the J and K contributions from the shell4 and density matrix.
!*******************************************************************************

   make_r_JK(J,K,P,factor,fa,la,fb,lb,fc,lc,fd,ld)
   ! Make the restricted part of the J and K matrices from the density elements
   ! in P, and the two electron integrals calculated from self.
     self :: IN
     J,K :: REALMAT, INOUT
      P :: REALMAT, IN
     factor :: REAL, IN
     fa,la,fb,lb,fc,lc,fd,ld :: INT, IN
     opt :: INT
     opt = 0
     if (.d.l==0) opt = opt + 1
     if (.c.l==0) opt = opt + 2
     if (.b.l==0) opt = opt + 4
     if (.a.l==0) opt = opt + 8
     select case (opt)
       case (0);  .make_r_JK_abcd(J,K,P,factor,fa,la,fb,lb,fc,lc,fd,ld) ! abcd
       case (1);  .make_r_JK_abcs(J,K,P,factor,fa,la,fb,lb,fc,lc,fd) ! abcs
       case (2);  .make_r_JK_absd(J,K,P,factor,fa,la,fb,lb,fc,fd,ld) ! absd
       case (3);  .make_r_JK_abss(J,K,P,factor,fa,la,fb,lb,fc,fd) ! abss
       case (4);  .make_r_JK_ascd(J,K,P,factor,fa,la,fb,fc,lc,fd,ld) ! ascd
       case (5);  .make_r_JK_ascs(J,K,P,factor,fa,la,fb,fc,lc,fd) ! ascs
       case (6);  .make_r_JK_assd(J,K,P,factor,fa,la,fb,fc,fd,ld) ! assd
       case (7);  .make_r_JK_asss(J,K,P,factor,fa,la,fb,fc,fd) ! asss
       case (8);  .make_r_JK_sbcd(J,K,P,factor,fa,fb,lb,fc,lc,fd,ld) ! sbcd
       case (9);  .make_r_JK_sbcs(J,K,P,factor,fa,fb,lb,fc,lc,fd) ! sbcs
       case (10); .make_r_JK_sbsd(J,K,P,factor,fa,fb,lb,fc,fd,ld) ! sbsd
       case (11); .make_r_JK_sbss(J,K,P,factor,fa,fb,lb,fc,fd) ! sbss
       case (12); .make_r_JK_sscd(J,K,P,factor,fa,fb,fc,lc,fd,ld) ! sscd
       case (13); .make_r_JK_sscs(J,K,P,factor,fa,fb,fc,lc,fd) ! sscs
       case (14); .make_r_JK_sssd(J,K,P,factor,fa,fb,fc,fd,ld) ! sssd
       case (15); .make_r_JK_ssss(J,K,P,factor,fa,fb,fc,fd) ! ssss
     end
   end

   make_r_JK_ssss(J,K,P,factor,fa,fb,fc,fd) ::: private
   ! Make the J and K contribution due to self and P and add it in.
   ! For an ssss shell4 only!
     self :: IN
     P :: REALMAT, IN
     J,K :: REALMAT, INOUT
     fa,fb,fc,fd :: INT, IN
     factor :: REAL, IN
     I0,I_abcd :: REAL
     if (.ab_n_gaussian_pairs > n_cc_cutoff) then
       .make_ssss(I0)
     else
       .make_ssss_low_ncc(I0)
     end
     I_abcd = factor * I0
     J(fa,fb) = J(fa,fb) + I_abcd*P(fd,fc)
     J(fc,fd) = J(fc,fd) + I_abcd*P(fb,fa)
     K(fa,fc) = K(fa,fc) + I_abcd*P(fd,fb)
     K(fa,fd) = K(fa,fd) + I_abcd*P(fc,fb)
     K(fb,fc) = K(fb,fc) + I_abcd*P(fd,fa)
     K(fb,fd) = K(fb,fd) + I_abcd*P(fc,fa)
   end

   make_r_JK_abcd(J,K,P,factor,fa,la,fb,lb,fc,lc,fd,ld) ::: private
   ! Make the J and K contribution due to self and P and add it in.
   ! For any shell4!
     self :: IN
     P :: REALMAT, IN
     J,K :: REALMAT, target
     fa,la,fb,lb,fc,lc,fd,ld :: INT, IN
     factor :: REAL, IN
     I4 :: REALMAT4*
     Kc,Kd :: REALVEC*
     P_dc,Jcd,P_db,P_cb,Kbc,Kbd,I_abcd :: REAL
     a,b,c,d :: INT
     I4.create(fa,la,fb,lb,fc,lc,fd,ld)
     if (.a.l==1 AND .b.l==1 AND .c.l==1 AND .d.l==1) then
       if (.ab_n_gaussian_pairs > n_cc_cutoff) then
         .make_pppp(I4)
       else
         .make_pppp_low_ncc(I4)
       end
     else
       .make_abcd(I4)
     end
     if (factor > 0.9) then
       do d = fd,ld
         Kd => K(:,d)
         do c = fc,lc
           P_dc = P(d,c)
           Kc => K(:,c)
           Jcd = ZERO
           do b = fb,lb
             P_db = P(d,b)
             P_cb = P(c,b)
             Kbc = ZERO
             Kbd = ZERO
             do a = fa,la
               I_abcd = I4(a,b,c,d)
               J(a,b) = J(a,b) + I_abcd*P_dc
               Kc(a)  = Kc(a)  + I_abcd*P_db
               Kd(a)  = Kd(a)  + I_abcd*P_cb
               Jcd    = Jcd    + I_abcd*P(b,a)
               Kbc    = Kbc    + I_abcd*P(d,a)
               Kbd    = Kbd    + I_abcd*P(c,a)
             end
             Kc(b) = Kc(b) + Kbc
             Kd(b) = Kd(b) + Kbd
           end
           J(c,d) = J(c,d) + Jcd
         end
       end
     else if (.a.l<2) then
       do d = fd,ld
         Kd => K(:,d)
         do c = fc,lc
           P_dc = P(d,c)
           Kc => K(:,c)
           Jcd = ZERO
           do b = fb,lb
             P_db = P(d,b)
             P_cb = P(c,b)
             Kbc = ZERO
             Kbd = ZERO
             do a = fa,la
               I_abcd = factor*I4(a,b,c,d)
               J(a,b) = J(a,b) + I_abcd*P_dc
               Kc(a)  = Kc(a)  + I_abcd*P_db
               Kd(a)  = Kd(a)  + I_abcd*P_cb
               Jcd    = Jcd    + I_abcd*P(b,a)
               Kbc    = Kbc    + I_abcd*P(d,a)
               Kbd    = Kbd    + I_abcd*P(c,a)
             end
             Kc(b) = Kc(b) + Kbc
             Kd(b) = Kd(b) + Kbd
           end
           J(c,d) = J(c,d) + Jcd
         end
       end
     else
       do d = fd,ld
         Kd => K(:,d)
         do c = fc,lc
           P_dc = factor*P(d,c)
           Kc => K(:,c)
           Jcd = ZERO
           do b = fb,lb
             P_db = factor*P(d,b)
             P_cb = factor*P(c,b)
             Kbc = ZERO
             Kbd = ZERO
             do a = fa,la
               I_abcd = I4(a,b,c,d)
               J(a,b) = J(a,b) + I_abcd*P_dc
               Kc(a)  = Kc(a)  + I_abcd*P_db
               Kd(a)  = Kd(a)  + I_abcd*P_cb
               Jcd    = Jcd    + I_abcd*P(b,a)
               Kbc    = Kbc    + I_abcd*P(d,a)
               Kbd    = Kbd    + I_abcd*P(c,a)
             end
             Kc(b) = Kc(b) + factor*Kbc
             Kd(b) = Kd(b) + factor*Kbd
           end
           J(c,d) = J(c,d) + factor*Jcd
         end
       end
     end
     I4.destroy
   end

   make_r_JK_sscd(J,K,P,factor,fa,fb,fc,lc,fd,ld) ::: private
   ! Make the J and K contribution due to self and P and add it in.
   ! For an sscd shell4 only!
     self :: IN
     P :: REALMAT, IN
     J,K :: REALMAT, INOUT
     fa,fb,fc,lc,fd,ld :: INT, IN
     factor :: REAL, IN
     I2 :: REALMAT*
     P_db,P_da,P_ba,Kbd,Kad,Jab,I_abcd :: REAL
     c,d :: INT
     I2.create(fc,lc,fd,ld)
     if (.c.l==1 AND .d.l==1) then
       if (.ab_n_gaussian_pairs > n_cc_cutoff) then
         .make_sspp(I2)
       else
         .make_sspp_low_ncc(I2)
       end
     else
       .make_sscd(I2)
     end
     if (factor > 0.9) then
       Jab = ZERO
       P_ba = P(fb,fa)
       do d = fd,ld
         Kad = ZERO
         Kbd = ZERO
         P_da = P(d,fa)
         P_db = P(d,fb)
         do c = fc,lc
           I_abcd = I2(c,d)
           Jab     = Jab     + I_abcd*P(d,c)
           J(c,d)  = J(c,d)  + I_abcd*P_ba
           K(fa,c) = K(fa,c) + I_abcd*P_db
           K(fb,c) = K(fb,c) + I_abcd*P_da
           Kad     = Kad     + I_abcd*P(c,fb)
           Kbd     = Kbd     + I_abcd*P(c,fa)
         end
         K(fa,d) = K(fa,d) + Kad
         K(fb,d) = K(fb,d) + Kbd
       end
       J(fa,fb) = J(fa,fb) + Jab
     else if (.c.l<2) then
       Jab = ZERO
       P_ba = P(fb,fa)
       do d = fd,ld
         Kad = ZERO
         Kbd = ZERO
         P_da = P(d,fa)
         P_db = P(d,fb)
         do c = fc,lc
           I_abcd = factor*I2(c,d)
           Jab     = Jab     + I_abcd*P(d,c)
           J(c,d)  = J(c,d)  + I_abcd*P_ba
           K(fa,c) = K(fa,c) + I_abcd*P_db
           K(fb,c) = K(fb,c) + I_abcd*P_da
           Kad     = Kad     + I_abcd*P(c,fb)
           Kbd     = Kbd     + I_abcd*P(c,fa)
         end
         K(fa,d) = K(fa,d) + Kad
         K(fb,d) = K(fb,d) + Kbd
       end
       J(fa,fb) = J(fa,fb) + Jab
     else
       Jab = ZERO
       P_ba = factor*P(fb,fa)
       do d = fd,ld
         Kad = ZERO
         Kbd = ZERO
         P_da = factor*P(d,fa)
         P_db = factor*P(d,fb)
         do c = fc,lc
           I_abcd = I2(c,d)
           Jab     = Jab     + I_abcd*P(d,c)
           J(c,d)  = J(c,d)  + I_abcd*P_ba
           K(fa,c) = K(fa,c) + I_abcd*P_db
           K(fb,c) = K(fb,c) + I_abcd*P_da
           Kad     = Kad     + I_abcd*P(c,fb)
           Kbd     = Kbd     + I_abcd*P(c,fa)
         end
         K(fa,d) = K(fa,d) + factor*Kad
         K(fb,d) = K(fb,d) + factor*Kbd
       end
       J(fa,fb) = J(fa,fb) + factor*Jab
     end
     I2.destroy
   end

   make_r_JK_abcs(J,K,P,factor,fa,la,fb,lb,fc,lc,fd) ::: private
   ! Make the J and K contribution due to self and P and add it in.
   ! For an abcs shell4!
     self :: IN
     P :: REALMAT, IN
     J,K :: REALMAT, INOUT
     fa,la,fb,lb,fc,lc,fd :: INT, IN
     factor :: REAL, IN
     I3 :: REALMAT3*
     P_dc,Jcd,P_db,P_cb,Kbc,Kbd,I_abcd :: REAL
     a,b,c :: INT
     I3.create(fa,la,fb,lb,fc,lc)
     if (.a.l==1 AND .b.l==1 AND .c.l==1) then
       if (.ab_n_gaussian_pairs > n_cc_cutoff) then
         .make_ppps(I3)
       else
         .make_ppps_low_ncc(I3)
       end
     else
       .make_abcs(I3)
     end
     if (factor > 0.9) then
       do c = fc,lc
         P_dc = P(fd,c)
         Jcd = ZERO
         do b = fb,lb
           P_db = P(fd,b)
           P_cb = P(c,b)
           Kbc = ZERO
           Kbd = ZERO
           do a = fa,la
             I_abcd  = I3(a,b,c)
             J(a,b)  = J(a,b)  + I_abcd*P_dc
             Jcd     = Jcd     + I_abcd*P(b,a)
             K(a,c)  = K(a,c)  + I_abcd*P_db
             K(a,fd) = K(a,fd) + I_abcd*P_cb
             Kbc     = Kbc     + I_abcd*P(fd,a)
             Kbd     = Kbd     + I_abcd*P(c,a)
           end
           K(b,c)  = K(b,c)  + Kbc
           K(b,fd) = K(b,fd) + Kbd
         end
         J(c,fd) = J(c,fd) + Jcd
       end
     else if (.a.l<2) then
       do c = fc,lc
         P_dc = P(fd,c)
         Jcd = ZERO
         do b = fb,lb
           P_db = P(fd,b)
           P_cb = P(c,b)
           Kbc = ZERO
           Kbd = ZERO
           do a = fa,la
             I_abcd  = factor*I3(a,b,c)
             J(a,b)  = J(a,b)  + I_abcd*P_dc
             Jcd     = Jcd     + I_abcd*P(b,a)
             K(a,c)  = K(a,c)  + I_abcd*P_db
             K(a,fd) = K(a,fd) + I_abcd*P_cb
             Kbc     = Kbc     + I_abcd*P(fd,a)
             Kbd     = Kbd     + I_abcd*P(c,a)
           end
           K(b,c)  = K(b,c)  + Kbc
           K(b,fd) = K(b,fd) + Kbd
         end
         J(c,fd) = J(c,fd) + Jcd
       end
     else
       do c = fc,lc
         P_dc = factor*P(fd,c)
         Jcd = ZERO
         do b = fb,lb
           P_db = factor*P(fd,b)
           P_cb = factor*P(c,b)
           Kbc = ZERO
           Kbd = ZERO
           do a = fa,la
             I_abcd  = I3(a,b,c)
             J(a,b)  = J(a,b)  + I_abcd*P_dc
             Jcd     = Jcd     + I_abcd*P(b,a)
             K(a,c)  = K(a,c)  + I_abcd*P_db
             K(a,fd) = K(a,fd) + I_abcd*P_cb
             Kbc     = Kbc     + I_abcd*P(fd,a)
             Kbd     = Kbd     + I_abcd*P(c,a)
           end
           K(b,c)  = K(b,c)  + factor*Kbc
           K(b,fd) = K(b,fd) + factor*Kbd
         end
         J(c,fd) = J(c,fd) + factor*Jcd
       end
     end
     I3.destroy
   end

   make_r_JK_absd(J,K,P,factor,fa,la,fb,lb,fc,fd,ld) ::: private
   ! Make the J and K contribution due to self and P and add it in.
   ! For an absd shell4 only!
     self :: IN
     P :: REALMAT, IN
     J,K :: REALMAT, INOUT
     fa,la,fb,lb,fc,fd,ld :: INT, IN
     factor :: REAL, IN
     I3 :: REALMAT3*
     P_dc,Jcd,P_db,P_cb,Kbc,Kbd,I_abcd :: REAL
     a,b,d :: INT
     I3.create(fa,la,fb,lb,fd,ld)
     if (.a.l==1 AND .b.l==1 AND .d.l==1) then
       if (.ab_n_gaussian_pairs > n_cc_cutoff) then
         .make_ppps(I3)
       else
         .make_ppps_low_ncc(I3)
       end
     else
       .make_abcs(I3)
     end
     if (factor > 0.9) then
       do d = fd,ld
         P_dc = P(d,fc)
         Jcd = ZERO
         do b = fb,lb
           P_db = P(d,b)
           P_cb = P(fc,b)
           Kbc = ZERO
           Kbd = ZERO
           do a = fa,la
             I_abcd  = I3(a,b,d)
             J(a,b)  = J(a,b)  + I_abcd*P_dc
             Jcd     = Jcd     + I_abcd*P(b,a)
             K(a,fc) = K(a,fc) + I_abcd*P_db
             K(a,d)  = K(a,d)  + I_abcd*P_cb
             Kbc     = Kbc     + I_abcd*P(d,a)
             Kbd     = Kbd     + I_abcd*P(fc,a)
           end
           K(b,fc) = K(b,fc) + Kbc
           K(b,d)  = K(b,d)  + Kbd
         end
         J(fc,d) = J(fc,d) + Jcd
       end
     else if (.a.l<2) then
       do d = fd,ld
         P_dc = P(d,fc)
         Jcd = ZERO
         do b = fb,lb
           P_db = P(d,b)
           P_cb = P(fc,b)
           Kbc = ZERO
           Kbd = ZERO
           do a = fa,la
             I_abcd  = factor*I3(a,b,d)
             J(a,b)  = J(a,b)  + I_abcd*P_dc
             Jcd     = Jcd     + I_abcd*P(b,a)
             K(a,fc) = K(a,fc) + I_abcd*P_db
             K(a,d)  = K(a,d)  + I_abcd*P_cb
             Kbc     = Kbc     + I_abcd*P(d,a)
             Kbd     = Kbd     + I_abcd*P(fc,a)
           end
           K(b,fc) = K(b,fc) + Kbc
           K(b,d)  = K(b,d)  + Kbd
         end
         J(fc,d) = J(fc,d) + Jcd
       end
     else
       do d = fd,ld
         P_dc = factor*P(d,fc)
         Jcd = ZERO
         do b = fb,lb
           P_db = factor*P(d,b)
           P_cb = factor*P(fc,b)
           Kbc = ZERO
           Kbd = ZERO
           do a = fa,la
             I_abcd  = I3(a,b,d)
             J(a,b)  = J(a,b)  + I_abcd*P_dc
             Jcd     = Jcd     + I_abcd*P(b,a)
             K(a,fc) = K(a,fc) + I_abcd*P_db
             K(a,d)  = K(a,d)  + I_abcd*P_cb
             Kbc     = Kbc     + I_abcd*P(d,a)
             Kbd     = Kbd     + I_abcd*P(fc,a)
           end
           K(b,fc) = K(b,fc) + factor*Kbc
           K(b,d)  = K(b,d)  + factor*Kbd
         end
         J(fc,d) = J(fc,d) + factor*Jcd
       end
     end
     I3.destroy
   end

   make_r_JK_sbcd(J,K,P,factor,fa,fb,lb,fc,lc,fd,ld) ::: private
   ! Make the J and K contribution due to self and P and add it in.
   ! For a spcd shell4 only!
     self :: IN
     P :: REALMAT, IN
     J,K :: REALMAT, INOUT
     fa,fb,lb,fc,lc,fd,ld :: INT, IN
     factor :: REAL, IN
     I3 :: REALMAT3*
     Jab,P_ba,Kad,Kbd,P_da,P_db,I_abcd :: REAL
     b,c,d :: INT
     I3.create(fb,lb,fc,lc,fd,ld)
     if (.b.l==1 AND .c.l==1 AND .d.l==1) then
       if (.ab_n_gaussian_pairs > n_cc_cutoff) then
         .make_pspp(I3)
       else
         .make_pspp_low_ncc(I3)
       end
     else
       .make_ascd(I3)
     end
     if (factor > 0.9) then
       do b=fb,lb
         Jab = ZERO
         P_ba = P(b,fa)
         do d = fd,ld
           Kad = ZERO
           Kbd = ZERO
           P_da = P(d,fa)
           P_db = P(d,b)
           do c = fc,lc
             I_abcd  = I3(b,c,d)
             Jab     = Jab     + I_abcd*P(d,c)
             J(c,d)  = J(c,d)  + I_abcd*P_ba
             K(fa,c) = K(fa,c) + I_abcd*P_db
             K(b,c)  = K(b,c)  + I_abcd*P_da
             Kad     = Kad     + I_abcd*P(c,b)
             Kbd     = Kbd     + I_abcd*P(c,fa)
           end
           K(fa,d) = K(fa,d) + Kad
           K(b,d)  = K(b,d)  + Kbd
         end
         J(fa,b) = J(fa,b) + Jab
       end
     else if (.c.l<2) then
       do b=fb,lb
         Jab = ZERO
         P_ba = P(b,fa)
         do d = fd,ld
           Kad = ZERO
           Kbd = ZERO
           P_da = P(d,fa)
           P_db = P(d,b)
           do c = fc,lc
             I_abcd  = factor*I3(b,c,d)
             Jab     = Jab     + I_abcd*P(d,c)
             J(c,d)  = J(c,d)  + I_abcd*P_ba
             K(fa,c) = K(fa,c) + I_abcd*P_db
             K(b,c)  = K(b,c)  + I_abcd*P_da
             Kad     = Kad     + I_abcd*P(c,b)
             Kbd     = Kbd     + I_abcd*P(c,fa)
           end
           K(fa,d) = K(fa,d) + Kad
           K(b,d)  = K(b,d)  + Kbd
         end
         J(fa,b) = J(fa,b) + Jab
       end
     else
       do b=fb,lb
         Jab = ZERO
         P_ba = factor*P(b,fa)
         do d = fd,ld
           Kad = ZERO
           Kbd = ZERO
           P_da = factor*P(d,fa)
           P_db = factor*P(d,b)
           do c = fc,lc
             I_abcd  = I3(b,c,d)
             Jab     = Jab     + I_abcd*P(d,c)
             J(c,d)  = J(c,d)  + I_abcd*P_ba
             K(fa,c) = K(fa,c) + I_abcd*P_db
             K(b,c)  = K(b,c)  + I_abcd*P_da
             Kad     = Kad     + I_abcd*P(c,b)
             Kbd     = Kbd     + I_abcd*P(c,fa)
           end
           K(fa,d) = K(fa,d) + factor*Kad
           K(b,d)  = K(b,d)  + factor*Kbd
         end
         J(fa,b) = J(fa,b) + factor*Jab
       end
     end
     I3.destroy
   end

   make_r_JK_ascd(J,K,P,factor,fa,la,fb,fc,lc,fd,ld) ::: private
   ! Make the J and K contribution due to self and P and add it in.
   ! For a pscd shell4 only!
     self :: IN
     P :: REALMAT, IN
     J,K :: REALMAT, INOUT
     fa,la,fb,fc,lc,fd,ld :: INT, IN
     factor :: REAL, IN
     I3 :: REALMAT3*
     Jab,P_ba,Kad,Kbd,P_da,P_db,I_abcd :: REAL
     a,c,d :: INT
     I3.create(fa,la,fc,lc,fd,ld)
     if (.a.l==1 AND .c.l==1 AND .d.l==1) then
       if (.ab_n_gaussian_pairs > n_cc_cutoff) then
         .make_pspp(I3)
       else
         .make_pspp_low_ncc(I3)
       end
     else
       .make_ascd(I3)
     end
     if (factor > 0.9) then
       do a=fa,la
         Jab = ZERO
         P_ba = P(fb,a)
         do d = fd,ld
           Kad = ZERO
           Kbd = ZERO
           P_da = P(d,a)
           P_db = P(d,fb)
           do c = fc,lc
             I_abcd  = I3(a,c,d)
             Jab     = Jab     + I_abcd*P(d,c)
             J(c,d)  = J(c,d)  + I_abcd*P_ba
             K(a,c)  = K(a,c)  + I_abcd*P_db
             K(fb,c) = K(fb,c) + I_abcd*P_da
             Kad     = Kad     + I_abcd*P(c,fb)
             Kbd     = Kbd     + I_abcd*P(c,a)
           end
           K(a,d)  = K(a,d)  + Kad
           K(fb,d) = K(fb,d) + Kbd
         end
         J(a,fb) = J(a,fb) + Jab
       end
     else if (.c.l<2) then
       do a=fa,la
         Jab = ZERO
         P_ba = P(fb,a)
         do d = fd,ld
           Kad = ZERO
           Kbd = ZERO
           P_da = P(d,a)
           P_db = P(d,fb)
           do c = fc,lc
             I_abcd  = factor*I3(a,c,d)
             Jab     = Jab     + I_abcd*P(d,c)
             J(c,d)  = J(c,d)  + I_abcd*P_ba
             K(a,c)  = K(a,c)  + I_abcd*P_db
             K(fb,c) = K(fb,c) + I_abcd*P_da
             Kad     = Kad     + I_abcd*P(c,fb)
             Kbd     = Kbd     + I_abcd*P(c,a)
           end
           K(a,d)  = K(a,d)  + Kad
           K(fb,d) = K(fb,d) + Kbd
         end
         J(a,fb) = J(a,fb) + Jab
       end
     else
       do a=fa,la
         Jab = ZERO
         P_ba = factor*P(fb,a)
         do d = fd,ld
           Kad = ZERO
           Kbd = ZERO
           P_da = factor*P(d,a)
           P_db = factor*P(d,fb)
           do c = fc,lc
             I_abcd  = I3(a,c,d)
             Jab     = Jab     + I_abcd*P(d,c)
             J(c,d)  = J(c,d)  + I_abcd*P_ba
             K(a,c)  = K(a,c)  + I_abcd*P_db
             K(fb,c) = K(fb,c) + I_abcd*P_da
             Kad     = Kad     + I_abcd*P(c,fb)
             Kbd     = Kbd     + I_abcd*P(c,a)
           end
           K(a,d)  = K(a,d)  + factor*Kad
           K(fb,d) = K(fb,d) + factor*Kbd
         end
         J(a,fb) = J(a,fb) + factor*Jab
       end
     end
     I3.destroy
   end

   make_r_JK_abss(J,K,P,factor,fa,la,fb,lb,fc,fd) ::: private
   ! Make the J and K contribution due to self and P and add it in.
   ! For an abss shell4 only!
     self :: IN
     P :: REALMAT, IN
     J,K :: REALMAT, INOUT
     fa,la,fb,lb,fc,fd :: INT, IN
     factor :: REAL, IN
     I2 :: REALMAT*
     P_dc,Jcd,P_db,P_cb,Kbc,Kbd,I_abcd :: REAL
     a,b :: INT
     I2.create(fa,la,fb,lb)
     if (.a.l==1 AND .b.l==1) then
       if (.ab_n_gaussian_pairs > n_cc_cutoff) then
         .make_ppss(I2)
       else
         .make_ppss_low_ncc(I2)
       end
     else
       .make_abss(I2)
     end
     if (factor > 0.9) then
       Jcd = ZERO
       P_dc = P(fd,fc)
       do b = fb,lb
         Kbc = ZERO
         Kbd = ZERO
         P_db = P(fd,b)
         P_cb = P(fc,b)
         do a = fa,la
           I_abcd = I2(a,b)
           J(a,b) = J(a,b) + I_abcd*P_dc
           Jcd    = Jcd    + I_abcd*P(b,a)
           K(a,fc) = K(a,fc) + I_abcd*P_db
           K(a,fd) = K(a,fd) + I_abcd*P_cb
           Kbc    = Kbc    + I_abcd*P(fd,a)
           Kbd    = Kbd    + I_abcd*P(fc,a)
         end
         K(b,fc) = K(b,fc) + Kbc
         K(b,fd) = K(b,fd) + Kbd
       end
       J(fc,fd) = J(fc,fd) + Jcd
     else if (.a.l<2) then
       Jcd = ZERO
       P_dc = P(fd,fc)
       do b = fb,lb
         Kbc = ZERO
         Kbd = ZERO
         P_db = P(fd,b)
         P_cb = P(fc,b)
         do a = fa,la
           I_abcd = factor*I2(a,b)
           J(a,b) = J(a,b) + I_abcd*P_dc
           Jcd    = Jcd    + I_abcd*P(b,a)
           K(a,fc) = K(a,fc) + I_abcd*P_db
           K(a,fd) = K(a,fd) + I_abcd*P_cb
           Kbc    = Kbc    + I_abcd*P(fd,a)
           Kbd    = Kbd    + I_abcd*P(fc,a)
         end
         K(b,fc) = K(b,fc) + Kbc
         K(b,fd) = K(b,fd) + Kbd
       end
       J(fc,fd) = J(fc,fd) + Jcd
     else
       Jcd = ZERO
       P_dc = factor*P(fd,fc)
       do b = fb,lb
         Kbc = ZERO
         Kbd = ZERO
         P_db = factor*P(fd,b)
         P_cb = factor*P(fc,b)
         do a = fa,la
           I_abcd = I2(a,b)
           J(a,b) = J(a,b) + I_abcd*P_dc
           Jcd    = Jcd    + I_abcd*P(b,a)
           K(a,fc) = K(a,fc) + I_abcd*P_db
           K(a,fd) = K(a,fd) + I_abcd*P_cb
           Kbc    = Kbc    + I_abcd*P(fd,a)
           Kbd    = Kbd    + I_abcd*P(fc,a)
         end
         K(b,fc) = K(b,fc) + factor*Kbc
         K(b,fd) = K(b,fd) + factor*Kbd
       end
       J(fc,fd) = J(fc,fd) + factor*Jcd
     end
     I2.destroy
   end

   make_r_JK_ascs(J,K,P,factor,fa,la,fb,fc,lc,fd) ::: private
   ! Make the J and K contribution due to self and P and add it in.
   ! For a ascs shell4 only!
     self :: IN
     P :: REALMAT, IN
     J,K :: REALMAT, INOUT
     fa,la,fb,fc,lc,fd :: INT, IN
     factor :: REAL, IN
     I2 :: REALMAT*
     P_dc,Jcd,P_db,P_cb,Kbc,Kbd,I_abcd :: REAL
     a,c :: INT
     I2.create(fa,la,fc,lc)
     if (.a.l==1 AND .c.l==1) then
       if (.ab_n_gaussian_pairs > n_cc_cutoff) then
         .make_psps(I2)
       else
         .make_psps_low_ncc(I2)
       end
     else if (.a.l==2 AND .c.l==2) then
       if (.ab_n_gaussian_pairs > n_cc_cutoff) then
         .make_dsds(I2)
       else
         .make_dsds_low_ncc(I2)
       end
     else if (.a.l==2 AND .c.l==1) then
       if (.ab_n_gaussian_pairs > n_cc_cutoff) then
         .make_dsps(I2)
       else
         .make_dsps_low_ncc(I2)
       end
     else if (.a.l==1 AND .c.l==2) then
       if (.ab_n_gaussian_pairs > n_cc_cutoff) then
         .make_psds(I2)
       else
         .make_psds_low_ncc(I2)
       end
     else
       .make_ascs(I2)
     end
     if (factor > 0.9) then
       P_db = P(fd,fb)
       Kbd = ZERO
       do c = fc,lc
         P_dc = P(fd,c)
         P_cb = P(c,fb)
         Jcd = ZERO
         Kbc = ZERO
         do a = fa,la
           I_abcd  = I2(a,c)
           J(a,fb) = J(a,fb) + I_abcd*P_dc
           Jcd     = Jcd     + I_abcd*P(fb,a)
           K(a,c)  = K(a,c)  + I_abcd*P_db
           K(a,fd) = K(a,fd) + I_abcd*P_cb
           Kbc     = Kbc     + I_abcd*P(fd,a)
           Kbd     = Kbd     + I_abcd*P(c,a)
         end
         K(fb,c) = K(fb,c) + Kbc
         J(c,fd) = J(c,fd) + Jcd
       end
       K(fb,fd) = K(fb,fd) + Kbd
     else if (.a.l<2) then
       P_db = P(fd,fb)
       Kbd = ZERO
       do c = fc,lc
         P_dc = P(fd,c)
         P_cb = P(c,fb)
         Jcd = ZERO
         Kbc = ZERO
         do a = fa,la
           I_abcd  = factor*I2(a,c)
           J(a,fb) = J(a,fb) + I_abcd*P_dc
           Jcd     = Jcd     + I_abcd*P(fb,a)
           K(a,c)  = K(a,c)  + I_abcd*P_db
           K(a,fd) = K(a,fd) + I_abcd*P_cb
           Kbc     = Kbc     + I_abcd*P(fd,a)
           Kbd     = Kbd     + I_abcd*P(c,a)
         end
         K(fb,c) = K(fb,c) + Kbc
         J(c,fd) = J(c,fd) + Jcd
       end
       K(fb,fd) = K(fb,fd) + Kbd
     else
       P_db = factor*P(fd,fb)
       Kbd = ZERO
       do c = fc,lc
         P_dc = factor*P(fd,c)
         P_cb = factor*P(c,fb)
         Jcd = ZERO
         Kbc = ZERO
         do a = fa,la
           I_abcd  = I2(a,c)
           J(a,fb) = J(a,fb) + I_abcd*P_dc
           Jcd     = Jcd     + I_abcd*P(fb,a)
           K(a,c)  = K(a,c)  + I_abcd*P_db
           K(a,fd) = K(a,fd) + I_abcd*P_cb
           Kbc     = Kbc     + I_abcd*P(fd,a)
           Kbd     = Kbd     + I_abcd*P(c,a)
         end
         K(fb,c) = K(fb,c) + factor*Kbc
         J(c,fd) = J(c,fd) + factor*Jcd
       end
       K(fb,fd) = K(fb,fd) + factor*Kbd
     end
     I2.destroy
   end

   make_r_JK_assd(J,K,P,factor,fa,la,fb,fc,fd,ld) ::: private
   ! Make the J and K contribution due to self and P and add it in.
   ! For a assd shell4 only!
     self :: IN
     P :: REALMAT, IN
     J,K :: REALMAT, INOUT
     fa,la,fb,fc,fd,ld :: INT, IN
     factor :: REAL, IN
     I2 :: REALMAT*
     P_dc,Jcd,P_db,P_cb,Kbc,Kbd,I_abcd :: REAL
     a,d :: INT
     I2.create(fa,la,fd,ld)
     if (.a.l==1 AND .d.l==1) then
       if (.ab_n_gaussian_pairs > n_cc_cutoff) then
         .make_psps(I2)
       else
         .make_psps_low_ncc(I2)
       end
     else if (.a.l==2 AND .d.l==2) then
       if (.ab_n_gaussian_pairs > n_cc_cutoff) then
         .make_dsds(I2)
       else
         .make_dsds_low_ncc(I2)
       end
     else if (.a.l==2 AND .d.l==1) then
       if (.ab_n_gaussian_pairs > n_cc_cutoff) then
         .make_dsps(I2)
       else
         .make_dsps_low_ncc(I2)
       end
     else if (.a.l==1 AND .d.l==2) then
       if (.ab_n_gaussian_pairs > n_cc_cutoff) then
         .make_psds(I2)
       else
         .make_psds_low_ncc(I2)
       end
     else
       .make_ascs(I2)
     end
     if (factor > 0.9) then
       P_cb = P(fc,fb)
       Kbc = ZERO
       do d = fd,ld
         P_dc = P(d,fc)
         P_db = P(d,fb)
         Jcd = ZERO
         Kbd = ZERO
         do a = fa,la
           I_abcd  = I2(a,d)
           Jcd     = Jcd     + I_abcd*P(fb,a)
           Kbc     = Kbc     + I_abcd*P(d,a)
           Kbd     = Kbd     + I_abcd*P(fc,a)
           J(a,fb) = J(a,fb) + I_abcd*P_dc
           K(a,fc) = K(a,fc) + I_abcd*P_db
           K(a,d)  = K(a,d)  + I_abcd*P_cb
         end
         K(fb,d) = K(fb,d) + Kbd
         J(fc,d) = J(fc,d) + Jcd
       end
       K(fb,fc) = K(fb,fc) + Kbc
     else if (.a.l<2) then
       P_cb = P(fc,fb)
       Kbc = ZERO
       do d = fd,ld
         P_dc = P(d,fc)
         P_db = P(d,fb)
         Jcd = ZERO
         Kbd = ZERO
         do a = fa,la
           I_abcd  = factor*I2(a,d)
           Jcd     = Jcd     + I_abcd*P(fb,a)
           Kbc     = Kbc     + I_abcd*P(d,a)
           Kbd     = Kbd     + I_abcd*P(fc,a)
           J(a,fb) = J(a,fb) + I_abcd*P_dc
           K(a,fc) = K(a,fc) + I_abcd*P_db
           K(a,d)  = K(a,d)  + I_abcd*P_cb
         end
         K(fb,d) = K(fb,d) + Kbd
         J(fc,d) = J(fc,d) + Jcd
       end
       K(fb,fc) = K(fb,fc) + Kbc
     else
       P_cb = factor*P(fc,fb)
       Kbc = ZERO
       do d = fd,ld
         P_dc = factor*P(d,fc)
         P_db = factor*P(d,fb)
         Jcd = ZERO
         Kbd = ZERO
         do a = fa,la
           I_abcd  = I2(a,d)
           Jcd     = Jcd     + I_abcd*P(fb,a)
           Kbc     = Kbc     + I_abcd*P(d,a)
           Kbd     = Kbd     + I_abcd*P(fc,a)
           J(a,fb) = J(a,fb) + I_abcd*P_dc
           K(a,fc) = K(a,fc) + I_abcd*P_db
           K(a,d)  = K(a,d)  + I_abcd*P_cb
         end
         K(fb,d) = K(fb,d) + factor*Kbd
         J(fc,d) = J(fc,d) + factor*Jcd
       end
       K(fb,fc) = K(fb,fc) + factor*Kbc
     end
     I2.destroy
   end

   make_r_JK_sbcs(J,K,P,factor,fa,fb,lb,fc,lc,fd) ::: private
   ! Make the J and K contribution due to self and P and add it in.
   ! For a sbcs shell4 only!
     self :: IN
     P :: REALMAT, IN
     J,K :: REALMAT, INOUT
     fa,fb,lb,fc,lc,fd :: INT, IN
     factor :: REAL, IN
     I2 :: REALMAT*
     P_dc,Jcd,P_da,P_ca,Kac,Kad,I_abcd :: REAL
     b,c :: INT
     I2.create(fb,lb,fc,lc)
     if (.b.l==1 AND .c.l==1) then
       if (.ab_n_gaussian_pairs > n_cc_cutoff) then
         .make_psps(I2)
       else
         .make_psps_low_ncc(I2)
       end
     else if (.b.l==2 AND .c.l==2) then
       if (.ab_n_gaussian_pairs > n_cc_cutoff) then
         .make_dsds(I2)
       else
         .make_dsds_low_ncc(I2)
       end
     else if (.b.l==2 AND .c.l==1) then
       if (.ab_n_gaussian_pairs > n_cc_cutoff) then
         .make_dsps(I2)
       else
         .make_dsps_low_ncc(I2)
       end
     else if (.b.l==1 AND .c.l==2) then
       if (.ab_n_gaussian_pairs > n_cc_cutoff) then
         .make_psds(I2)
       else
         .make_psds_low_ncc(I2)
       end
     else
       .make_ascs(I2)
     end
     if (factor > 0.9) then
       Kad = ZERO
       P_da = P(fd,fa)
       do c = fc,lc
         P_dc = P(fd,c)
         P_ca = P(c,fa)
         Jcd = ZERO
         Kac = ZERO
         do b = fb,lb
           I_abcd  = I2(b,c)
           Jcd     = Jcd     + I_abcd*P(b,fa)
           Kac     = Kac     + I_abcd*P(fd,b)
           Kad     = Kad     + I_abcd*P(c,b)
           J(fa,b) = J(fa,b) + I_abcd*P_dc
           K(b,c)  = K(b,c)  + I_abcd*P_da
           K(b,fd) = K(b,fd) + I_abcd*P_ca
         end
         K(fa,c) = K(fa,c) + Kac
         J(c,fd) = J(c,fd) + Jcd
       end
       K(fa,fd) = K(fa,fd) + Kad
     else if (.b.l<2) then
       Kad = ZERO
       P_da = P(fd,fa)
       do c = fc,lc
         P_dc = P(fd,c)
         P_ca = P(c,fa)
         Jcd = ZERO
         Kac = ZERO
         do b = fb,lb
           I_abcd  = factor*I2(b,c)
           Jcd     = Jcd     + I_abcd*P(b,fa)
           Kac     = Kac     + I_abcd*P(fd,b)
           Kad     = Kad     + I_abcd*P(c,b)
           J(fa,b) = J(fa,b) + I_abcd*P_dc
           K(b,c)  = K(b,c)  + I_abcd*P_da
           K(b,fd) = K(b,fd) + I_abcd*P_ca
         end
         K(fa,c) = K(fa,c) + Kac
         J(c,fd) = J(c,fd) + Jcd
       end
       K(fa,fd) = K(fa,fd) + Kad
     else
       Kad = ZERO
       P_da = factor*P(fd,fa)
       do c = fc,lc
         P_dc = factor*P(fd,c)
         P_ca = factor*P(c,fa)
         Jcd = ZERO
         Kac = ZERO
         do b = fb,lb
           I_abcd  = I2(b,c)
           Jcd     = Jcd     + I_abcd*P(b,fa)
           Kac     = Kac     + I_abcd*P(fd,b)
           Kad     = Kad     + I_abcd*P(c,b)
           J(fa,b) = J(fa,b) + I_abcd*P_dc
           K(b,c)  = K(b,c)  + I_abcd*P_da
           K(b,fd) = K(b,fd) + I_abcd*P_ca
         end
         K(fa,c) = K(fa,c) + factor*Kac
         J(c,fd) = J(c,fd) + factor*Jcd
       end
       K(fa,fd) = K(fa,fd) + factor*Kad
     end
     I2.destroy
   end

   make_r_JK_sbsd(J,K,P,factor,fa,fb,lb,fc,fd,ld) ::: private
   ! Make the J and K contribution due to self and P and add it in.
   ! For a sbsd shell4 only!
     self :: IN
     P :: REALMAT, IN
     J,K :: REALMAT, INOUT
     fa,fb,lb,fc,fd,ld :: INT, IN
     factor :: REAL, IN
     I2 :: REALMAT*
     P_ca,Jcd,P_dc,P_da,Kac,Kad,I_abcd :: REAL
     b,d :: INT
     I2.create(fb,lb,fd,ld)
     if (.b.l==1 AND .d.l==1) then
       if (.ab_n_gaussian_pairs > n_cc_cutoff) then
         .make_psps(I2)
       else
         .make_psps_low_ncc(I2)
       end
     else if (.b.l==2 AND .d.l==2) then
       if (.ab_n_gaussian_pairs > n_cc_cutoff) then
         .make_dsds(I2)
       else
         .make_dsds_low_ncc(I2)
       end
     else if (.b.l==2 AND .d.l==1) then
       if (.ab_n_gaussian_pairs > n_cc_cutoff) then
         .make_dsps(I2)
       else
         .make_dsps_low_ncc(I2)
       end
     else if (.b.l==1 AND .d.l==2) then
       if (.ab_n_gaussian_pairs > n_cc_cutoff) then
         .make_psds(I2)
       else
         .make_psds_low_ncc(I2)
       end
     else
       .make_ascs(I2)
     end
     if (factor > 0.9) then
       P_ca = P(fc,fa)
       Kac = ZERO
       do d = fd,ld
         Kad = ZERO
         Jcd = ZERO
         P_dc = P(d,fc)
         P_da = P(d,fa)
         do b = fb,lb
           I_abcd  = I2(b,d)
           Jcd     = Jcd     + I_abcd*P(b,fa)
           Kac     = Kac     + I_abcd*P(d,b)
           Kad     = Kad     + I_abcd*P(fc,b)
           J(fa,b) = J(fa,b) + I_abcd*P_dc
           K(b,fc) = K(b,fc) + I_abcd*P_da
           K(b,d)  = K(b,d)  + I_abcd*P_ca
         end
         K(fa,d) = K(fa,d) + Kad
         J(fc,d) = J(fc,d) + Jcd
       end
       K(fa,fc) = K(fa,fc) + Kac
     else if (.b.l<2) then
       P_ca = P(fc,fa)
       Kac = ZERO
       do d = fd,ld
         Kad = ZERO
         Jcd = ZERO
         P_dc = P(d,fc)
         P_da = P(d,fa)
         do b = fb,lb
           I_abcd  = factor*I2(b,d)
           Jcd     = Jcd     + I_abcd*P(b,fa)
           Kac     = Kac     + I_abcd*P(d,b)
           Kad     = Kad     + I_abcd*P(fc,b)
           J(fa,b) = J(fa,b) + I_abcd*P_dc
           K(b,fc) = K(b,fc) + I_abcd*P_da
           K(b,d)  = K(b,d)  + I_abcd*P_ca
         end
         K(fa,d) = K(fa,d) + Kad
         J(fc,d) = J(fc,d) + Jcd
       end
       K(fa,fc) = K(fa,fc) + Kac
     else
       P_ca = factor*P(fc,fa)
       Kac = ZERO
       do d = fd,ld
         Kad = ZERO
         Jcd = ZERO
         P_dc = factor*P(d,fc)
         P_da = factor*P(d,fa)
         do b = fb,lb
           I_abcd  = I2(b,d)
           Jcd     = Jcd     + I_abcd*P(b,fa)
           Kac     = Kac     + I_abcd*P(d,b)
           Kad     = Kad     + I_abcd*P(fc,b)
           J(fa,b) = J(fa,b) + I_abcd*P_dc
           K(b,fc) = K(b,fc) + I_abcd*P_da
           K(b,d)  = K(b,d)  + I_abcd*P_ca
         end
         K(fa,d) = K(fa,d) + factor*Kad
         J(fc,d) = J(fc,d) + factor*Jcd
       end
       K(fa,fc) = K(fa,fc) + factor*Kac
     end
     I2.destroy
   end

   make_r_JK_asss(J,K,P,factor,fa,la,fb,fc,fd) ::: private
   ! Make the J and K contribution due to self and P and add it in.
   ! For a asss shell4 only!
     self :: IN
     P :: REALMAT, IN
     J,K :: REALMAT, INOUT
     fa,la,fb,fc,fd :: INT, IN
     factor :: REAL, IN
      I :: REALVEC(fa:la)
     P_dc,Jcd,P_db,P_cb,Kbc,Kbd,I_abcd :: REAL
      a :: INT
     if (.a.l==1) then
       if (.ab_n_gaussian_pairs > n_cc_cutoff) then
         .make_psss(I)
       else
         .make_psss_low_ncc(I)
       end
       P_cb = P(fc,fb)
       P_dc = P(fd,fc)
       P_db = P(fd,fb)
       Kbc = ZERO
       Jcd = ZERO
       Kbd = ZERO
       do a = fa,la
         I_abcd  = factor*I(a)
         Jcd     = Jcd     + I_abcd*P(fb,a)
         Kbc     = Kbc     + I_abcd*P(fd,a)
         Kbd     = Kbd     + I_abcd*P(fc,a)
         J(a,fb) = J(a,fb) + I_abcd*P_dc
         K(a,fc) = K(a,fc) + I_abcd*P_db
         K(a,fd) = K(a,fd) + I_abcd*P_cb
       end
       K(fb,fd) = K(fb,fd) + Kbd
       J(fc,fd) = J(fc,fd) + Jcd
       K(fb,fc) = K(fb,fc) + Kbc
     else
       if (.a.l==2) then
         if (.ab_n_gaussian_pairs > n_cc_cutoff) then
           .make_dsss(I)
         else
           .make_dsss_low_ncc(I)
         end
       else
         .make_asss(I)
       end
       P_cb = factor*P(fc,fb)
       P_dc = factor*P(fd,fc)
       P_db = factor*P(fd,fb)
       Kbc = ZERO
       Jcd = ZERO
       Kbd = ZERO
       do a = fa,la
         I_abcd  = I(a)
         Jcd     = Jcd     + I_abcd*P(fb,a)
         Kbc     = Kbc     + I_abcd*P(fd,a)
         Kbd     = Kbd     + I_abcd*P(fc,a)
         J(a,fb) = J(a,fb) + I_abcd*P_dc
         K(a,fc) = K(a,fc) + I_abcd*P_db
         K(a,fd) = K(a,fd) + I_abcd*P_cb
       end
       K(fb,fd) = K(fb,fd) + factor*Kbd
       J(fc,fd) = J(fc,fd) + factor*Jcd
       K(fb,fc) = K(fb,fc) + factor*Kbc
     end
   end

   make_r_JK_sbss(J,K,P,factor,fa,fb,lb,fc,fd) ::: private
   ! Make the J and K contribution due to self and P and add it in.
   ! For a sbss shell4 only!
     self :: IN
     P :: REALMAT, IN
     J,K :: REALMAT, INOUT
     fa,fb,lb,fc,fd :: INT, IN
     factor :: REAL, IN
     I :: REALVEC(fb:lb)
     P_ca,Jcd,P_dc,P_da,Kac,Kad,I_abcd :: REAL
      b :: INT
     if (.b.l==1) then
       if (.ab_n_gaussian_pairs > n_cc_cutoff) then
         .make_psss(I)
       else
         .make_psss_low_ncc(I)
       end
       P_ca = P(fc,fa)
       P_dc = P(fd,fc)
       P_da = P(fd,fa)
       Kac = ZERO
       Kad = ZERO
       Jcd = ZERO
       do b = fb,lb
         I_abcd  = factor*I(b)
         Jcd     = Jcd     + I_abcd*P(b,fa)
         Kac     = Kac     + I_abcd*P(fd,b)
         Kad     = Kad     + I_abcd*P(fc,b)
         J(fa,b) = J(fa,b) + I_abcd*P_dc
         K(b,fc) = K(b,fc) + I_abcd*P_da
         K(b,fd) = K(b,fd) + I_abcd*P_ca
       end
       K(fa,fd) = K(fa,fd) + Kad
       J(fc,fd) = J(fc,fd) + Jcd
       K(fa,fc) = K(fa,fc) + Kac
     else
       if (.b.l==2) then
         if (.ab_n_gaussian_pairs > n_cc_cutoff) then
           .make_dsss(I)
         else
           .make_dsss_low_ncc(I)
         end
       else
         .make_asss(I)
       end
       P_ca = factor*P(fc,fa)
       P_dc = factor*P(fd,fc)
       P_da = factor*P(fd,fa)
       Kac = ZERO
       Kad = ZERO
       Jcd = ZERO
       do b = fb,lb
         I_abcd  = I(b)
         Jcd     = Jcd     + I_abcd*P(b,fa)
         Kac     = Kac     + I_abcd*P(fd,b)
         Kad     = Kad     + I_abcd*P(fc,b)
         J(fa,b) = J(fa,b) + I_abcd*P_dc
         K(b,fc) = K(b,fc) + I_abcd*P_da
         K(b,fd) = K(b,fd) + I_abcd*P_ca
       end
       K(fa,fd) = K(fa,fd) + factor*Kad
       J(fc,fd) = J(fc,fd) + factor*Jcd
       K(fa,fc) = K(fa,fc) + factor*Kac
     end
   end

   make_r_JK_sscs(J,K,P,factor,fa,fb,fc,lc,fd) ::: private
   ! Make the J and K contribution due to self and P and add it in.
   ! For an sscs shell4 only!
     self :: IN
     P :: REALMAT, IN
     J,K :: REALMAT, INOUT
     fa,fb,fc,lc,fd :: INT, IN
     factor :: REAL, IN
      I :: REALVEC*
     P_db,P_da,P_ba,Kbd,Kad,Jab,I_abcd :: REAL
      c :: INT
     I.create(fc,lc)
     if (.c.l==1) then
       if (.ab_n_gaussian_pairs > n_cc_cutoff) then
         .make_ssps(I)
       else
         .make_ssps_low_ncc(I)
       end
       P_db = P(fd,fb)
       P_da = P(fd,fa)
       P_ba = P(fb,fa)
       Kbd = ZERO
       Kad = ZERO
       Jab = ZERO
       do c = fc,lc
         I_abcd = factor*I(c)
         Jab      = Jab     + I_abcd*P(fd,c)
         J(c,fd)  = J(c,fd) + I_abcd*P_ba
         K(fa,c)  = K(fa,c) + I_abcd*P_db
         Kad      = Kad     + I_abcd*P(c,fb)
         K(fb,c)  = K(fb,c) + I_abcd*P_da
         Kbd      = Kbd     + I_abcd*P(c,fa)
       end
       J(fa,fb) = J(fa,fb) + Jab
       K(fa,fd) = K(fa,fd) + Kad
       K(fb,fd) = K(fb,fd) + Kbd
     else
       if (.c.l==2) then
         if (.ab_n_gaussian_pairs > n_cc_cutoff) then
           .make_ssds(I)
         else
           .make_ssds_low_ncc(I)
         end
       else
         .make_sscs(I)
       end
       P_db = factor*P(fd,fb)
       P_da = factor*P(fd,fa)
       P_ba = factor*P(fb,fa)
       Kbd = ZERO
       Kad = ZERO
       Jab = ZERO
       do c = fc,lc
         I_abcd = I(c)
         Jab      = Jab     + I_abcd*P(fd,c)
         J(c,fd)  = J(c,fd) + I_abcd*P_ba
         K(fa,c)  = K(fa,c) + I_abcd*P_db
         Kad      = Kad     + I_abcd*P(c,fb)
         K(fb,c)  = K(fb,c) + I_abcd*P_da
         Kbd      = Kbd     + I_abcd*P(c,fa)
       end
       J(fa,fb) = J(fa,fb) + factor*Jab
       K(fa,fd) = K(fa,fd) + factor*Kad
       K(fb,fd) = K(fb,fd) + factor*Kbd
     end
     I.destroy
   end

   make_r_JK_sssd(J,K,P,factor,fa,fb,fc,fd,ld) ::: private
   ! Make the J and K contribution due to self and P and add it in.
   ! For an sssd shell4 only!
     self :: IN
     P :: REALMAT, IN
     J,K :: REALMAT, INOUT
     fa,fb,fc,fd,ld :: INT, IN
     factor :: REAL, IN
     I :: REALVEC*
     Jab,P_cb,P_ca,P_ba,Kbc,Kac,I_abcd :: REAL
     d :: INT
     I.create(fd,ld)
     if (.d.l==1) then
       if (.ab_n_gaussian_pairs > n_cc_cutoff) then
         .make_ssps(I)
       else
         .make_ssps_low_ncc(I)
       end
       P_cb = P(fc,fb)
       P_ca = P(fc,fa)
       P_ba = P(fb,fa)
       Jab = ZERO
       Kac = ZERO
       Kbc = ZERO
       do d = fd,ld
         I_abcd = factor*I(d)
         Jab     = Jab     + I_abcd*P(d,fc)
         J(fc,d) = J(fc,d) + I_abcd*P_ba
         Kac     = Kac     + I_abcd*P(d,fb)
         K(fa,d) = K(fa,d) + I_abcd*P_cb
         Kbc     = Kbc     + I_abcd*P(d,fa)
         K(fb,d) = K(fb,d) + I_abcd*P_ca
       end
       K(fb,fc) = K(fb,fc) + Kbc
       K(fa,fc) = K(fa,fc) + Kac
       J(fa,fb) = J(fa,fb) + Jab
     else
       if (.d.l==2) then
         if (.ab_n_gaussian_pairs > n_cc_cutoff) then
           .make_ssds(I)
         else
           .make_ssds_low_ncc(I)
         end
       else
         .make_sscs(I)
       end
       P_cb = factor*P(fc,fb)
       P_ca = factor*P(fc,fa)
       P_ba = factor*P(fb,fa)
       Jab = ZERO
       Kac = ZERO
       Kbc = ZERO
       do d = fd,ld
         I_abcd = I(d)
         Jab     = Jab     + I_abcd*P(d,fc)
         J(fc,d) = J(fc,d) + I_abcd*P_ba
         Kac     = Kac     + I_abcd*P(d,fb)
         K(fa,d) = K(fa,d) + I_abcd*P_cb
         Kbc     = Kbc     + I_abcd*P(d,fa)
         K(fb,d) = K(fb,d) + I_abcd*P_ca
       end
       K(fb,fc) = K(fb,fc) + factor*Kbc
       K(fa,fc) = K(fa,fc) + factor*Kac
       J(fa,fb) = J(fa,fb) + factor*Jab
     end
     I.destroy
   end

!*******************************************************************************
!       make only the J contributions from the shell4 and density matrix.
!*******************************************************************************

   make_r_J(J,P,factor,fa,la,fb,lb,fc,lc,fd,ld)
   ! Make the restricted part of the J and K matrices from the density elements
   ! in P, and the two electron integrals calculated from self.
     self :: IN
     J :: REALMAT, INOUT
     P :: REALMAT, IN
     factor :: REAL, IN
     fa,la,fb,lb,fc,lc,fd,ld :: INT, IN
     opt :: INT
     opt = 0
     if (.d.l==0) opt = opt + 1
     if (.c.l==0) opt = opt + 2
     if (.b.l==0) opt = opt + 4
     if (.a.l==0) opt = opt + 8
     select case (opt)
       case (0);  .make_r_J_abcd(J,P,factor,fa,la,fb,lb,fc,lc,fd,ld) ! abcd
       case (1);  .make_r_J_abcs(J,P,factor,fa,la,fb,lb,fc,lc,fd) ! abcs
       case (2);  .make_r_J_absd(J,P,factor,fa,la,fb,lb,fc,fd,ld) ! absd
       case (3);  .make_r_J_abss(J,P,factor,fa,la,fb,lb,fc,fd) ! abss
       case (4);  .make_r_J_ascd(J,P,factor,fa,la,fb,fc,lc,fd,ld) ! ascd
       case (5);  .make_r_J_ascs(J,P,factor,fa,la,fb,fc,lc,fd) ! ascs
       case (6);  .make_r_J_assd(J,P,factor,fa,la,fb,fc,fd,ld) ! assd
       case (7);  .make_r_J_asss(J,P,factor,fa,la,fb,fc,fd) ! asss
       case (8);  .make_r_J_sbcd(J,P,factor,fa,fb,lb,fc,lc,fd,ld) ! sbcd
       case (9);  .make_r_J_sbcs(J,P,factor,fa,fb,lb,fc,lc,fd) ! sbcs
       case (10); .make_r_J_sbsd(J,P,factor,fa,fb,lb,fc,fd,ld) ! sbsd
       case (11); .make_r_J_sbss(J,P,factor,fa,fb,lb,fc,fd) ! sbss
       case (12); .make_r_J_sscd(J,P,factor,fa,fb,fc,lc,fd,ld) ! sscd
       case (13); .make_r_J_sscs(J,P,factor,fa,fb,fc,lc,fd) ! sscs
       case (14); .make_r_J_sssd(J,P,factor,fa,fb,fc,fd,ld) ! sssd
       case (15); .make_r_J_ssss(J,P,factor,fa,fb,fc,fd) ! ssss
     end
   end

   make_r_J_ssss(J,P,factor,fa,fb,fc,fd) ::: private
   ! Make the J contribution due to self and P and add it in.
   ! For an ssss shell4 only!
     self :: IN
     P :: REALMAT, IN
     J :: REALMAT, INOUT
     fa,fb,fc,fd :: INT, IN
     factor :: REAL, IN
     I0,I_abcd :: REAL
     .make_ssss(I0)
     I_abcd = factor * I0
     J(fa,fb) = J(fa,fb) + I_abcd*P(fd,fc)
     J(fc,fd) = J(fc,fd) + I_abcd*P(fb,fa)
   end

   make_r_J_abcd(J,P,factor,fa,la,fb,lb,fc,lc,fd,ld) ::: private
   ! Make the J contribution due to self and P and add it in.
   ! For any shell4!
     self :: IN
     P :: REALMAT, IN
     J :: REALMAT, target
     fa,la,fb,lb,fc,lc,fd,ld :: INT, IN
     factor :: REAL, IN
     I4 :: REALMAT4*
     P_dc,Jcd,I_abcd :: REAL
     a,b,c,d :: INT
     I4.create(fa,la,fb,lb,fc,lc,fd,ld)
     if (.a.l==1 AND .b.l==1 AND .c.l==1 AND .d.l==1) then
       .make_pppp(I4)
     else
       .make_abcd(I4)
     end
     if (factor > 0.9) then
       do d = fd,ld
         do c = fc,lc
           P_dc = P(d,c)
           Jcd = ZERO
           do b = fb,lb
             do a = fa,la
               I_abcd = I4(a,b,c,d)
               J(a,b) = J(a,b) + I_abcd*P_dc
               Jcd    = Jcd    + I_abcd*P(b,a)
             end
           end
           J(c,d) = J(c,d) + Jcd
         end
       end
     else if (.a.l<2) then
       do d = fd,ld
         do c = fc,lc
           P_dc = P(d,c)
           Jcd = ZERO
           do b = fb,lb
             do a = fa,la
               I_abcd = factor*I4(a,b,c,d)
               J(a,b) = J(a,b) + I_abcd*P_dc
               Jcd    = Jcd    + I_abcd*P(b,a)
             end
           end
           J(c,d) = J(c,d) + Jcd
         end
       end
     else
       do d = fd,ld
         do c = fc,lc
           P_dc = factor*P(d,c)
           Jcd = ZERO
           do b = fb,lb
             do a = fa,la
               I_abcd = I4(a,b,c,d)
               J(a,b) = J(a,b) + I_abcd*P_dc
               Jcd    = Jcd    + I_abcd*P(b,a)
             end
           end
           J(c,d) = J(c,d) + factor*Jcd
         end
       end
     end
     I4.destroy
   end

   make_r_J_sscd(J,P,factor,fa,fb,fc,lc,fd,ld) ::: private
   ! Make the J contribution due to self and P and add it in.
   ! For an sscd shell4 only!
     self :: IN
     P :: REALMAT, IN
     J :: REALMAT, INOUT
     fa,fb,fc,lc,fd,ld :: INT, IN
     factor :: REAL, IN
     I2 :: REALMAT*
     P_ba,Jab,I_abcd :: REAL
     c,d :: INT
     I2.create(fc,lc,fd,ld)
     if (.c.l==1 AND .d.l==1) then
       .make_sspp(I2)
     else
       .make_sscd(I2)
     end
     if (factor > 0.9) then
       Jab = ZERO
       P_ba = P(fb,fa)
       do d = fd,ld
         do c = fc,lc
           I_abcd = I2(c,d)
           Jab     = Jab     + I_abcd*P(d,c)
           J(c,d)  = J(c,d)  + I_abcd*P_ba
         end
       end
       J(fa,fb) = J(fa,fb) + Jab
     else if (.c.l<2) then
       Jab = ZERO
       P_ba = P(fb,fa)
       do d = fd,ld
         do c = fc,lc
           I_abcd = factor*I2(c,d)
           Jab     = Jab     + I_abcd*P(d,c)
           J(c,d)  = J(c,d)  + I_abcd*P_ba
         end
       end
       J(fa,fb) = J(fa,fb) + Jab
     else
       Jab = ZERO
       P_ba = factor*P(fb,fa)
       do d = fd,ld
         do c = fc,lc
           I_abcd = I2(c,d)
           Jab     = Jab     + I_abcd*P(d,c)
           J(c,d)  = J(c,d)  + I_abcd*P_ba
         end
       end
       J(fa,fb) = J(fa,fb) + factor*Jab
     end
     I2.destroy
   end

   make_r_J_abcs(J,P,factor,fa,la,fb,lb,fc,lc,fd) ::: private
   ! Make the J contribution due to self and P and add it in.
   ! For an abcs shell4!
     self :: IN
     P :: REALMAT, IN
     J :: REALMAT, INOUT
     fa,la,fb,lb,fc,lc,fd :: INT, IN
     factor :: REAL, IN
     I3 :: REALMAT3*
     P_dc,Jcd,I_abcd :: REAL
     a,b,c :: INT
     I3.create(fa,la,fb,lb,fc,lc)
     if (.a.l==1 AND .b.l==1 AND .c.l==1) then
       .make_ppps(I3)
     else
       .make_abcs(I3)
     end
     if (factor > 0.9) then
       do c = fc,lc
         P_dc = P(fd,c)
         Jcd = ZERO
         do b = fb,lb
           do a = fa,la
             I_abcd  = I3(a,b,c)
             J(a,b)  = J(a,b)  + I_abcd*P_dc
             Jcd     = Jcd     + I_abcd*P(b,a)
           end
         end
         J(c,fd) = J(c,fd) + Jcd
       end
     else if (.a.l<2) then
       do c = fc,lc
         P_dc = P(fd,c)
         Jcd = ZERO
         do b = fb,lb
           do a = fa,la
             I_abcd  = factor*I3(a,b,c)
             J(a,b)  = J(a,b)  + I_abcd*P_dc
             Jcd     = Jcd     + I_abcd*P(b,a)
           end
         end
         J(c,fd) = J(c,fd) + Jcd
       end
     else
       do c = fc,lc
         P_dc = factor*P(fd,c)
         Jcd = ZERO
         do b = fb,lb
           do a = fa,la
             I_abcd  = I3(a,b,c)
             J(a,b)  = J(a,b)  + I_abcd*P_dc
             Jcd     = Jcd     + I_abcd*P(b,a)
           end
         end
         J(c,fd) = J(c,fd) + factor*Jcd
       end
     end
     I3.destroy
   end

   make_r_J_absd(J,P,factor,fa,la,fb,lb,fc,fd,ld) ::: private
   ! Make the J contribution due to self and P and add it in.
   ! For an absd shell4 only!
     self :: IN
     P :: REALMAT, IN
     J :: REALMAT, INOUT
     fa,la,fb,lb,fc,fd,ld :: INT, IN
     factor :: REAL, IN
     I3 :: REALMAT3*
     P_dc,Jcd,I_abcd :: REAL
     a,b,d :: INT
     I3.create(fa,la,fb,lb,fd,ld)
     if (.a.l==1 AND .b.l==1 AND .d.l==1) then
       .make_ppps(I3)
     else
       .make_abcs(I3)
     end
     if (factor > 0.9) then
       do d = fd,ld
         P_dc = P(d,fc)
         Jcd = ZERO
         do b = fb,lb
           do a = fa,la
             I_abcd  = I3(a,b,d)
             J(a,b)  = J(a,b)  + I_abcd*P_dc
             Jcd     = Jcd     + I_abcd*P(b,a)
           end
         end
         J(fc,d) = J(fc,d) + Jcd
       end
     else if (.a.l<2) then
       do d = fd,ld
         P_dc = P(d,fc)
         Jcd = ZERO
         do b = fb,lb
           do a = fa,la
             I_abcd  = factor*I3(a,b,d)
             J(a,b)  = J(a,b)  + I_abcd*P_dc
             Jcd     = Jcd     + I_abcd*P(b,a)
           end
         end
         J(fc,d) = J(fc,d) + Jcd
       end
     else
       do d = fd,ld
         P_dc = factor*P(d,fc)
         Jcd = ZERO
         do b = fb,lb
           do a = fa,la
             I_abcd  = I3(a,b,d)
             J(a,b)  = J(a,b)  + I_abcd*P_dc
             Jcd     = Jcd     + I_abcd*P(b,a)
           end
         end
         J(fc,d) = J(fc,d) + factor*Jcd
       end
     end
     I3.destroy
   end

   make_r_J_sbcd(J,P,factor,fa,fb,lb,fc,lc,fd,ld) ::: private
   ! Make the J contribution due to self and P and add it in.
   ! For a spcd shell4 only!
     self :: IN
     P :: REALMAT, IN
     J :: REALMAT, INOUT
     fa,fb,lb,fc,lc,fd,ld :: INT, IN
     factor :: REAL, IN
     I3 :: REALMAT3*
     Jab,P_ba,P_da,P_db,I_abcd :: REAL
     b,c,d :: INT
     I3.create(fb,lb,fc,lc,fd,ld)
     if (.b.l==1 AND .c.l==1 AND .d.l==1) then
       .make_pspp(I3)
     else
       .make_ascd(I3)
     end
     if (factor > 0.9) then
       do b=fb,lb
         Jab = ZERO
         P_ba = P(b,fa)
         do d = fd,ld
           P_da = P(d,fa)
           P_db = P(d,b)
           do c = fc,lc
             I_abcd  = I3(b,c,d)
             Jab     = Jab     + I_abcd*P(d,c)
             J(c,d)  = J(c,d)  + I_abcd*P_ba
           end
         end
         J(fa,b) = J(fa,b) + Jab
       end
     else if (.c.l<2) then
       do b=fb,lb
         Jab = ZERO
         P_ba = P(b,fa)
         do d = fd,ld
           P_da = P(d,fa)
           P_db = P(d,b)
           do c = fc,lc
             I_abcd  = factor*I3(b,c,d)
             Jab     = Jab     + I_abcd*P(d,c)
             J(c,d)  = J(c,d)  + I_abcd*P_ba
           end
         end
         J(fa,b) = J(fa,b) + Jab
       end
     else
       do b=fb,lb
         Jab = ZERO
         P_ba = factor*P(b,fa)
         do d = fd,ld
           P_da = factor*P(d,fa)
           P_db = factor*P(d,b)
           do c = fc,lc
             I_abcd  = I3(b,c,d)
             Jab     = Jab     + I_abcd*P(d,c)
             J(c,d)  = J(c,d)  + I_abcd*P_ba
           end
         end
         J(fa,b) = J(fa,b) + factor*Jab
       end
     end
     I3.destroy
   end

   make_r_J_ascd(J,P,factor,fa,la,fb,fc,lc,fd,ld) ::: private
   ! Make the J contribution due to self and P and add it in.
   ! For a pscd shell4 only!
     self :: IN
     P :: REALMAT, IN
     J :: REALMAT, INOUT
     fa,la,fb,fc,lc,fd,ld :: INT, IN
     factor :: REAL, IN
     I3 :: REALMAT3*
     Jab,P_ba,I_abcd :: REAL
     a,c,d :: INT
     I3.create(fa,la,fc,lc,fd,ld)
     if (.a.l==1 AND .c.l==1 AND .d.l==1) then
       .make_pspp(I3)
     else
       .make_ascd(I3)
     end
     if (factor > 0.9) then
       do a=fa,la
         Jab = ZERO
         P_ba = P(fb,a)
         do d = fd,ld
           do c = fc,lc
             I_abcd  = I3(a,c,d)
             Jab     = Jab     + I_abcd*P(d,c)
             J(c,d)  = J(c,d)  + I_abcd*P_ba
           end
         end
         J(a,fb) = J(a,fb) + Jab
       end
     else if (.c.l<2) then
       do a=fa,la
         Jab = ZERO
         P_ba = P(fb,a)
         do d = fd,ld
           do c = fc,lc
             I_abcd  = factor*I3(a,c,d)
             Jab     = Jab     + I_abcd*P(d,c)
             J(c,d)  = J(c,d)  + I_abcd*P_ba
           end
         end
         J(a,fb) = J(a,fb) + Jab
       end
     else
       do a=fa,la
         Jab = ZERO
         P_ba = factor*P(fb,a)
         do d = fd,ld
           do c = fc,lc
             I_abcd  = I3(a,c,d)
             Jab     = Jab     + I_abcd*P(d,c)
             J(c,d)  = J(c,d)  + I_abcd*P_ba
           end
         end
         J(a,fb) = J(a,fb) + factor*Jab
       end
     end
     I3.destroy
   end

   make_r_J_abss(J,P,factor,fa,la,fb,lb,fc,fd) ::: private
   ! Make the J contribution due to self and P and add it in.
   ! For an abss shell4 only!
     self :: IN
     P :: REALMAT, IN
     J :: REALMAT, INOUT
     fa,la,fb,lb,fc,fd :: INT, IN
     factor :: REAL, IN
     I2 :: REALMAT*
     P_dc,Jcd,I_abcd :: REAL
     a,b :: INT
     I2.create(fa,la,fb,lb)
     if (.a.l==1 AND .b.l==1) then
       .make_ppss(I2)
     else
       .make_abss(I2)
     end
     if (factor > 0.9) then
       Jcd = ZERO
       P_dc = P(fd,fc)
       do b = fb,lb
         do a = fa,la
           I_abcd = I2(a,b)
           J(a,b) = J(a,b) + I_abcd*P_dc
           Jcd    = Jcd    + I_abcd*P(b,a)
         end
       end
       J(fc,fd) = J(fc,fd) + Jcd
     else if (.a.l<2) then
       Jcd = ZERO
       P_dc = P(fd,fc)
       do b = fb,lb
         do a = fa,la
           I_abcd = factor*I2(a,b)
           J(a,b) = J(a,b) + I_abcd*P_dc
           Jcd    = Jcd    + I_abcd*P(b,a)
         end
       end
       J(fc,fd) = J(fc,fd) + Jcd
     else
       Jcd = ZERO
       P_dc = factor*P(fd,fc)
       do b = fb,lb
         do a = fa,la
           I_abcd = I2(a,b)
           J(a,b) = J(a,b) + I_abcd*P_dc
           Jcd    = Jcd    + I_abcd*P(b,a)
         end
       end
       J(fc,fd) = J(fc,fd) + factor*Jcd
     end
     I2.destroy
   end

   make_r_J_ascs(J,P,factor,fa,la,fb,fc,lc,fd) ::: private
   ! Make the J contribution due to self and P and add it in.
   ! For a ascs shell4 only!
     self :: IN
     P :: REALMAT, IN
     J :: REALMAT, INOUT
     fa,la,fb,fc,lc,fd :: INT, IN
     factor :: REAL, IN
     I2 :: REALMAT*
     P_dc,Jcd,I_abcd :: REAL
     a,c :: INT
     I2.create(fa,la,fc,lc)
     if (.a.l==1 AND .c.l==1) then
       .make_psps(I2)
     else
       .make_ascs(I2)
     end
     if (factor > 0.9) then
       do c = fc,lc
         P_dc = P(fd,c)
         Jcd = ZERO
         do a = fa,la
           I_abcd  = I2(a,c)
           J(a,fb) = J(a,fb) + I_abcd*P_dc
           Jcd     = Jcd     + I_abcd*P(fb,a)
         end
         J(c,fd) = J(c,fd) + Jcd
       end
     else if (.a.l<2) then
       do c = fc,lc
         P_dc = P(fd,c)
         Jcd = ZERO
         do a = fa,la
           I_abcd  = factor*I2(a,c)
           J(a,fb) = J(a,fb) + I_abcd*P_dc
           Jcd     = Jcd     + I_abcd*P(fb,a)
         end
         J(c,fd) = J(c,fd) + Jcd
       end
     else
       do c = fc,lc
         P_dc = factor*P(fd,c)
         Jcd = ZERO
         do a = fa,la
           I_abcd  = I2(a,c)
           J(a,fb) = J(a,fb) + I_abcd*P_dc
           Jcd     = Jcd     + I_abcd*P(fb,a)
         end
         J(c,fd) = J(c,fd) + factor*Jcd
       end
     end
     I2.destroy
   end

   make_r_J_assd(J,P,factor,fa,la,fb,fc,fd,ld) ::: private
   ! Make the J contribution due to self and P and add it in.
   ! For a assd shell4 only!
     self :: IN
     P :: REALMAT, IN
     J :: REALMAT, INOUT
     fa,la,fb,fc,fd,ld :: INT, IN
     factor :: REAL, IN
     I2 :: REALMAT*
     P_dc,Jcd,I_abcd :: REAL
     a,d :: INT
     I2.create(fa,la,fd,ld)
     if (.a.l==1 AND .d.l==1) then
       .make_psps(I2)
     else
       .make_ascs(I2)
     end
     if (factor > 0.9) then
       do d = fd,ld
         P_dc = P(d,fc)
         Jcd = ZERO
         do a = fa,la
           I_abcd  = I2(a,d)
           Jcd     = Jcd     + I_abcd*P(fb,a)
           J(a,fb) = J(a,fb) + I_abcd*P_dc
         end
         J(fc,d) = J(fc,d) + Jcd
       end
     else if (.a.l<2) then
       do d = fd,ld
         P_dc = P(d,fc)
         Jcd = ZERO
         do a = fa,la
           I_abcd  = factor*I2(a,d)
           Jcd     = Jcd     + I_abcd*P(fb,a)
           J(a,fb) = J(a,fb) + I_abcd*P_dc
         end
         J(fc,d) = J(fc,d) + Jcd
       end
     else
       do d = fd,ld
         P_dc = factor*P(d,fc)
         Jcd = ZERO
         do a = fa,la
           I_abcd  = I2(a,d)
           Jcd     = Jcd     + I_abcd*P(fb,a)
           J(a,fb) = J(a,fb) + I_abcd*P_dc
         end
         J(fc,d) = J(fc,d) + factor*Jcd
       end
     end
     I2.destroy
   end

   make_r_J_sbcs(J,P,factor,fa,fb,lb,fc,lc,fd) ::: private
   ! Make the J contribution due to self and P and add it in.
   ! For a sbcs shell4 only!
     self :: IN
     P :: REALMAT, IN
     J :: REALMAT, INOUT
     fa,fb,lb,fc,lc,fd :: INT, IN
     factor :: REAL, IN
     I2 :: REALMAT*
     P_dc,Jcd,I_abcd :: REAL
     b,c :: INT
     I2.create(fb,lb,fc,lc)
     if (.b.l==1 AND .c.l==1) then
       .make_psps(I2)
     else
       .make_ascs(I2)
     end
     if (factor > 0.9) then
       do c = fc,lc
         P_dc = P(fd,c)
         Jcd = ZERO
         do b = fb,lb
           I_abcd  = I2(b,c)
           Jcd     = Jcd     + I_abcd*P(b,fa)
           J(fa,b) = J(fa,b) + I_abcd*P_dc
         end
         J(c,fd) = J(c,fd) + Jcd
       end
     else if (.b.l<2) then
       do c = fc,lc
         P_dc = P(fd,c)
         Jcd = ZERO
         do b = fb,lb
           I_abcd  = factor*I2(b,c)
           Jcd     = Jcd     + I_abcd*P(b,fa)
           J(fa,b) = J(fa,b) + I_abcd*P_dc
         end
         J(c,fd) = J(c,fd) + Jcd
       end
     else
       do c = fc,lc
         P_dc = factor*P(fd,c)
         Jcd = ZERO
         do b = fb,lb
           I_abcd  = I2(b,c)
           Jcd     = Jcd     + I_abcd*P(b,fa)
           J(fa,b) = J(fa,b) + I_abcd*P_dc
         end
         J(c,fd) = J(c,fd) + factor*Jcd
       end
     end
     I2.destroy
   end

   make_r_J_sbsd(J,P,factor,fa,fb,lb,fc,fd,ld) ::: private
   ! Make the J contribution due to self and P and add it in.
   ! For a sbsd shell4 only!
     self :: IN
     P :: REALMAT, IN
     J :: REALMAT, INOUT
     fa,fb,lb,fc,fd,ld :: INT, IN
     factor :: REAL, IN
     I2 :: REALMAT*
     P_ca,Jcd,P_dc,P_da,I_abcd :: REAL
     b,d :: INT
     I2.create(fb,lb,fd,ld)
     if (.b.l==1 AND .d.l==1) then
       .make_psps(I2)
     else
       .make_ascs(I2)
     end
     if (factor > 0.9) then
       P_ca = P(fc,fa)
       do d = fd,ld
         Jcd = ZERO
         P_dc = P(d,fc)
         P_da = P(d,fa)
         do b = fb,lb
           I_abcd  = I2(b,d)
           Jcd     = Jcd     + I_abcd*P(b,fa)
           J(fa,b) = J(fa,b) + I_abcd*P_dc
         end
         J(fc,d) = J(fc,d) + Jcd
       end
     else if (.b.l<2) then
       P_ca = P(fc,fa)
       do d = fd,ld
         Jcd = ZERO
         P_dc = P(d,fc)
         P_da = P(d,fa)
         do b = fb,lb
           I_abcd  = factor*I2(b,d)
           Jcd     = Jcd     + I_abcd*P(b,fa)
           J(fa,b) = J(fa,b) + I_abcd*P_dc
         end
         J(fc,d) = J(fc,d) + Jcd
       end
     else
       P_ca = factor*P(fc,fa)
       do d = fd,ld
         Jcd = ZERO
         P_dc = factor*P(d,fc)
         P_da = factor*P(d,fa)
         do b = fb,lb
           I_abcd  = I2(b,d)
           Jcd     = Jcd     + I_abcd*P(b,fa)
           J(fa,b) = J(fa,b) + I_abcd*P_dc
         end
         J(fc,d) = J(fc,d) + factor*Jcd
       end
     end
     I2.destroy
   end

   make_r_J_asss(J,P,factor,fa,la,fb,fc,fd) ::: private
   ! Make the J contribution due to self and P and add it in.
   ! For a asss shell4 only!
     self :: IN
     P :: REALMAT, IN
     J :: REALMAT, INOUT
     fa,la,fb,fc,fd :: INT, IN
     factor :: REAL, IN
     I :: REALVEC(fa:la)
     P_dc,Jcd,I_abcd :: REAL
     a :: INT
     if (.a.l==1) then
       .make_psss(I)
       P_dc = P(fd,fc)
       Jcd = ZERO
       do a = fa,la
         I_abcd  = factor*I(a)
         Jcd     = Jcd     + I_abcd*P(fb,a)
         J(a,fb) = J(a,fb) + I_abcd*P_dc
       end
       J(fc,fd) = J(fc,fd) + Jcd
     else
       if (.a.l==2) then
         .make_dsss(I)
       else
         .make_asss(I)
       end
       P_dc = factor*P(fd,fc)
       Jcd = ZERO
       do a = fa,la
         I_abcd  = I(a)
         Jcd     = Jcd     + I_abcd*P(fb,a)
         J(a,fb) = J(a,fb) + I_abcd*P_dc
       end
       J(fc,fd) = J(fc,fd) + factor*Jcd
     end
   end

   make_r_J_sbss(J,P,factor,fa,fb,lb,fc,fd) ::: private
   ! Make the J contribution due to self and P and add it in.
   ! For a sbss shell4 only!
     self :: IN
     P :: REALMAT, IN
     J :: REALMAT, INOUT
     fa,fb,lb,fc,fd :: INT, IN
     factor :: REAL, IN
     I :: REALVEC(fb:lb)
     Jcd,P_dc,I_abcd :: REAL
      b :: INT
     if (.b.l==1) then
       .make_psss(I)
       P_dc = P(fd,fc)
       Jcd = ZERO
       do b = fb,lb
         I_abcd  = factor*I(b)
         Jcd     = Jcd     + I_abcd*P(b,fa)
         J(fa,b) = J(fa,b) + I_abcd*P_dc
       end
       J(fc,fd) = J(fc,fd) + Jcd
     else
       if (.b.l==2) then
         .make_dsss(I)
       else
         .make_asss(I)
       end
       P_dc = factor*P(fd,fc)
       Jcd = ZERO
       do b = fb,lb
         I_abcd  = I(b)
         Jcd     = Jcd     + I_abcd*P(b,fa)
         J(fa,b) = J(fa,b) + I_abcd*P_dc
       end
       J(fc,fd) = J(fc,fd) + factor*Jcd
     end
   end

   make_r_J_sscs(J,P,factor,fa,fb,fc,lc,fd) ::: private
   ! Make the J contribution due to self and P and add it in.
   ! For an sscs shell4 only!
     self :: IN
     P :: REALMAT, IN
     J :: REALMAT, INOUT
     fa,fb,fc,lc,fd :: INT, IN
     factor :: REAL, IN
     I :: REALVEC*
     P_ba,Jab,I_abcd :: REAL
     c :: INT
     I.create(fc,lc)
     if (.c.l==1) then
       .make_ssps(I)
       P_ba = P(fb,fa)
       Jab = ZERO
       do c = fc,lc
         I_abcd = factor*I(c)
         Jab      = Jab     + I_abcd*P(fd,c)
         J(c,fd)  = J(c,fd) + I_abcd*P_ba
       end
       J(fa,fb) = J(fa,fb) + Jab
     else
       if (.c.l==2) then
         .make_ssds(I)
       else
         .make_sscs(I)
       end
       P_ba = factor*P(fb,fa)
       Jab = ZERO
       do c = fc,lc
         I_abcd = I(c)
         Jab      = Jab     + I_abcd*P(fd,c)
         J(c,fd)  = J(c,fd) + I_abcd*P_ba
       end
       J(fa,fb) = J(fa,fb) + factor*Jab
     end
     I.destroy
   end

   make_r_J_sssd(J,P,factor,fa,fb,fc,fd,ld) ::: private
   ! Make the J contribution due to self and P and add it in.
   ! For an sssd shell4 only!
     self :: IN
     P :: REALMAT, IN
     J :: REALMAT, INOUT
     fa,fb,fc,fd,ld :: INT, IN
     factor :: REAL, IN
     I :: REALVEC*
     Jab,P_ba,I_abcd :: REAL
     d :: INT
     I.create(fd,ld)
     if (.d.l==1) then
       .make_ssps(I)
       P_ba = P(fb,fa)
       Jab = ZERO
       do d = fd,ld
         I_abcd = factor*I(d)
         Jab     = Jab     + I_abcd*P(d,fc)
         J(fc,d) = J(fc,d) + I_abcd*P_ba
       end
       J(fa,fb) = J(fa,fb) + Jab
     else
       if (.d.l==2) then
         .make_ssds(I)
       else
         .make_sscs(I)
       end
       P_ba = factor*P(fb,fa)
       Jab = ZERO
       do d = fd,ld
         I_abcd = I(d)
         Jab     = Jab     + I_abcd*P(d,fc)
         J(fc,d) = J(fc,d) + I_abcd*P_ba
       end
       J(fa,fb) = J(fa,fb) + factor*Jab
     end
     I.destroy
   end

!*******************************************************************************
!  Output Routines.
!*******************************************************************************

   put
   ! Put the shell4 information to file "out"
     n_cc,i :: INT
     stdout.flush
     stdout.show("A shell l quantum number =",.a.l)
     stdout.show("B shell l quantum number =",.b.l)
     stdout.show("C shell l quantum number =",.c.l)
     stdout.show("D shell l quantum number =",.d.l)
     stdout.show("A position               =",.pos_a)
     stdout.show("B position               =",.pos_b)
     stdout.show("C position               =",.pos_c)
     stdout.show("D position               =",.pos_d)
     stdout.flush
     stdout.dash(int_fields=1,real_fields=8)
     stdout.put("N", int_width=TRUE)
     stdout.put("ex_a")
     stdout.put("cc_a")
     stdout.put("ex_b")
     stdout.put("cc_b")
     stdout.put("ex_c")
     stdout.put("cc_c")
     stdout.put("ex_d")
     stdout.put("cc_d")
     stdout.flush
     stdout.dash(int_fields=1,real_fields=8)
     n_cc = max(.a.n_cc,.b.n_cc,.c.n_cc,.d.n_cc)
     do i = 1,n_cc
        stdout.put(i)
        if (i<=.a.n_cc) then
        stdout.put( .a.ex(i))
        stdout.put( .a.cc(i))
        else
        stdout.tab(real_fields=2)
        end
        if (i<=.b.n_cc) then
        stdout.put( .b.ex(i))
        stdout.put( .b.cc(i))
        else
        stdout.tab(real_fields=2)
        end
        if (i<=.c.n_cc) then
        stdout.put( .c.ex(i))
        stdout.put( .c.cc(i))
        else
        stdout.tab(real_fields=2)
        end
        if (i<=.d.n_cc) then
        stdout.put( .d.ex(i))
        stdout.put( .d.cc(i))
        else
        stdout.tab(real_fields=2)
        end
        stdout.flush
     end
     stdout.dash(int_fields=1,real_fields=8)
   end

end
