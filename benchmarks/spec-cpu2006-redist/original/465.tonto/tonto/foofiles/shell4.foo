!
! Copyright (C) Daniel Grimwood, March 1998
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id: shell4.foo,v 1.49.2.6 2003/11/13 05:33:21 reaper Exp $
!*******************************************************************************

module SHELL4

  implicit none

contains

!*******************************************************************************
!  Create/Destroy routines.
!*******************************************************************************

   create ::: leaky
   ! Create a shell4 object, but no its component shells.
     self :: PTR
     nullify(self)
     allocate(self)
     ADD_MEMORY(SHELL4_SIZE)
     .nullify_ptr_part
   end

   create(shell_a,shell_b,shell_c,shell_d) ::: leaky
   ! Create a shell4 object from copies of shell1s.
     self :: PTR
     shell_a,shell_b,shell_c,shell_d :: SHELL1, IN
     .create
     .copy(shell_a,shell_b,shell_c,shell_d)
   end

   create(shell_a,shell_b,shell_c,shell_d,pos_a,pos_b,pos_c,pos_d) ::: leaky
   ! Create a shell4 object from copies of shells and their positions.
     self :: PTR
     shell_a,shell_b,shell_c,shell_d :: SHELL, IN
     pos_a,pos_b,pos_c,pos_d :: REALVEC(3), IN
     .create
     .copy(shell_a,shell_b,shell_c,shell_d,pos_a,pos_b,pos_c,pos_d)
   end

   destroy ::: leaky
   ! Destroy a shell4 object.
     self :: PTR
     if (associated(self)) then
       .destroy_ptr_part
       DELETE_MEMORY(SHELL4_SIZE)
       deallocate(self)
     end
   end

!   created result(res)
!   ! Returns true if self has been created
!     self :: PTR
!     res :: BIN
!     res = associated(self)
!   end

!   destroyed result(res)
!   ! Returns true if self has *not* been created
!     self :: PTR
!     res :: BIN
!     res = NOT associated(self)
!   end

   nullify_ptr_part
   ! Nullify the pointer parts of self
     .a.nullify_ptr_part
     .b.nullify_ptr_part
     .c.nullify_ptr_part
     .d.nullify_ptr_part
   end

   destroy_ptr_part ::: leaky
   ! Destroy the pointer parts of self
     .destroy_ab
     .destroy_cd
   end

   destroy_ab ::: leaky
   ! Destroy the shella and shellb pointer parts of self
     .a.destroy_ptr_part
     .b.destroy_ptr_part
   end

   destroy_cd ::: leaky
   ! Destroy the shellc and shelld pointer parts of self
     .c.destroy_ptr_part
     .d.destroy_ptr_part
   end

   create_copy(shell) ::: leaky
   ! Create a copy of "shell"
     self :: PTR
     shell :: SHELL4, IN
     .create
     .copy(shell)
   end

!*******************************************************************************
!  Setting parts of self from other shells and shell1s.
!*******************************************************************************

   copy(shell) ::: leaky
   ! Make a copy of "shell"
     shell :: SHELL4, IN
     .a.copy(shell.a)
     .b.copy(shell.b)
     .c.copy(shell.c)
     .d.copy(shell.d)
   end

   copy(shell_a,shell_b,shell_c,shell_d) ::: leaky
   ! Copy the shell4 using from shell1 objects
     shell_a,shell_b,shell_c,shell_d :: SHELL1, IN
     .a.copy(shell_a)
     .b.copy(shell_b)
     .c.copy(shell_c)
     .d.copy(shell_d)
   end

   copy(shell_a,shell_b,shell_c,shell_d,pos_a,pos_b,pos_c,pos_d) ::: leaky
   ! Set the shell4 using shell objects and positions
     shell_a,shell_b,shell_c,shell_d :: SHELL, IN
     pos_a,pos_b,pos_c,pos_d :: REALVEC, IN
     .a.copy(shell_a,pos_a)
     .b.copy(shell_b,pos_b)
     .c.copy(shell_c,pos_c)
     .d.copy(shell_d,pos_d)
   end

   set(shell_a,shell_b,shell_c,shell_d)
   ! Set the shell4 using from shell1 objects
     shell_a,shell_b,shell_c,shell_d :: SHELL1, IN
     .a.set(shell_a)
     .b.set(shell_b)
     .c.set(shell_c)
     .d.set(shell_d)
   end

   copy_ab(shell_a,shell_b,pos_a,pos_b) ::: leaky
   ! Copy the a and b parts of the shell4 using from shell1 objects
     shell_a,shell_b :: SHELL, IN
     pos_a,pos_b :: REALVEC, IN
     .a.copy(shell_a,pos_a)
     .b.copy(shell_b,pos_b)
   end

   copy_cd(shell_c,shell_d,pos_c,pos_d) ::: leaky
   ! Copy the c and d parts of the shell4 using from shell1 objects
     shell_c,shell_d :: SHELL, IN
     pos_c,pos_d :: REALVEC, IN
     .c.copy(shell_c,pos_c)
     .d.copy(shell_d,pos_d)
   end

   set(shell_a,shell_b,shell_c,shell_d,pos_a,pos_b,pos_c,pos_d)
   ! Set the shell4 using shell objects and positions
     shell_a,shell_b,shell_c,shell_d :: SHELL, IN
     pos_a,pos_b,pos_c,pos_d :: REALVEC, IN
     .a.set(shell_a,pos_a)
     .b.set(shell_b,pos_b)
     .c.set(shell_c,pos_c)
     .d.set(shell_d,pos_d)
   end

!*******************************************************************************
!  Miscellaneous Routines.
!*******************************************************************************

   unnormalise
   ! Unnormalise each shell in this shell quartet
     .a.unnormalise
     .b.unnormalise
     .c.unnormalise
     .d.unnormalise
   end

!*******************************************************************************
!  ERI cutoffs
!*******************************************************************************

  ab_kappa_max result (res) ::: pure
  ! Return the largest kappa_ab used in the Lindh integrals.
    self :: IN
    res :: REAL
    AB :: REALVEC(3)
    b,b_cc,a,ab_inv,prefac,r2_ab :: REAL
    bg,ag :: INT
    AB = .b.pos - .a.pos
    r2_ab = dot_product(AB,AB)
    res = ZERO
    do bg = 1,.b.n_cc
      b      = .b.ex(bg)
      b_cc   = .b.cc(bg)
      do ag = 1,.a.n_cc
        a = .a.ex(ag)
        ab_inv = ONE/(a+b)
        prefac = b_cc*.a.cc(ag) * ab_inv * sqrt(ab_inv) * exp(-a*b*r2_ab*ab_inv)
        res = max(res,prefac/(sqrt(ab_inv)*ab_inv))
      end
    end
  end

  cd_kappa_max result (res) ::: pure
  ! Return the largest kappa_cd used in the Lindh integrals.
    self :: IN
    res :: REAL
    CD :: REALVEC(3)
    d,d_cc,c,cd_inv,prefac,r2_cd :: REAL
    dg,cg :: INT
    CD = .d.pos - .c.pos
    r2_cd = dot_product(CD,CD)
    res = ZERO
    do dg = 1,.d.n_cc
      d      = .d.ex(dg)
      d_cc   = .d.cc(dg)
      do cg = 1,.c.n_cc
        c = .c.ex(cg)
        cd_inv = ONE/(c+d)
        prefac = d_cc*.c.cc(cg) * cd_inv * sqrt(cd_inv) * exp(-c*d*r2_cd*cd_inv)
        res = max(res,prefac/(sqrt(cd_inv)*cd_inv))
      end
    end
  end

   skip_ERI result (res) ::: pure
   ! Whether the ERI block will be less than a cutoff value.
     self :: IN
     res :: BIN
     res = (.ab_kappa_max*.cd_kappa_max < SHELL4_ERI_CUTOFF)
   end

   skip_ERI(cutoff) result (res) ::: pure
   ! Whether the ERI block will be less than a cutoff value.
     self :: IN
     cutoff :: REAL, IN
     res :: BIN
     res = (.ab_kappa_max*.cd_kappa_max < cutoff)
   end

!*******************************************************************************
!                            CADPAC-style integrals
!*******************************************************************************

  make_ERI_ints(I)
  ! Make the ERI integral matrix, using Gauss-Hermite quadrature, like in
  ! CADPAC.
  ! This is not expected to be as efficient as Daniel's code, below!
  ! But probably much easier to understand.
    I :: REALMAT4
    II :: REALMAT4*
    G :: GAUSSIAN4
    a,b,c,d :: INT
    I = ZERO
    II.create(.a.n_comp,.b.n_comp,.c.n_comp,.d.n_comp)
    G.a.l   = .a.l;   G.b.l   = .b.l;   G.c.l   = .c.l;   G.d.l   = .d.l
    G.a.pos = .a.pos; G.b.pos = .b.pos; G.c.pos = .c.pos; G.d.pos = .d.pos
    do a = 1,.a.n_cc
      do b = 1,.b.n_cc
        do c = 1,.c.n_cc
          do d = 1,.d.n_cc
            G.a.ex = .a.ex(a)
            G.b.ex = .b.ex(b)
            G.c.ex = .c.ex(c)
            G.d.ex = .d.ex(d)
            G.make_ERI_ints(II)
            I = I + II*.a.cc(a)*.b.cc(b)*.c.cc(c)*.d.cc(d)
          end
        end
      end
    end
    II.destroy
    .to_normalise(I)
  end

  make_spin_orbit_ints(S,O)
  ! Make the spin same orbit integrals, "Sx", ... , and the
  ! spin other orbit integrals "Ox", ... , using
  ! Gauss-Hermite quadrature. Probably not the best implementation.
    S,O :: REALMAT5
    .make_spin_orbit_ints(S(:,:,:,:,1),S(:,:,:,:,2),S(:,:,:,:,3), &
                          O(:,:,:,:,1),O(:,:,:,:,2),O(:,:,:,:,3))
  end

  make_spin_orbit_ints(Sx,Sy,Sz,Ox,Oy,Oz)
  ! Make the spin same orbit integrals, "Sx", ... , and the
  ! spin other orbit integrals "Ox", ... , using
  ! Gauss-Hermite quadrature. Probably not the best implementation.
    Sx,Sy,Sz,Ox,Oy,Oz :: REALMAT4
    SSx,SSy,SSz,OOx,OOy,OOz :: REALMAT4*
    G :: GAUSSIAN4
    a,b,c,d,na,nb,nc,nd :: INT
    cc :: REAL
    Sx = ZERO; Sy = ZERO; Sz = ZERO
    Ox = ZERO; Oy = ZERO; Oz = ZERO
    na = .a.n_comp; nb = .b.n_comp; nc =.c.n_comp; nd =.d.n_comp
    SSx.create(na,nb,nc,nd); SSy.create(na,nb,nc,nd); SSz.create(na,nb,nc,nd)
    OOx.create(na,nb,nc,nd); OOy.create(na,nb,nc,nd); OOz.create(na,nb,nc,nd)
    G.a.l   = .a.l;   G.b.l   = .b.l;   G.c.l   = .c.l;   G.d.l   = .d.l
    G.a.pos = .a.pos; G.b.pos = .b.pos; G.c.pos = .c.pos; G.d.pos = .d.pos
    do a = 1,.a.n_cc
      do b = 1,.b.n_cc
        do c = 1,.c.n_cc
          do d = 1,.d.n_cc
            G.a.ex = .a.ex(a)
            G.b.ex = .b.ex(b)
            G.c.ex = .c.ex(c)
            G.d.ex = .d.ex(d)
            G.make_spin_orbit_ints(SSx,SSy,SSz,OOx,OOy,OOz)
            cc = .a.cc(a)*.b.cc(b)*.c.cc(c)*.d.cc(d)
            Sx = Sx + SSx*cc; Sy = Sy + SSy*cc; Sz = Sz + SSz*cc
            Ox = Ox + OOx*cc; Oy = Oy + OOy*cc; Oz = Oz + OOz*cc
          end
        end
      end
    end
    OOz.destroy; OOy.destroy; OOx.destroy
    SSz.destroy; SSy.destroy; SSx.destroy
    .to_normalise(Sx); .to_normalise(Sy); .to_normalise(Sz)
    .to_normalise(Ox); .to_normalise(Oy); .to_normalise(Oz)
  end

  make_spin_spin_dipole_ints(Dxx,Dyy,Dzz,Dxy,Dxz,Dyz)
  ! Make the spin spin magnetic dipole integrals, "Dij"
  ! using Gauss-Hermite quadrature. For sure, not the
  ! best implementation, but where else will you get em', eh?
    Dxx,Dyy,Dzz,Dxy,Dxz,Dyz :: REALMAT4
    Mxx,Myy,Mzz,Mxy,Mxz,Myz :: REALMAT4*
    G :: GAUSSIAN4
    a,b,c,d,na,nb,nc,nd :: INT
    cc :: REAL
    Dxx = ZERO; Dyy = ZERO; Dzz = ZERO
    Dxy = ZERO; Dxz = ZERO; Dyz = ZERO
    na = .a.n_comp; nb = .b.n_comp; nc =.c.n_comp; nd =.d.n_comp
    Mxx.create(na,nb,nc,nd); Myy.create(na,nb,nc,nd); Mzz.create(na,nb,nc,nd)
    Mxy.create(na,nb,nc,nd); Mxz.create(na,nb,nc,nd); Myz.create(na,nb,nc,nd)
    G.a.l   = .a.l;   G.b.l   = .b.l;   G.c.l   = .c.l;   G.d.l   = .d.l
    G.a.pos = .a.pos; G.b.pos = .b.pos; G.c.pos = .c.pos; G.d.pos = .d.pos
    do a = 1,.a.n_cc
      do b = 1,.b.n_cc
        do c = 1,.c.n_cc
          do d = 1,.d.n_cc
            G.a.ex = .a.ex(a)
            G.b.ex = .b.ex(b)
            G.c.ex = .c.ex(c)
            G.d.ex = .d.ex(d)
            G.make_spin_spin_dipole_ints(Mxx,Myy,Mzz,Mxy,Mxz,Myz)
            cc = .a.cc(a)*.b.cc(b)*.c.cc(c)*.d.cc(d)
            Dxx = Dxx + Mxx*cc; Dyy = Dyy + Myy*cc; Dzz = Dzz + Mzz*cc
            Dxy = Dxy + Mxy*cc; Dxz = Dxz + Mxz*cc; Dyz = Dyz + Myz*cc
          end
        end
      end
    end
    Myz.destroy; Mxz.destroy; Mxy.destroy
    Mzz.destroy; Myy.destroy; Mxx.destroy
    .to_normalise(Dxx); .to_normalise(Dyy); .to_normalise(Dzz)
    .to_normalise(Dxy); .to_normalise(Dxz); .to_normalise(Dyz)
  end

  make_ERI_derivatives(AA,BB,CC,DD)
  !
    AA,BB,CC,DD :: REALMAT5, optional
    AX,BX,CX,DX :: REALMAT5*
    G :: GAUSSIAN4
    a,b,c,d, na,nb,nc,nd :: INT
    fac :: REAL
    G.a.l = .a.l; G.b.l = .b.l; G.c.l = .c.l; G.d.l = .d.l
    G.a.pos = .a.pos; G.b.pos = .b.pos; G.c.pos = .c.pos; G.d.pos = .d.pos
    na = .a.n_comp; nb = .b.n_comp; nc =.c.n_comp; nd =.d.n_comp
    if (present(AA)) then
      AA = ZERO; AX.create(na,nb,nc,nd,3)
    end
    if (present(BB)) then
      BB = ZERO; BX.create(na,nb,nc,nd,3)
    end
    if (present(CC)) then
      CC = ZERO; CX.create(na,nb,nc,nd,3)
    end
    if (present(DD)) then
      DD = ZERO; DX.create(na,nb,nc,nd,3)
    end
    do a = 1,.a.n_cc
      do b = 1,.b.n_cc
        do c = 1,.c.n_cc
          do d = 1,.d.n_cc
            G.a.ex = .a.ex(a)
            G.b.ex = .b.ex(b)
            G.c.ex = .c.ex(c)
            G.d.ex = .d.ex(d)
            G.make_ERI_derivatives(AA=AX,BB=BX,CC=CX,DD=DX)
            fac = .a.cc(a)*.b.cc(b)*.c.cc(c)*.d.cc(d)
            if (present(AA)) AA = AA + AX*fac
            if (present(BB)) BB = BB + BX*fac
            if (present(CC)) CC = CC + CX*fac
            if (present(DD)) DD = DD + DX*fac
          end
        end
      end
    end
    if (present(DD)) then
      DX.destroy; .to_normalise(DD)
    end
    if (present(CC)) then
      CX.destroy; .to_normalise(CC)
    end
    if (present(BB)) then
      BX.destroy; .to_normalise(BB)
    end
    if (present(AA)) then
      AX.destroy; .to_normalise(AA)
    end
  end

!*******************************************************************************
!                   Roland Lindh-style integrals
!
! Electron repulsion integrals from Lindh, Ryu and Liu,
! J. Chem. Phys 95(8) 1991, 5889-5897.
!
! See also:
! Obara and Saika, J. Chem. Phys. 84(7), 1986, 3963-3974.
! Head-Gordon and Pople, J. Chem. Phys. 89(9), 1988, 5777-5786.
!
!*******************************************************************************

  get_ERI(abcd)
  ! Makes the (ab|cd) integrals, summed over the primitives
  ! (uses the transfer equation to make (ab|cd) from (es|fs))
    self :: IN
    abcd :: REALMAT4, OUT
    escd :: REALMAT3*
    esfs :: REALMAT*
    eub,fub,ab_l_max,cd_l_max :: INT
    nullify(esfs)
    nullify(escd)
    ab_l_max = max(.a.l,.b.l)-1
    cd_l_max = max(.c.l,.d.l)-1
    eub = (.a.l+.b.l).n_comp_sum - ab_l_max.n_comp_sum
    fub = (.c.l+.d.l).n_comp_sum - cd_l_max.n_comp_sum
    esfs.create(eub,fub)
    .make_esfs(esfs)
    escd.create(eub, .c.n_comp, .d.n_comp)
    .transfer_cd(esfs,escd)
    .transfer_ab(escd,abcd)
    escd.destroy
    esfs.destroy
    .to_normalise(abcd)
  end

  make_esfs(esfs) ::: private
  ! Makes the initial (es|fs) integrals, summed over the primitives
    self :: IN
    esfs :: REALMAT, OUT
    Ixa,Iya,Iza :: REALMAT3*
    rys1 :: RYS*
    Ix,Iy,Iz :: REALMAT*
    At,Ct,P,Q,PA,QC,QP,AB,CD :: REALVEC(3)
    zeta,eta,xx,zinv,rho,einv,rho_zinv,rho_einv :: REAL
    ce,cf,bb,ce1,kappa_ab,kappa_cd,normab,norm,r2ab,r2cd :: REAL
    a_cc,b_cc,c_cc,d_cc,a_ex,b_ex,c_ex,d_ex :: REAL
    t2,t2_rz,t2_re,half_zinv,half_einv,f1_bb,f1_cf :: REAL
    ag,bg,cg,dg,nroots,eub,fub,dim1,dim2 :: INT
    e,f,e1,f1,fp1,ep1,n,i,n_sum,ab_l_sum,cd_l_sum,ab_l_max,cd_l_max :: INT

    ab_l_sum = .a.l + .b.l
    cd_l_sum = .c.l + .d.l
    ab_l_max = max(.a.l,.b.l)-1
    cd_l_max = max(.c.l,.d.l)-1
    eub = ab_l_sum.n_comp_sum - ab_l_max.n_comp_sum
    fub = cd_l_sum.n_comp_sum - cd_l_max.n_comp_sum
    dim1 = ab_l_sum + 1
    dim2 = cd_l_sum + 1
    nroots = (dim1+dim2)/2

    ! number of elements to sum over
    n_sum = nroots*.a.n_cc*.b.n_cc*.c.n_cc*.d.n_cc
    Ixa.create(n_sum,dim1,dim2)
    Iya.create(n_sum,dim1,dim2)
    Iza.create(n_sum,dim1,dim2)

    AB = .a.pos-.b.pos
    CD = .c.pos-.d.pos
    r2ab = dot_product(AB,AB)
    r2cd = dot_product(CD,CD)
    ! Want position of shell1 with higher angular momentum.
    if (.a.l > .b.l) then; At = .a.pos
    else;                  At = .b.pos
    end
    if (.c.l > .d.l) then; Ct = .c.pos
    else;                  Ct = .d.pos
    end

    rys1.create(nroots)

    i = 0
    do ag = 1, .a.n_cc
      a_cc = .a.cc(ag)
      a_ex = .a.ex(ag)
      do bg = 1, .b.n_cc
        b_cc = .b.cc(bg)
        b_ex = .b.ex(bg)
        zeta = a_ex + b_ex
        zinv = ONE/zeta
        half_zinv = HALF * zinv
        kappa_ab = exp(-a_ex*b_ex*r2ab*zinv)
        normab = TWOPI5ON2 * b_cc*a_cc * zinv * sqrt(zinv) * kappa_ab
        P = (b_ex*.b.pos + a_ex*.a.pos) * zinv
        PA = P - At
        do cg = 1, .c.n_cc
          c_cc = .c.cc(cg)
          c_ex = .c.ex(cg)
          do dg = 1, .d.n_cc
            d_cc = .d.cc(dg)
            d_ex = .d.ex(dg)
            eta = c_ex + d_ex
            einv = ONE/eta
            half_einv = HALF * einv
            kappa_cd = exp(-c_ex*d_ex*r2cd*einv)
            norm = normab * d_cc*c_cc * einv * sqrt(einv) * kappa_cd
            Q = (d_ex*.d.pos + c_ex*.c.pos) * einv
            QC = Q - Ct
            rho  = zeta * eta / (zeta + eta)
            rho_zinv = rho * zinv
            rho_einv = rho * einv
            half_einv = HALF * einv
            QP = Q - P
            xx   = rho * dot_product(QP,QP)
            rys1.get_weights(xx)
            rys1.w(:) = rys1.w(:) * (norm * sqrt(rho))

            ! Now make the 2 dimensional integrals.
            do n=1,nroots
              i = i + 1
              Ix => Ixa(i,:,:)
              Iy => Iya(i,:,:)
              Iz => Iza(i,:,:)
              t2      = rys1.r(n)
              t2_rz   = t2 * rho_zinv
              t2_re   = t2 * rho_einv
              cf      = (ONE - t2_re) * half_einv
              ce      = (ONE - t2_rz) * half_zinv
              bb      = t2_rz * half_einv
              Ix(1,1) = ONE
              Iy(1,1) = ONE
              Iz(1,1) = ONE
              if (ab_l_sum>0) then
                Ix(2,1) = PA(1) + t2_rz * QP(1)
                Iy(2,1) = PA(2) + t2_rz * QP(2)
                Iz(2,1) = PA(3) + t2_rz * QP(3)
                do e = 2, ab_l_sum
                  e1 = e - 1
                  ep1 = e + 1
                  ce1 = (e-1) * ce
                  Ix(ep1,1) = Ix(2,1) * Ix(e,1) + ce1 * Ix(e1,1)
                  Iy(ep1,1) = Iy(2,1) * Iy(e,1) + ce1 * Iy(e1,1)
                  Iz(ep1,1) = Iz(2,1) * Iz(e,1) + ce1 * Iz(e1,1)
                end
              end
              if (cd_l_sum>0) then
                Ix(1,2) = QC(1) - t2_re * QP(1)
                Iy(1,2) = QC(2) - t2_re * QP(2)
                Iz(1,2) = QC(3) - t2_re * QP(3)
                do f = 2,cd_l_sum
                  f1 = f - 1
                  fp1   = f + 1
                  f1_cf = (f-1)*cf
                  Ix(1,fp1) = Ix(1,2) * Ix(1,f) + f1_cf * Ix(1,f1)
                  Iy(1,fp1) = Iy(1,2) * Iy(1,f) + f1_cf * Iy(1,f1)
                  Iz(1,fp1) = Iz(1,2) * Iz(1,f) + f1_cf * Iz(1,f1)
                end
                if (ab_l_sum>0) then
                  Ix(2,2) = Ix(1,2) * Ix(2,1) + bb
                  Iy(2,2) = Iy(1,2) * Iy(2,1) + bb
                  Iz(2,2) = Iz(1,2) * Iz(2,1) + bb
                  do f = 2,cd_l_sum
                    f1 = f - 1
                    fp1   = f + 1
                    f1_cf = (f-1)*cf
                    Ix(2,fp1) = Ix(1,2) * Ix(2,f) + f1_cf * Ix(2,f1) + bb * Ix(1,f)
                    Iy(2,fp1) = Iy(1,2) * Iy(2,f) + f1_cf * Iy(2,f1) + bb * Iy(1,f)
                    Iz(2,fp1) = Iz(1,2) * Iz(2,f) + f1_cf * Iz(2,f1) + bb * Iz(1,f)
                  end
                end
              end
              do e = 2, ab_l_sum
                e1  = e - 1
                ep1 = e + 1
                ce1 = (e-1) * ce
                do f=2, cd_l_sum+1
                  f1 = f - 1
                  f1_bb = (f-1)*bb
                  Ix(ep1,f) = Ix(2,1)*Ix(e,f) + ce1*Ix(e1,f) + f1_bb*Ix(e,f1)
                  Iy(ep1,f) = Iy(2,1)*Iy(e,f) + ce1*Iy(e1,f) + f1_bb*Iy(e,f1)
                  Iz(ep1,f) = Iz(2,1)*Iz(e,f) + ce1*Iz(e1,f) + f1_bb*Iz(e,f1)
                end
              end
              Iz = Iz * rys1.w(n)
            end
          end
        end
      end
    end

    rys1.destroy

    .form_3d_ints(Ixa,Iya,Iza,esfs,eub,fub,n_sum)

    Iza.destroy
    Iya.destroy
    Ixa.destroy
  end

  form_3d_ints(Ix,Iy,Iz,esfs,eub,fub,n_sum) ::: private
  ! Forms (es|fs) from the two dimensional integrals, summed over primitives.
  ! This is the main routine, all the others are specialised and may break if
  ! given the wrong shell4.
    self :: IN
    Ix,Iy,Iz :: REALMAT3, IN
    esfs :: REALMAT, OUT
    eub,fub,n_sum :: INT, IN
    if (min(.a.l,.b.l) < 3 AND min(.c.l,.d.l) < 3) then !s or p or d
      .form_3d_ints_no_rm(Ix,Iy,Iz,esfs,eub,fub)
    else
      .form_3d_ints_rm(Ix,Iy,Iz,esfs,eub,fub,n_sum)
    end
  end

  form_3d_ints_rm(Ix,Iy,Iz,esfs,eub,fub,n_sum) ::: private
  ! Forms the three dimensional integrals from the two dimensional integrals,
  ! summed over primitives.
  ! This version uses the reduced multiplication scheme.
    self :: IN
    Ix,Iy,Iz :: REALMAT3, IN
    esfs :: REALMAT, OUT
    eub,fub,n_sum :: INT, IN
    e_x,e_y,e_z,f_x,f_y,f_z,ii_e_ivec,ii_f_ivec :: INTVEC*
    Ief :: REALMAT3*
    e,f,zf,yf,ze,ye,iie,iif,m :: INT
    dime,dimf,dime1,dimf1,dime2,dimf2 :: INT

    dime  = .a.l+.b.l+1
    dime1 = dime+1
    dime2 = 2*dime1+1
    dimf  = .c.l+.d.l+1
    dimf1 = dimf+1
    dimf2 = 2*dimf1+1

    e_x.create(eub);  e_y.create(eub);  e_z.create(eub)
    f_x.create(fub);  f_y.create(fub);  f_z.create(fub)
    m = max(.a.l,.b.l); m.make_gaussian_xyz_indices(e_x,e_y,e_z,.a.l+.b.l)
    m = max(.c.l,.d.l); m.make_gaussian_xyz_indices(f_x,f_y,f_z,.c.l+.d.l)

    ii_e_ivec.create(eub)
    do e=1,eub
      ze = e_z(e)
      ii_e_ivec(e) = -dime1 + ze*(dime2-ze)/2 + e_y(e)
    end
    ii_f_ivec.create(fub)
    do f=1,fub
      zf = f_z(f)
      ii_f_ivec(f) = -dimf1 + zf*(dimf2-zf)/2 + f_y(f)
    end

    ! Apply reduced multiplication scheme to Iy and Iz, store in triangle.
    Ief.create(n_sum,dime*dime1/2,dimf*dimf1/2)
    iif = 0
    do zf=1,dimf
      do yf=1,dimf1-zf
        iif = iif + 1
        iie = 0
        do ze=1,dime
          do ye=1,dime1-ze
            iie = iie + 1
            Ief(:,iie,iif) = Iy(:,ye,yf) * Iz(:,ze,zf)
          end
        end
      end
    end

    ! Now add in the Ix 2d integrals and sum over contractions and roots
    esfs = sum(Ix(:,e_x,f_x) * Ief(:,ii_e_ivec,ii_f_ivec),dim=1)
    Ief.destroy

    ii_f_ivec.destroy
    ii_e_ivec.destroy
    f_z.destroy;  f_y.destroy;  f_x.destroy
    e_z.destroy;  e_y.destroy;  e_x.destroy
  end

  form_3d_ints_no_rm(Ix,Iy,Iz,esfs,eub,fub) ::: private
  ! Forms the three dimensional integrals from the two dimensional integrals,
  ! summed over primitives.
  ! This version does not use the reduced multiplication scheme.
    self :: IN
    Ix,Iy,Iz :: REALMAT3, IN
    esfs :: REALMAT, OUT
    eub,fub :: INT, IN
    e,f,m :: INT
    e_x,e_y,e_z,f_x,f_y,f_z :: INTVEC*

    e_x.create(eub);  e_y.create(eub);  e_z.create(eub)
    f_x.create(fub);  f_y.create(fub);  f_z.create(fub)
    m = max(.a.l,.b.l); m.make_gaussian_xyz_indices(e_x,e_y,e_z,.a.l+.b.l)
    m = max(.c.l,.d.l); m.make_gaussian_xyz_indices(f_x,f_y,f_z,.c.l+.d.l)

    !esfs = sum(Ix(:,e_x,f_x) * Iy(:,e_y,f_y) * Iz(:,e_z,f_z),dim=1)
    do e=1,eub
      do f=1,fub
        esfs(e,f) = sum(Ix(:,e_x(e),f_x(f)) * Iy(:,e_y(e),f_y(f)) * Iz(:,e_z(e),f_z(f)))
      end
    end

    f_z.destroy;  f_y.destroy;  f_x.destroy
    e_z.destroy;  e_y.destroy;  e_x.destroy
  end

  transfer_cd(esfs,escd)
  ! Applies the transfer equation to (es|fs) to give (es|cd)
    self :: IN
    esfs :: REALMAT, IN
    escd :: REALMAT3, OUT
    if (.c.l > .d.l) then
      .transfer_l_c_highest(esfs,escd)
    else
      .transfer_l_d_highest(esfs,escd)
    end
  end

  transfer_ab(escd,abcd)
  ! Applies the transfer equation to (es|cd) to give (ab|cd)
    self :: IN
    escd :: REALMAT3, IN
    abcd :: REALMAT4, OUT
    if (.a.l > .b.l) then
      .transfer_l_a_highest(escd,abcd)
    else
      .transfer_l_b_highest(escd,abcd)
    end
  end

  transfer_ab(escd,abcd)
  ! Applies the transfer equation to (es|cd) to give (ab|cd)
    self :: IN
    escd :: REALMAT, IN
    abcd :: REALMAT3, OUT
    if (.a.l > .b.l) then
      .transfer_l_a_highest(escd,abcd)
    else
      .transfer_l_b_highest(escd,abcd)
    end
  end

   transfer_l_c_highest(esfs,escd) ::: private
   ! Applies the transfer equation to (es|fs) to give (es|cd)
     self :: IN
     esfs :: REALMAT, IN
     escd :: REALMAT3, OUT
     int_new,int_old :: REALMAT3*
     components,components_c,components_d :: INTMAT*
     index_c,index_d :: INTMAT3*
     comp_to_use,component_to_use :: INTVEC*
     CD :: REALVEC(3)
     c,d,c1,c2,c3,d1,ld,cub,dub,ab_l_max :: INT
     cx,cy,cz,dx,dy,dz,j,clb,dlb,tmp,e,eub :: INT
     CDi,CDx,CDy,CDz,esfs_ec :: REAL

     select case (.d.l)
       case (0)
         escd(:,:,1)=esfs

       case (1)
         ab_l_max = max(.a.l,.b.l)-1
         clb = (.c.l-1).n_comp_sum
         eub = (.a.l+.b.l).n_comp_sum - ab_l_max.n_comp_sum
         CD   = .c.pos - .d.pos
         cub  = .c.n_comp

         components.create(3, (.c.l+.d.l).n_comp_sum - clb)
         index_c.create(0,(.c.l+.d.l),0,(.c.l+.d.l),0,(.c.l+.d.l))
         .c.l.make_gaussian_xyz_powers(components,(.c.l+.d.l),index_c)

         CDx = CD(1); CDy = CD(2); CDz = CD(3)
         do c = 1, cub
           cx = components(1,c)
           cy = components(2,c)
           cz = components(3,c)
           c1 = index_c(cx+1,cy,cz)
           c2 = index_c(cx,cy+1,cz)
           c3 = index_c(cx,cy,cz+1)
           do e = 1, eub
             esfs_ec = esfs(e,c)
             escd(e,c,1) = esfs(e,c1) + CDx * esfs_ec
             escd(e,c,2) = esfs(e,c2) + CDy * esfs_ec
             escd(e,c,3) = esfs(e,c3) + CDz * esfs_ec
           end
         end
         components.destroy
         index_c.destroy

       case default
         ab_l_max = max(.a.l,.b.l)-1
         clb  = (.c.l-1).n_comp_sum
         eub  = (.a.l+.b.l).n_comp_sum - ab_l_max.n_comp_sum
         CD   = .c.pos - .d.pos
         cub  = ((.c.l+.d.l)-1).n_comp_sum - clb

         index_c.create(0,(.c.l+.d.l),0,(.c.l+.d.l),0,(.c.l+.d.l))
         index_d.create(0,(.c.l+.d.l),0,(.c.l+.d.l),0,(.c.l+.d.l))
         components.create(3, (.c.l+.d.l).n_comp_sum)
         comp_to_use.create( (.c.l+.d.l).n_comp_sum )
         tmp=0; tmp.make_gaussian_xyz_powers(components,(.c.l+.d.l),index_d,comp_to_use)
         .c.l.make_gaussian_xyz_power_index(index_c,(.c.l+.d.l))
         components_c => components(:,clb+1:)

         nullify(int_new)
         int_new.create(eub,cub,3)

         CDx = CD(1); CDy = CD(2); CDz = CD(3)
         do c = 1, cub
           cx = components_c(1,c)
           cy = components_c(2,c)
           cz = components_c(3,c)
           c1 = index_c(cx+1,cy,cz)
           c2 = index_c(cx,cy+1,cz)
           c3 = index_c(cx,cy,cz+1)
           do e = 1, eub
             esfs_ec = esfs(e,c)
             int_new(e,c,1) = esfs(e,c1) + CDx * esfs_ec
             int_new(e,c,2) = esfs(e,c2) + CDy * esfs_ec
             int_new(e,c,3) = esfs(e,c3) + CDz * esfs_ec
           end
         end

         do ld=2, .d.l - 1
           dlb              = (ld-1).n_comp_sum
           dub              = ld.n_comp
           cub              = ((.c.l+.d.l)-ld).n_comp_sum - clb
           component_to_use => comp_to_use(dlb+1:dlb+dub)
           components_d     => components(:,dlb+1:dlb+dub)
           int_old          => int_new
           nullify(int_new)
           int_new.create(eub,cub,dub)
           do d=1,dub
             dx = components_d(1,d)
             dy = components_d(2,d)
             dz = components_d(3,d)
             j=component_to_use(d)
             .subtract_from_component(dx,dy,dz,j)
             d1 = index_d(dx,dy,dz)
             CDi=CD(j)
             do c=1,cub
               cx = components_c(1,c)
               cy = components_c(2,c)
               cz = components_c(3,c)
               .add_to_component(cx,cy,cz,j)
               c1 = index_c(cx,cy,cz)
               int_new(:,c,d)=int_old(:,c1,d1)+CDi*int_old(:,c,d1)
             end
           end
           int_old.destroy
         end

         dlb              = (.d.l-1).n_comp_sum
         dub              = .d.n_comp
         cub              = .c.n_comp
         component_to_use => comp_to_use(dlb+1:dlb+dub)
         components_d     => components(:,dlb+1:dlb+dub)
         int_old          => int_new
         do d=1,dub
           dx = components_d(1,d)
           dy = components_d(2,d)
           dz = components_d(3,d)
           j=component_to_use(d)
           .subtract_from_component(dx,dy,dz,j)
           d1 = index_d(dx,dy,dz)
           CDi=CD(j)
           do c=1,cub
             cx = components_c(1,c)
             cy = components_c(2,c)
             cz = components_c(3,c)
             .add_to_component(cx,cy,cz,j)
             c1 = index_c(cx,cy,cz)
             escd(:,c,d)=int_old(:,c1,d1)+CDi*int_old(:,c,d1)
           end
         end
         int_old.destroy
         index_c.destroy
         index_d.destroy
         components.destroy
         comp_to_use.destroy
     end
   end

   transfer_l_d_highest(esfs,escd) ::: private
   ! Applies the transfer equation to (es|fs) to give (es|cd)
     self :: IN
     esfs :: REALMAT, IN
     escd :: REALMAT3, OUT
     int_new,int_old :: REALMAT3*
     components,components_c,components_d :: INTMAT*
     index_c,index_d :: INTMAT3*
     comp_to_use,component_to_use :: INTVEC*
     DC :: REALVEC(3)
     c,d,c1,d1,d2,d3,lc,cub,dub,ab_l_max :: INT
     cx,cy,cz,dx,dy,dz,j,clb,dlb,tmp,eub :: INT
     DCi,DCx,DCy,DCz :: REAL

     select case (.c.l)
       case (0)
         escd(:,1,:)=esfs

       case (1)
         ab_l_max = max(.a.l,.b.l)-1
         dlb = (.d.l-1).n_comp_sum
         eub = (.a.l+.b.l).n_comp_sum - ab_l_max.n_comp_sum
         DC   = .d.pos - .c.pos
         dub  = .d.n_comp

         components.create(3, (.c.l+.d.l).n_comp_sum - dlb)
         index_d.create(0,(.c.l+.d.l),0,(.c.l+.d.l),0,(.c.l+.d.l))
         .d.l.make_gaussian_xyz_powers(components,(.c.l+.d.l),index_d)

         DCx=DC(1); DCy=DC(2); DCz=DC(3)
         do d=1,dub
           dx = components(1,d)
           dy = components(2,d)
           dz = components(3,d)
           d1 = index_d(dx+1,dy,dz)
           d2 = index_d(dx,dy+1,dz)
           d3 = index_d(dx,dy,dz+1)
             escd(:,1,d)=esfs(:,d1)+DCx*esfs(:,d)
             escd(:,2,d)=esfs(:,d2)+DCy*esfs(:,d)
             escd(:,3,d)=esfs(:,d3)+DCz*esfs(:,d)
         end
         components.destroy
         index_d.destroy

       case default
         ab_l_max = max(.a.l,.b.l)-1
         dlb = (.d.l-1).n_comp_sum
         eub = (.a.l+.b.l).n_comp_sum - ab_l_max.n_comp_sum
         DC   = .d.pos - .c.pos
         dub  = (.c.l+.d.l-1).n_comp_sum - dlb

         index_c.create(0,(.c.l+.d.l),0,(.c.l+.d.l),0,(.c.l+.d.l))
         index_d.create(0,(.c.l+.d.l),0,(.c.l+.d.l),0,(.c.l+.d.l))
         components.create(3, (.c.l+.d.l).n_comp_sum)
         comp_to_use.create( (.c.l+.d.l).n_comp_sum )
         tmp=0; tmp.make_gaussian_xyz_powers(components,(.c.l+.d.l),index_c,comp_to_use)
         .d.l.make_gaussian_xyz_power_index(index_d,(.c.l+.d.l))
         components_d => components(:,dlb+1:)

         nullify(int_new)
         int_new.create(eub,dub,3)
         DCx=DC(1); DCy=DC(2); DCz=DC(3)
         do d=1,dub
           dx = components_d(1,d)
           dy = components_d(2,d)
           dz = components_d(3,d)
           d1 = index_d(dx+1,dy,dz)
           d2 = index_d(dx,dy+1,dz)
           d3 = index_d(dx,dy,dz+1)
             int_new(:,d,1)=esfs(:,d1)+DCx*esfs(:,d)
             int_new(:,d,2)=esfs(:,d2)+DCy*esfs(:,d)
             int_new(:,d,3)=esfs(:,d3)+DCz*esfs(:,d)
         end
         do lc=2, .c.l - 1
           clb              = (lc-1).n_comp_sum
           cub              = lc.n_comp
           dub              = ((.c.l+.d.l)-lc).n_comp_sum - dlb
           component_to_use => comp_to_use(clb+1:clb+cub)
           components_c     => components(:,clb+1:clb+cub)
           int_old          => int_new
           nullify(int_new)
           int_new.create(eub,dub,cub)
           do c=1,cub
             cx = components_c(1,c)
             cy = components_c(2,c)
             cz = components_c(3,c)
             j=component_to_use(c)
             .subtract_from_component(cx,cy,cz,j)
             c1 = index_c(cx,cy,cz)
             DCi=DC(j)
             do d=1,dub
               dx = components_d(1,d)
               dy = components_d(2,d)
               dz = components_d(3,d)
               .add_to_component(dx,dy,dz,j)
               d1 = index_d(dx,dy,dz)
               int_new(:,d,c)=int_old(:,d1,c1)+DCi*int_old(:,d,c1)
             end
           end
           int_old.destroy
         end
         clb              = (.c.l-1).n_comp_sum
         cub              = .c.n_comp
         dub              = .d.n_comp
         component_to_use => comp_to_use(clb+1:clb+cub)
         components_c     => components(:,clb+1:clb+cub)
         int_old          => int_new
         do c=1,cub
           cx = components_c(1,c)
           cy = components_c(2,c)
           cz = components_c(3,c)
           j=component_to_use(c)
           .subtract_from_component(cx,cy,cz,j)
           c1 = index_c(cx,cy,cz)
           DCi=DC(j)
           do d=1,dub
             dx = components_d(1,d)
             dy = components_d(2,d)
             dz = components_d(3,d)
             .add_to_component(dx,dy,dz,j)
             d1 = index_d(dx,dy,dz)
             escd(:,c,d)=int_old(:,d1,c1)+DCi*int_old(:,d,c1)
           end
         end
         int_old.destroy
         index_c.destroy
         index_d.destroy
         components.destroy
         comp_to_use.destroy
     end
   end

   transfer_l_a_highest(escd,abcd) ::: private
   ! Applies the transfer equation to (es|cd) to give (ab|cd)
     self :: IN
     escd :: REALMAT3, IN
     abcd :: REALMAT4, OUT
     int_new,int_old :: REALMAT4*
     components,components_a,components_b :: INTMAT*
     index_a,index_b :: INTMAT3*
     AB :: REALVEC(3)
     a,b,c,d,a1,a2,a3,b1,lb,aub,bub,cub,dub :: INT
     ax,ay,az,bx,by,bz,j,alb,blb,tmp :: INT
     ABi,ABx,ABy,ABz,escd_acd :: REAL
     comp_to_use,component_to_use :: INTVEC*

     select case (.b.l)
       case (0)
         abcd(:,1,:,:)=escd

       case (1)
         alb = (.a.l-1).n_comp_sum
         AB   = .a.pos - .b.pos
         aub  = .a.n_comp
         cub  = .c.n_comp
         dub  = .d.n_comp

         components.create(3, (.a.l+.b.l).n_comp_sum - alb)
         index_a.create(0,(.a.l+.b.l),0,(.a.l+.b.l),0,(.a.l+.b.l))
         .a.l.make_gaussian_xyz_powers(components,(.a.l+.b.l),index_a)

         ABx=AB(1); ABy=AB(2); ABz=AB(3)
         do a=1,aub
           ax = components(1,a)
           ay = components(2,a)
           az = components(3,a)
           a1 = index_a(ax+1,ay,az)
           a2 = index_a(ax,ay+1,az)
           a3 = index_a(ax,ay,az+1)
           do d=1,dub
             do c=1,cub
               escd_acd = escd(a,c,d)
               abcd(a,1,c,d)=escd(a1,c,d) + ABx * escd_acd
               abcd(a,2,c,d)=escd(a2,c,d) + ABy * escd_acd
               abcd(a,3,c,d)=escd(a3,c,d) + ABz * escd_acd
             end
           end
         end
         index_a.destroy
         components.destroy

       case default
         alb = (.a.l-1).n_comp_sum
         AB   = .a.pos - .b.pos
         aub  = ((.a.l+.b.l)-1).n_comp_sum - alb
         bub  = .b.n_comp
         cub  = .c.n_comp
         dub  = .d.n_comp

         index_b.create(0,(.a.l+.b.l),0,(.a.l+.b.l),0,(.a.l+.b.l))
         index_a.create(0,(.a.l+.b.l),0,(.a.l+.b.l),0,(.a.l+.b.l))
         components.create(3, (.a.l+.b.l).n_comp_sum)
         comp_to_use.create( (.a.l+.b.l).n_comp_sum )
         tmp=0; tmp.make_gaussian_xyz_powers(components,(.a.l+.b.l),index_b,comp_to_use)
         tmp=.a.l; tmp.make_gaussian_xyz_power_index(index_a,(.a.l+.b.l))
         components_a => components(:,alb+1:)

         nullify(int_new)
         int_new.create(cub,dub,bub,aub)
         ABx=AB(1); ABy=AB(2); ABz=AB(3)
         do a=1,aub
           ax = components_a(1,a)
           ay = components_a(2,a)
           az = components_a(3,a)
           a1 = index_a(ax+1,ay,az)
           a2 = index_a(ax,ay+1,az)
           a3 = index_a(ax,ay,az+1)
           do d=1,dub
             do c=1,cub
               escd_acd = escd(a,c,d)
               int_new(c,d,1,a)=escd(a1,c,d) + ABx * escd_acd
               int_new(c,d,2,a)=escd(a2,c,d) + ABy * escd_acd
               int_new(c,d,3,a)=escd(a3,c,d) + ABz * escd_acd
             end
           end
         end

         do lb=2, .b.l - 1
           blb              = (lb-1).n_comp_sum
           bub              = lb.n_comp
           aub              = ((.a.l+.b.l)-lb).n_comp_sum - alb
           component_to_use => comp_to_use(blb+1:blb+bub)
           components_b     => components(:,blb+1:blb+bub)
           int_old          => int_new
           nullify(int_new)
           int_new.create(cub,dub,bub,aub)
           do b=1,bub
             bx = components_b(1,b)
             by = components_b(2,b)
             bz = components_b(3,b)
             j = component_to_use(b)
             .subtract_from_component(bx,by,bz,j)
             b1 = index_b(bx,by,bz)
             ABi=AB(j)
             do a=1,aub
               ax = components_a(1,a)
               ay = components_a(2,a)
               az = components_a(3,a)
               .add_to_component(ax,ay,az,j)
               a1 = index_a(ax,ay,az)
               int_new(:,:,b,a)=int_old(:,:,b1,a1) + ABi * int_old(:,:,b1,a)
             end
           end
           int_old.destroy
         end

         blb              = (.b.l-1).n_comp_sum
         bub              = .b.n_comp
         aub              = .a.n_comp
         component_to_use => comp_to_use(blb+1:blb+bub)
         components_b     => components(:,blb+1:blb+bub)
         int_old          => int_new
         do b=1,bub
           bx = components_b(1,b)
           by = components_b(2,b)
           bz = components_b(3,b)
           j = component_to_use(b)
           .subtract_from_component(bx,by,bz,j)
           b1 = index_b(bx,by,bz)
           ABi=AB(j)
           do a=1,aub
             ax = components_a(1,a)
             ay = components_a(2,a)
             az = components_a(3,a)
             .add_to_component(ax,ay,az,j)
             a1 = index_a(ax,ay,az)
             abcd(a,b,:,:)=int_old(:,:,b1,a1) + ABi * int_old(:,:,b1,a)
           end
         end
         int_old.destroy
         comp_to_use.destroy
         components.destroy
         index_a.destroy
         index_b.destroy
     end
   end

   transfer_l_b_highest(escd,abcd) ::: private
   ! Applies the transfer equation to (es|cd) to give (ab|cd)
     self :: IN
     escd :: REALMAT3, IN
     abcd :: REALMAT4, OUT
     int_new,int_old :: REALMAT4*
     components,components_a,components_b :: INTMAT*
     index_a,index_b :: INTMAT3*
     BA :: REALVEC(3)
     a,b,c,d,a1,b1,b2,b3,la,aub,bub,cub,dub :: INT
     ax,ay,az,bx,by,bz,j,alb,blb,tmp :: INT
     BAi,BAx,BAy,BAz,escd_bcd :: REAL
     comp_to_use,component_to_use :: INTVEC*

     select case (.a.l)
       case (0)
         abcd(1,:,:,:)=escd

       case (1)
         blb = (.b.l-1).n_comp_sum
         BA   = .b.pos - .a.pos
         bub  = .b.n_comp
         cub  = .c.n_comp
         dub  = .d.n_comp

         components.create(3, (.a.l+.b.l).n_comp_sum - blb)
         index_b.create(0,(.a.l+.b.l),0,(.a.l+.b.l),0,(.a.l+.b.l))
         .b.l.make_gaussian_xyz_powers(components,(.a.l+.b.l),index_b)

         BAx = BA(1);    BAy = BA(2);    BAz = BA(3)
         do b = 1, bub
           bx = components(1,b)
           by = components(2,b)
           bz = components(3,b)
           b1 = index_b(bx+1,by,bz)
           b2 = index_b(bx,by+1,bz)
           b3 = index_b(bx,by,bz+1)
           do d = 1, dub
             do c = 1, cub
               escd_bcd = escd(b,c,d)
               abcd(1,b,c,d) = escd(b1,c,d) + BAx * escd_bcd
               abcd(2,b,c,d) = escd(b2,c,d) + BAy * escd_bcd
               abcd(3,b,c,d) = escd(b3,c,d) + BAz * escd_bcd
             end
           end
         end

         components.destroy
         index_b.destroy

       case default
         blb = (.b.l-1).n_comp_sum
         BA   = .b.pos - .a.pos
         bub  = ((.a.l+.b.l)-1).n_comp_sum - blb
         aub  = .a.n_comp
         cub  = .c.n_comp
         dub  = .d.n_comp

         index_a.create(0,(.a.l+.b.l),0,(.a.l+.b.l),0,(.a.l+.b.l))
         index_b.create(0,(.a.l+.b.l),0,(.a.l+.b.l),0,(.a.l+.b.l))
         components.create(3, (.a.l+.b.l).n_comp_sum)
         comp_to_use.create( (.a.l+.b.l).n_comp_sum )
         tmp=0; tmp.make_gaussian_xyz_powers(components,(.a.l+.b.l),index_a,comp_to_use)
         tmp=.b.l; tmp.make_gaussian_xyz_power_index(index_b,(.a.l+.b.l))
         components_b => components(:,blb+1:)

         nullify(int_new)
         int_new.create(cub,dub,bub,aub)

         BAx = BA(1);    BAy = BA(2);    BAz = BA(3)
         do b = 1, bub
           bx = components_b(1,b)
           by = components_b(2,b)
           bz = components_b(3,b)
           b1 = index_b(bx+1,by,bz)
           b2 = index_b(bx,by+1,bz)
           b3 = index_b(bx,by,bz+1)
           do c = 1, cub
             do d = 1, dub
               escd_bcd = escd(b,c,d)
               int_new(c,d,b,1) = escd(b1,c,d) + BAx * escd_bcd
               int_new(c,d,b,2) = escd(b2,c,d) + BAy * escd_bcd
               int_new(c,d,b,3) = escd(b3,c,d) + BAz * escd_bcd
             end
           end
         end

         do la=2, .a.l - 1
           alb              = (la-1).n_comp_sum
           aub              = la.n_comp
           bub              = ((.a.l+.b.l)-la).n_comp_sum - blb
           component_to_use => comp_to_use(alb+1:alb+aub)
           components_a     => components(:,alb+1:alb+aub)
           int_old          => int_new
           nullify(int_new)
           int_new.create(cub,dub,bub,aub)
           do a=1,aub
             ax = components_a(1,a)
             ay = components_a(2,a)
             az = components_a(3,a)
             j=component_to_use(a)
             .subtract_from_component(ax,ay,az,j)
             a1 = index_a(ax,ay,az)
             BAi=BA(j)
             do b=1,bub
               bx = components_b(1,b)
               by = components_b(2,b)
               bz = components_b(3,b)
               .add_to_component(bx,by,bz,j)
               b1 = index_b(bx,by,bz)
               int_new(:,:,b,a)=int_old(:,:,b1,a1) + BAi * int_old(:,:,b,a1)
             end
           end
           int_old.destroy
         end

         alb              = (.a.l-1).n_comp_sum
         aub              = .a.n_comp
         bub              = .b.n_comp
         component_to_use => comp_to_use(alb+1:alb+aub)
         components_a     => components(:,alb+1:alb+aub)
         int_old          => int_new
         do a=1,aub
           ax = components_a(1,a)
           ay = components_a(2,a)
           az = components_a(3,a)
           j = component_to_use(a)
           .subtract_from_component(ax,ay,az,j)
           a1 = index_a(ax,ay,az)
           BAi=BA(j)
           do b=1,bub
             bx = components_b(1,b)
             by = components_b(2,b)
             bz = components_b(3,b)
             .add_to_component(bx,by,bz,j)
             b1 = index_b(bx,by,bz)
             abcd(a,b,:,:)=int_old(:,:,b1,a1) + BAi * int_old(:,:,b,a1)
           end
         end
         int_old.destroy
         comp_to_use.destroy
         components.destroy
         index_b.destroy
         index_a.destroy
     end
   end

   transfer_l_a_highest(escd,abcd) ::: private
   ! Applies the transfer equation to (es|cd) to give (ab|cd)
     self :: IN
     escd :: REALMAT, IN
     abcd :: REALMAT3, OUT
     int_new,int_old :: REALMAT3*
     components,components_a,components_b :: INTMAT*
     index_a,index_b :: INTMAT3*
     AB :: REALVEC(3)
     a,b,f,a1,a2,a3,b1,lb,aub,bub,fub :: INT
     ax,ay,az,bx,by,bz,j,alb,blb,tmp :: INT
     ABi,ABx,ABy,ABz,escd_acd :: REAL
     comp_to_use,component_to_use :: INTVEC*

     select case (.b.l)
       case (0)
         abcd(:,1,:)=escd

       case (1)
         alb = (.a.l-1).n_comp_sum
         AB   = .a.pos - .b.pos
         aub  = .a.n_comp
         fub  = size(escd,2)

         components.create(3, (.a.l+.b.l).n_comp_sum - alb)
         index_a.create(0,(.a.l+.b.l),0,(.a.l+.b.l),0,(.a.l+.b.l))
         .a.l.make_gaussian_xyz_powers(components,(.a.l+.b.l),index_a)

         ABx=AB(1); ABy=AB(2); ABz=AB(3)
         do a=1,aub
           ax = components(1,a)
           ay = components(2,a)
           az = components(3,a)
           a1 = index_a(ax+1,ay,az)
           a2 = index_a(ax,ay+1,az)
           a3 = index_a(ax,ay,az+1)
           do f=1,fub
             escd_acd = escd(a,f)
             abcd(a,1,f)=escd(a1,f) + ABx * escd_acd
             abcd(a,2,f)=escd(a2,f) + ABy * escd_acd
             abcd(a,3,f)=escd(a3,f) + ABz * escd_acd
           end
         end
         index_a.destroy
         components.destroy

       case default
         alb = (.a.l-1).n_comp_sum
         AB   = .a.pos - .b.pos
         aub  = ((.a.l+.b.l)-1).n_comp_sum - alb
         bub  = .b.n_comp
         fub  = size(escd,2)

         index_b.create(0,(.a.l+.b.l),0,(.a.l+.b.l),0,(.a.l+.b.l))
         index_a.create(0,(.a.l+.b.l),0,(.a.l+.b.l),0,(.a.l+.b.l))
         components.create(3, (.a.l+.b.l).n_comp_sum)
         comp_to_use.create( (.a.l+.b.l).n_comp_sum )
         tmp=0; tmp.make_gaussian_xyz_powers(components,(.a.l+.b.l),index_b,comp_to_use)
         tmp=.a.l; tmp.make_gaussian_xyz_power_index(index_a,(.a.l+.b.l))
         components_a => components(:,alb+1:)

         nullify(int_new)
         int_new.create(fub,bub,aub)
         ABx=AB(1); ABy=AB(2); ABz=AB(3)
         do a=1,aub
           ax = components_a(1,a)
           ay = components_a(2,a)
           az = components_a(3,a)
           a1 = index_a(ax+1,ay,az)
           a2 = index_a(ax,ay+1,az)
           a3 = index_a(ax,ay,az+1)
           do f=1,fub
             escd_acd = escd(a,f)
             int_new(f,1,a)=escd(a1,f) + ABx * escd_acd
             int_new(f,2,a)=escd(a2,f) + ABy * escd_acd
             int_new(f,3,a)=escd(a3,f) + ABz * escd_acd
           end
         end

         do lb=2, .b.l - 1
           blb              = (lb-1).n_comp_sum
           bub              = lb.n_comp
           aub              = ((.a.l+.b.l)-lb).n_comp_sum - alb
           component_to_use => comp_to_use(blb+1:blb+bub)
           components_b     => components(:,blb+1:blb+bub)
           int_old          => int_new
           nullify(int_new)
           int_new.create(fub,bub,aub)
           do b=1,bub
             bx = components_b(1,b)
             by = components_b(2,b)
             bz = components_b(3,b)
             j = component_to_use(b)
             .subtract_from_component(bx,by,bz,j)
             b1 = index_b(bx,by,bz)
             ABi=AB(j)
             do a=1,aub
               ax = components_a(1,a)
               ay = components_a(2,a)
               az = components_a(3,a)
               .add_to_component(ax,ay,az,j)
               a1 = index_a(ax,ay,az)
               int_new(:,b,a)=int_old(:,b1,a1) + ABi * int_old(:,b1,a)
             end
           end
           int_old.destroy
         end

         blb              = (.b.l-1).n_comp_sum
         bub              = .b.n_comp
         aub              = .a.n_comp
         component_to_use => comp_to_use(blb+1:blb+bub)
         components_b     => components(:,blb+1:blb+bub)
         int_old          => int_new
         do b=1,bub
           bx = components_b(1,b)
           by = components_b(2,b)
           bz = components_b(3,b)
           j = component_to_use(b)
           .subtract_from_component(bx,by,bz,j)
           b1 = index_b(bx,by,bz)
           ABi=AB(j)
           do a=1,aub
             ax = components_a(1,a)
             ay = components_a(2,a)
             az = components_a(3,a)
             .add_to_component(ax,ay,az,j)
             a1 = index_a(ax,ay,az)
             do f=1,fub
               abcd(a,b,f)=int_old(f,b1,a1) + ABi * int_old(f,b1,a)
             end
           end
         end
         int_old.destroy
         comp_to_use.destroy
         components.destroy
         index_a.destroy
         index_b.destroy
     end
   end

   transfer_l_b_highest(escd,abcd) ::: private
   ! Applies the transfer equation to (es|cd) to give (ab|cd)
     self :: IN
     escd :: REALMAT, IN
     abcd :: REALMAT3, OUT
     int_new,int_old :: REALMAT3*
     components,components_a,components_b :: INTMAT*
     index_a,index_b :: INTMAT3*
     BA :: REALVEC(3)
     a,b,f,a1,b1,b2,b3,la,aub,bub,fub :: INT
     ax,ay,az,bx,by,bz,j,alb,blb,tmp :: INT
     BAi,BAx,BAy,BAz,escd_bcd :: REAL
     comp_to_use,component_to_use :: INTVEC*

     select case (.a.l)
       case (0)
         abcd(1,:,:)=escd

       case (1)
         blb = (.b.l-1).n_comp_sum
         BA   = .b.pos - .a.pos
         bub  = .b.n_comp
         fub  = size(escd,2)

         components.create(3, (.a.l+.b.l).n_comp_sum - blb)
         index_b.create(0,(.a.l+.b.l),0,(.a.l+.b.l),0,(.a.l+.b.l))
         .b.l.make_gaussian_xyz_powers(components,(.a.l+.b.l),index_b)

         BAx = BA(1);    BAy = BA(2);    BAz = BA(3)
         do b = 1, bub
           bx = components(1,b)
           by = components(2,b)
           bz = components(3,b)
           b1 = index_b(bx+1,by,bz)
           b2 = index_b(bx,by+1,bz)
           b3 = index_b(bx,by,bz+1)
           do f = 1, fub
             escd_bcd = escd(b,f)
             abcd(1,b,f) = escd(b1,f) + BAx * escd_bcd
             abcd(2,b,f) = escd(b2,f) + BAy * escd_bcd
             abcd(3,b,f) = escd(b3,f) + BAz * escd_bcd
           end
         end

         components.destroy
         index_b.destroy

       case default
         blb = (.b.l-1).n_comp_sum
         BA   = .b.pos - .a.pos
         bub  = ((.a.l+.b.l)-1).n_comp_sum - blb
         aub  = .a.n_comp
         fub  = size(escd,2)

         index_a.create(0,(.a.l+.b.l),0,(.a.l+.b.l),0,(.a.l+.b.l))
         index_b.create(0,(.a.l+.b.l),0,(.a.l+.b.l),0,(.a.l+.b.l))
         components.create(3, (.a.l+.b.l).n_comp_sum)
         comp_to_use.create( (.a.l+.b.l).n_comp_sum )
         tmp=0; tmp.make_gaussian_xyz_powers(components,(.a.l+.b.l),index_a,comp_to_use)
         tmp=.b.l; tmp.make_gaussian_xyz_power_index(index_b,(.a.l+.b.l))
         components_b => components(:,blb+1:)

         nullify(int_new)
         int_new.create(fub,bub,aub)

         BAx = BA(1);    BAy = BA(2);    BAz = BA(3)
         do b = 1, bub
           bx = components_b(1,b)
           by = components_b(2,b)
           bz = components_b(3,b)
           b1 = index_b(bx+1,by,bz)
           b2 = index_b(bx,by+1,bz)
           b3 = index_b(bx,by,bz+1)
           do f = 1, fub
             escd_bcd = escd(b,f)
             int_new(f,b,1) = escd(b1,f) + BAx * escd_bcd
             int_new(f,b,2) = escd(b2,f) + BAy * escd_bcd
             int_new(f,b,3) = escd(b3,f) + BAz * escd_bcd
           end
         end

         do la=2, .a.l - 1
           alb              = (la-1).n_comp_sum
           aub              = la.n_comp
           bub              = ((.a.l+.b.l)-la).n_comp_sum - blb
           component_to_use => comp_to_use(alb+1:alb+aub)
           components_a     => components(:,alb+1:alb+aub)
           int_old          => int_new
           nullify(int_new)
           int_new.create(fub,bub,aub)
           do a=1,aub
             ax = components_a(1,a)
             ay = components_a(2,a)
             az = components_a(3,a)
             j=component_to_use(a)
             .subtract_from_component(ax,ay,az,j)
             a1 = index_a(ax,ay,az)
             BAi=BA(j)
             do b=1,bub
               bx = components_b(1,b)
               by = components_b(2,b)
               bz = components_b(3,b)
               .add_to_component(bx,by,bz,j)
               b1 = index_b(bx,by,bz)
               int_new(:,b,a)=int_old(:,b1,a1) + BAi * int_old(:,b,a1)
             end
           end
           int_old.destroy
         end

         alb              = (.a.l-1).n_comp_sum
         aub              = .a.n_comp
         bub              = .b.n_comp
         component_to_use => comp_to_use(alb+1:alb+aub)
         components_a     => components(:,alb+1:alb+aub)
         int_old          => int_new
         do a=1,aub
           ax = components_a(1,a)
           ay = components_a(2,a)
           az = components_a(3,a)
           j = component_to_use(a)
           .subtract_from_component(ax,ay,az,j)
           a1 = index_a(ax,ay,az)
           BAi=BA(j)
           do b=1,bub
             bx = components_b(1,b)
             by = components_b(2,b)
             bz = components_b(3,b)
             .add_to_component(bx,by,bz,j)
             b1 = index_b(bx,by,bz)
             do f=1,fub
               abcd(a,b,f)=int_old(f,b1,a1) + BAi * int_old(f,b,a1)
             end
           end
         end
         int_old.destroy
         comp_to_use.destroy
         components.destroy
         index_b.destroy
         index_a.destroy
     end
   end

   add_to_component(x,y,z,j) ::: private, always_pure
   ! Adds one to the component specified by j.  Used by transfer equation.
   ! j=1 => x=x+1, j=2 => y=y+1, j=3 => z=z+1.
     self :: IN
     x,y,z :: INT, INOUT
     j :: INT, IN
     select case(j)
       case (1); x = x + 1
       case (2); y = y + 1
       case (3); z = z + 1
     end
   end

   subtract_from_component(x,y,z,j) ::: private, always_pure
   ! Subtracts one from the component specified by j.  Used by transfer
   ! equation.  j=1 => x=x-1, j=2 => y=y-1, j=3 => z=z-1.
     self :: IN
     x,y,z :: INT, INOUT
     j :: INT, IN
     select case(j)
       case (1); x = x - 1
       case (2); y = y - 1
       case (3); z = z - 1
     end
   end

!*******************************************************************************
!                  Normalisation routines.
!*******************************************************************************

   to_normalise(abcd)
   ! Multiply the matrix by the orbital normalisation coefficients
   ! for the orbitals a, b, c and d.
     self :: IN
     abcd :: REALMAT4, INOUT
     aub,bub,cub,dub,a,b,c,d :: INT
     norm_d,norm_cd,norm_bcd :: REAL
     anorm,bnorm,cnorm,dnorm :: REALVEC*

     anorm.create(.a.l.n_comp);    anorm.normalising_factors(.a.l)
     bnorm.create(.b.l.n_comp);    bnorm.normalising_factors(.b.l)
     cnorm.create(.c.l.n_comp);    cnorm.normalising_factors(.c.l)
     dnorm.create(.d.l.n_comp);    dnorm.normalising_factors(.d.l)
     aub=.a.n_comp
     bub=.b.n_comp
     cub=.c.n_comp
     dub=.d.n_comp
     do d=1,dub
       norm_d = dnorm(d)
       do c=1,cub
         norm_cd = norm_d*cnorm(c)
         do b=1,bub
           norm_bcd = norm_cd*bnorm(b)
           do a=1,aub
             abcd(a,b,c,d)=abcd(a,b,c,d)*norm_bcd*anorm(a)
           end
         end
       end
     end
     dnorm.destroy
     cnorm.destroy
     bnorm.destroy
     anorm.destroy
   end

   to_normalise(X)
   ! Multiply the matrix by the orbital normalisation coefficients for the
   ! orbitals a, b, c and d.
     self :: IN
     X :: REALMAT5, INOUT
     i,dim :: INT
     dim = size(X,5)
     do i = 1,dim
        .to_normalise(X(:,:,:,:,i))
     end
   end

!*******************************************************************************
!       make the J and K contributions from the shell4 and density matrix.
!*******************************************************************************

   make_r_JK(J,K,P,factor,fa,la,fb,lb,fc,lc,fd,ld)
   ! Make the J and K contribution due to self and P and add it in.
   ! For any shell4!
     self :: IN
     P :: REALMAT, IN
     J,K :: REALMAT, target
     fa,la,fb,lb,fc,lc,fd,ld :: INT, IN
     factor :: REAL, IN
     I4 :: REALMAT4*
     Kc,Kd :: REALVEC*
     P_dc,Jcd,P_db,P_cb,Kbc,Kbd,I_abcd :: REAL
     a,b,c,d :: INT
     I4.create(fa,la,fb,lb,fc,lc,fd,ld)
     .get_ERI(I4)
     if (factor > 0.9) then
       do d = fd,ld
         Kd => K(:,d)
         do c = fc,lc
           P_dc = P(d,c)
           Kc => K(:,c)
           Jcd = ZERO
           do b = fb,lb
             P_db = P(d,b)
             P_cb = P(c,b)
             Kbc = ZERO
             Kbd = ZERO
             do a = fa,la
               I_abcd = I4(a,b,c,d)
               J(a,b) = J(a,b) + I_abcd*P_dc
               Kc(a)  = Kc(a)  + I_abcd*P_db
               Kd(a)  = Kd(a)  + I_abcd*P_cb
               Jcd    = Jcd    + I_abcd*P(b,a)
               Kbc    = Kbc    + I_abcd*P(d,a)
               Kbd    = Kbd    + I_abcd*P(c,a)
             end
             Kc(b) = Kc(b) + Kbc
             Kd(b) = Kd(b) + Kbd
           end
           J(c,d) = J(c,d) + Jcd
         end
       end
     else
       do d = fd,ld
         Kd => K(:,d)
         do c = fc,lc
           P_dc = factor*P(d,c)
           Kc => K(:,c)
           Jcd = ZERO
           do b = fb,lb
             P_db = factor*P(d,b)
             P_cb = factor*P(c,b)
             Kbc = ZERO
             Kbd = ZERO
             do a = fa,la
               I_abcd = I4(a,b,c,d)
               J(a,b) = J(a,b) + I_abcd*P_dc
               Kc(a)  = Kc(a)  + I_abcd*P_db
               Kd(a)  = Kd(a)  + I_abcd*P_cb
               Jcd    = Jcd    + I_abcd*P(b,a)
               Kbc    = Kbc    + I_abcd*P(d,a)
               Kbd    = Kbd    + I_abcd*P(c,a)
             end
             Kc(b) = Kc(b) + factor*Kbc
             Kd(b) = Kd(b) + factor*Kbd
           end
           J(c,d) = J(c,d) + factor*Jcd
         end
       end
     end
     I4.destroy
   end

!*******************************************************************************
!       make only the J contributions from the shell4 and density matrix.
!*******************************************************************************

   make_r_J(J,P,factor,fa,la,fb,lb,fc,lc,fd,ld)
   ! Make the J contribution due to self and P and add it in.
   ! For any shell4!
     self :: IN
     P :: REALMAT, IN
     J :: REALMAT, target
     fa,la,fb,lb,fc,lc,fd,ld :: INT, IN
     factor :: REAL, IN
     I4 :: REALMAT4*
     P_dc,Jcd,P_db,P_cb,I_abcd :: REAL
     a,b,c,d :: INT
     I4.create(fa,la,fb,lb,fc,lc,fd,ld)
     .get_ERI(I4)
     if (factor > 0.9) then
       do d = fd,ld
         do c = fc,lc
           P_dc = P(d,c)
           Jcd = ZERO
           do b = fb,lb
             P_db = P(d,b)
             P_cb = P(c,b)
             do a = fa,la
               I_abcd = I4(a,b,c,d)
               J(a,b) = J(a,b) + I_abcd*P_dc
               Jcd    = Jcd    + I_abcd*P(b,a)
             end
           end
           J(c,d) = J(c,d) + Jcd
         end
       end
     else
       do d = fd,ld
         do c = fc,lc
           P_dc = factor*P(d,c)
           Jcd = ZERO
           do b = fb,lb
             P_db = factor*P(d,b)
             P_cb = factor*P(c,b)
             do a = fa,la
               I_abcd = I4(a,b,c,d)
               J(a,b) = J(a,b) + I_abcd*P_dc
               Jcd    = Jcd    + I_abcd*P(b,a)
             end
           end
           J(c,d) = J(c,d) + factor*Jcd
         end
       end
     end
     I4.destroy
   end

!*******************************************************************************
!  Output Routines.
!*******************************************************************************

   put
   ! Put the shell4 information to file "out"
     n_cc,i :: INT
     stdout.flush
     stdout.show("A shell l quantum number =",.a.l)
     stdout.show("B shell l quantum number =",.b.l)
     stdout.show("C shell l quantum number =",.c.l)
     stdout.show("D shell l quantum number =",.d.l)
     stdout.show("A position               =",.a.pos)
     stdout.show("B position               =",.b.pos)
     stdout.show("C position               =",.c.pos)
     stdout.show("D position               =",.d.pos)
     stdout.flush
     stdout.dash(int_fields=1,real_fields=8)
     stdout.put("N", int_width=TRUE)
     stdout.put("ex_a")
     stdout.put("cc_a")
     stdout.put("ex_b")
     stdout.put("cc_b")
     stdout.put("ex_c")
     stdout.put("cc_c")
     stdout.put("ex_d")
     stdout.put("cc_d")
     stdout.flush
     stdout.dash(int_fields=1,real_fields=8)
     n_cc = max(.a.n_cc,.b.n_cc,.c.n_cc,.d.n_cc)
     do i = 1,n_cc
        stdout.put(i)
        if (i<=.a.n_cc) then
        stdout.put( .a.ex(i))
        stdout.put( .a.cc(i))
        else
        stdout.tab(real_fields=2)
        end
        if (i<=.b.n_cc) then
        stdout.put( .b.ex(i))
        stdout.put( .b.cc(i))
        else
        stdout.tab(real_fields=2)
        end
        if (i<=.c.n_cc) then
        stdout.put( .c.ex(i))
        stdout.put( .c.cc(i))
        else
        stdout.tab(real_fields=2)
        end
        if (i<=.d.n_cc) then
        stdout.put( .d.ex(i))
        stdout.put( .d.cc(i))
        else
        stdout.tab(real_fields=2)
        end
        stdout.flush
     end
     stdout.dash(int_fields=1,real_fields=8)
   end

end
